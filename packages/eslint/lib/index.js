(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('node:process'), require('node:assert'), require('node:readline')) :
	typeof define === 'function' && define.amd ? define(['node:process', 'node:assert', 'node:readline'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.process$4, global.assert$2, global.readline$1));
})(this, (function (process$4, assert$2, readline$1) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var commander = {};

	var argument = {};

	var error = {};

	/**
	 * CommanderError class
	 * @class
	 */
	let CommanderError$3 = class CommanderError extends Error {
	  /**
	   * Constructs the CommanderError class
	   * @param {number} exitCode suggested exit code which could be used with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   * @constructor
	   */
	  constructor(exitCode, code, message) {
	    super(message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	    this.code = code;
	    this.exitCode = exitCode;
	    this.nestedError = undefined;
	  }
	};

	/**
	 * InvalidArgumentError class
	 * @class
	 */
	let InvalidArgumentError$4 = class InvalidArgumentError extends CommanderError$3 {
	  /**
	   * Constructs the InvalidArgumentError class
	   * @param {string} [message] explanation of why argument is invalid
	   * @constructor
	   */
	  constructor(message) {
	    super(1, 'commander.invalidArgument', message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	  }
	};
	error.CommanderError = CommanderError$3;
	error.InvalidArgumentError = InvalidArgumentError$4;

	const {
	  InvalidArgumentError: InvalidArgumentError$3
	} = error;
	let Argument$3 = class Argument {
	  /**
	   * Initialize a new command argument with the given name and description.
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   */

	  constructor(name, description) {
	    this.description = description || '';
	    this.variadic = false;
	    this.parseArg = undefined;
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.argChoices = undefined;
	    switch (name[0]) {
	      case '<':
	        // e.g. <required>
	        this.required = true;
	        this._name = name.slice(1, -1);
	        break;
	      case '[':
	        // e.g. [optional]
	        this.required = false;
	        this._name = name.slice(1, -1);
	        break;
	      default:
	        this.required = true;
	        this._name = name;
	        break;
	    }
	    if (this._name.length > 3 && this._name.slice(-3) === '...') {
	      this.variadic = true;
	      this._name = this._name.slice(0, -3);
	    }
	  }

	  /**
	   * Return argument name.
	   *
	   * @return {string}
	   */

	  name() {
	    return this._name;
	  }

	  /**
	   * @package internal use only
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }
	    return previous.concat(value);
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Argument}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI command arguments into argument values.
	   *
	   * @param {Function} [fn]
	   * @return {Argument}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Only allow argument value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Argument}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError$3(`Allowed choices are ${this.argChoices.join(', ')}.`);
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Make argument required.
	   */
	  argRequired() {
	    this.required = true;
	    return this;
	  }

	  /**
	   * Make argument optional.
	   */
	  argOptional() {
	    this.required = false;
	    return this;
	  }
	};

	/**
	 * Takes an argument and returns its human readable equivalent for help usage.
	 *
	 * @param {Argument} arg
	 * @return {string}
	 * @private
	 */

	function humanReadableArgName$2(arg) {
	  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');
	  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
	}
	argument.Argument = Argument$3;
	argument.humanReadableArgName = humanReadableArgName$2;

	var command = {};

	var domain;

	// This constructor is used to store event handlers. Instantiating this is
	// faster than explicitly calling `Object.create(null)` to get a "clean" empty
	// object (tested with v8 v4.9).
	function EventHandlers() {}
	EventHandlers.prototype = Object.create(null);

	function EventEmitter$1() {
	  EventEmitter$1.init.call(this);
	}

	// nodejs oddity
	// require('events') === require('events').EventEmitter
	EventEmitter$1.EventEmitter = EventEmitter$1;

	EventEmitter$1.usingDomains = false;

	EventEmitter$1.prototype.domain = undefined;
	EventEmitter$1.prototype._events = undefined;
	EventEmitter$1.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter$1.defaultMaxListeners = 10;

	EventEmitter$1.init = function() {
	  this.domain = null;
	  if (EventEmitter$1.usingDomains) {
	    // if there is an active domain, then attach to it.
	    if (domain.active ) ;
	  }

	  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || isNaN(n))
	    throw new TypeError('"n" argument must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
	  if (isFn)
	    handler.call(self);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self);
	  }
	}
	function emitOne(handler, isFn, self, arg1) {
	  if (isFn)
	    handler.call(self, arg1);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1);
	  }
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
	  if (isFn)
	    handler.call(self, arg1, arg2);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2);
	  }
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
	  if (isFn)
	    handler.call(self, arg1, arg2, arg3);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2, arg3);
	  }
	}

	function emitMany(handler, isFn, self, args) {
	  if (isFn)
	    handler.apply(self, args);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].apply(self, args);
	  }
	}

	EventEmitter$1.prototype.emit = function emit(type) {
	  var er, handler, len, args, i, events, domain;
	  var doError = (type === 'error');

	  events = this._events;
	  if (events)
	    doError = (doError && events.error == null);
	  else if (!doError)
	    return false;

	  domain = this.domain;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    er = arguments[1];
	    if (domain) {
	      if (!er)
	        er = new Error('Uncaught, unspecified "error" event');
	      er.domainEmitter = this;
	      er.domain = domain;
	      er.domainThrown = false;
	      domain.emit('error', er);
	    } else if (er instanceof Error) {
	      throw er; // Unhandled 'error' event
	    } else {
	      // At least give some kind of context to the user
	      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	      err.context = er;
	      throw err;
	    }
	    return false;
	  }

	  handler = events[type];

	  if (!handler)
	    return false;

	  var isFn = typeof handler === 'function';
	  len = arguments.length;
	  switch (len) {
	    // fast cases
	    case 1:
	      emitNone(handler, isFn, this);
	      break;
	    case 2:
	      emitOne(handler, isFn, this, arguments[1]);
	      break;
	    case 3:
	      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
	      break;
	    case 4:
	      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
	      break;
	    // slower
	    default:
	      args = new Array(len - 1);
	      for (i = 1; i < len; i++)
	        args[i - 1] = arguments[i];
	      emitMany(handler, isFn, this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');

	  events = target._events;
	  if (!events) {
	    events = target._events = new EventHandlers();
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (!existing) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] :
	                                          [existing, listener];
	    } else {
	      // If we've already got an array, just append.
	      if (prepend) {
	        existing.unshift(listener);
	      } else {
	        existing.push(listener);
	      }
	    }

	    // Check for listener leak
	    if (!existing.warned) {
	      m = $getMaxListeners(target);
	      if (m && m > 0 && existing.length > m) {
	        existing.warned = true;
	        var w = new Error('Possible EventEmitter memory leak detected. ' +
	                            existing.length + ' ' + type + ' listeners added. ' +
	                            'Use emitter.setMaxListeners() to increase limit');
	        w.name = 'MaxListenersExceededWarning';
	        w.emitter = target;
	        w.type = type;
	        w.count = existing.length;
	        emitWarning(w);
	      }
	    }
	  }

	  return target;
	}
	function emitWarning(e) {
	  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
	}
	EventEmitter$1.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

	EventEmitter$1.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function _onceWrap(target, type, listener) {
	  var fired = false;
	  function g() {
	    target.removeListener(type, g);
	    if (!fired) {
	      fired = true;
	      listener.apply(target, arguments);
	    }
	  }
	  g.listener = listener;
	  return g;
	}

	EventEmitter$1.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter$1.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter$1.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');

	      events = this._events;
	      if (!events)
	        return this;

	      list = events[type];
	      if (!list)
	        return this;

	      if (list === listener || (list.listener && list.listener === listener)) {
	        if (--this._eventsCount === 0)
	          this._events = new EventHandlers();
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length; i-- > 0;) {
	          if (list[i] === listener ||
	              (list[i].listener && list[i].listener === listener)) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (list.length === 1) {
	          list[0] = undefined;
	          if (--this._eventsCount === 0) {
	            this._events = new EventHandlers();
	            return this;
	          } else {
	            delete events[type];
	          }
	        } else {
	          spliceOne(list, position);
	        }

	        if (events.removeListener)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };
	    
	// Alias for removeListener added in NodeJS 10.0
	// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
	EventEmitter$1.prototype.off = function(type, listener){
	    return this.removeListener(type, listener);
	};

	EventEmitter$1.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events;

	      events = this._events;
	      if (!events)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (!events.removeListener) {
	        if (arguments.length === 0) {
	          this._events = new EventHandlers();
	          this._eventsCount = 0;
	        } else if (events[type]) {
	          if (--this._eventsCount === 0)
	            this._events = new EventHandlers();
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        for (var i = 0, key; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = new EventHandlers();
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners) {
	        // LIFO order
	        do {
	          this.removeListener(type, listeners[listeners.length - 1]);
	        } while (listeners[0]);
	      }

	      return this;
	    };

	EventEmitter$1.prototype.listeners = function listeners(type) {
	  var evlistener;
	  var ret;
	  var events = this._events;

	  if (!events)
	    ret = [];
	  else {
	    evlistener = events[type];
	    if (!evlistener)
	      ret = [];
	    else if (typeof evlistener === 'function')
	      ret = [evlistener.listener || evlistener];
	    else
	      ret = unwrapListeners(evlistener);
	  }

	  return ret;
	};

	EventEmitter$1.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$1.call(emitter, type);
	  }
	};

	EventEmitter$1.prototype.listenerCount = listenerCount$1;
	function listenerCount$1(type) {
	  var events = this._events;

	  if (events) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};

	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
	    list[i] = list[k];
	  list.pop();
	}

	function arrayClone(arr, i) {
	  var copy = new Array(i);
	  while (i--)
	    copy[i] = arr[i];
	  return copy;
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	var _polyfillNode_events = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EventEmitter: EventEmitter$1,
		default: EventEmitter$1
	});

	var require$$0$8 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

	var _polyfillNode_child_process = {};

	var _polyfillNode_child_process$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _polyfillNode_child_process
	});

	var require$$1$5 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_child_process$1);

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	function resolve() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : '/';

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter$3(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	}
	// path.normalize(path)
	// posix version
	function normalize(path) {
	  var isPathAbsolute = isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter$3(path.split('/'), function(p) {
	    return !!p;
	  }), !isPathAbsolute).join('/');

	  if (!path && !isPathAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isPathAbsolute ? '/' : '') + path;
	}
	// posix version
	function isAbsolute(path) {
	  return path.charAt(0) === '/';
	}

	// posix version
	function join() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return normalize(filter$3(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	}


	// path.relative(from, to)
	// posix version
	function relative(from, to) {
	  from = resolve(from).substr(1);
	  to = resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	}

	var sep = '/';
	var delimiter = ':';

	function dirname(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	}

	function basename(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	}


	function extname(path) {
	  return splitPath(path)[3];
	}
	var path$e = {
	  extname: extname,
	  basename: basename,
	  dirname: dirname,
	  sep: sep,
	  delimiter: delimiter,
	  relative: relative,
	  join: join,
	  isAbsolute: isAbsolute,
	  normalize: normalize,
	  resolve: resolve
	};
	function filter$3 (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ?
	    function (str, start, len) { return str.substr(start, len) } :
	    function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	var _polyfillNode_path = /*#__PURE__*/Object.freeze({
		__proto__: null,
		basename: basename,
		default: path$e,
		delimiter: delimiter,
		dirname: dirname,
		extname: extname,
		isAbsolute: isAbsolute,
		join: join,
		normalize: normalize,
		relative: relative,
		resolve: resolve,
		sep: sep
	});

	var require$$1$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path);

	var fs$m = {};

	var _polyfillNode_fs = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: fs$m
	});

	var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs);

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue$1 = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue$1 = currentQueue.concat(queue$1);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue$1.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue$1.length;
	    while(len) {
	        currentQueue = queue$1;
	        queue$1 = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue$1.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue$1.push(new Item(fun, args));
	    if (queue$1.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform$2 = 'browser';
	var browser = true;
	var env$1 = {};
	var argv = [];
	var version$1 = ''; // empty string to avoid regexp issues
	var versions = {};
	var release$1 = {};
	var config$1 = {};

	function noop$2() {}

	var on = noop$2;
	var addListener = noop$2;
	var once = noop$2;
	var off = noop$2;
	var removeListener = noop$2;
	var removeAllListeners = noop$2;
	var emit$1 = noop$2;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd$1 () { return '/' }
	function chdir$1 (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime$1() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env$1,
	  argv: argv,
	  version: version$1,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit$1,
	  binding: binding,
	  cwd: cwd$1,
	  chdir: chdir$1,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform$2,
	  release: release$1,
	  config: config$1,
	  uptime: uptime$1
	};

	var _polyfillNode_process = /*#__PURE__*/Object.freeze({
		__proto__: null,
		addListener: addListener,
		argv: argv,
		binding: binding,
		browser: browser,
		chdir: chdir$1,
		config: config$1,
		cwd: cwd$1,
		default: browser$1,
		emit: emit$1,
		env: env$1,
		hrtime: hrtime,
		nextTick: nextTick,
		off: off,
		on: on,
		once: once,
		platform: platform$2,
		release: release$1,
		removeAllListeners: removeAllListeners,
		removeListener: removeListener,
		title: title,
		umask: umask,
		uptime: uptime$1,
		version: version$1,
		versions: versions
	});

	var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_process);

	var help = {};

	const {
	  humanReadableArgName: humanReadableArgName$1
	} = argument;

	/**
	 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
	 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
	 * @typedef { import("./argument.js").Argument } Argument
	 * @typedef { import("./command.js").Command } Command
	 * @typedef { import("./option.js").Option } Option
	 */

	// Although this is a class, methods are static in style to allow override using subclass or just functions.
	let Help$3 = class Help {
	  constructor() {
	    this.helpWidth = undefined;
	    this.sortSubcommands = false;
	    this.sortOptions = false;
	    this.showGlobalOptions = false;
	  }

	  /**
	   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Command[]}
	   */

	  visibleCommands(cmd) {
	    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
	    const helpCommand = cmd._getHelpCommand();
	    if (helpCommand && !helpCommand._hidden) {
	      visibleCommands.push(helpCommand);
	    }
	    if (this.sortSubcommands) {
	      visibleCommands.sort((a, b) => {
	        // @ts-ignore: overloaded return type
	        return a.name().localeCompare(b.name());
	      });
	    }
	    return visibleCommands;
	  }

	  /**
	   * Compare options for sort.
	   *
	   * @param {Option} a
	   * @param {Option} b
	   * @returns number
	   */
	  compareOptions(a, b) {
	    const getSortKey = option => {
	      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
	      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
	    };
	    return getSortKey(a).localeCompare(getSortKey(b));
	  }

	  /**
	   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleOptions(cmd) {
	    const visibleOptions = cmd.options.filter(option => !option.hidden);
	    // Built-in help option.
	    const helpOption = cmd._getHelpOption();
	    if (helpOption && !helpOption.hidden) {
	      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
	      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
	      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
	      if (!removeShort && !removeLong) {
	        visibleOptions.push(helpOption); // no changes needed
	      } else if (helpOption.long && !removeLong) {
	        visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
	      } else if (helpOption.short && !removeShort) {
	        visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
	      }
	    }
	    if (this.sortOptions) {
	      visibleOptions.sort(this.compareOptions);
	    }
	    return visibleOptions;
	  }

	  /**
	   * Get an array of the visible global options. (Not including help.)
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleGlobalOptions(cmd) {
	    if (!this.showGlobalOptions) return [];
	    const globalOptions = [];
	    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
	      const visibleOptions = ancestorCmd.options.filter(option => !option.hidden);
	      globalOptions.push(...visibleOptions);
	    }
	    if (this.sortOptions) {
	      globalOptions.sort(this.compareOptions);
	    }
	    return globalOptions;
	  }

	  /**
	   * Get an array of the arguments if any have a description.
	   *
	   * @param {Command} cmd
	   * @returns {Argument[]}
	   */

	  visibleArguments(cmd) {
	    // Side effect! Apply the legacy descriptions before the arguments are displayed.
	    if (cmd._argsDescription) {
	      cmd.registeredArguments.forEach(argument => {
	        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
	      });
	    }

	    // If there are any arguments with a description then return all the arguments.
	    if (cmd.registeredArguments.find(argument => argument.description)) {
	      return cmd.registeredArguments;
	    }
	    return [];
	  }

	  /**
	   * Get the command term to show in the list of subcommands.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandTerm(cmd) {
	    // Legacy. Ignores custom usage string, and nested commands.
	    const args = cmd.registeredArguments.map(arg => humanReadableArgName$1(arg)).join(' ');
	    return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + (
	    // simplistic check for non-help option
	    args ? ' ' + args : '');
	  }

	  /**
	   * Get the option term to show in the list of options.
	   *
	   * @param {Option} option
	   * @returns {string}
	   */

	  optionTerm(option) {
	    return option.flags;
	  }

	  /**
	   * Get the argument term to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @returns {string}
	   */

	  argumentTerm(argument) {
	    return argument.name();
	  }

	  /**
	   * Get the longest command term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestSubcommandTermLength(cmd, helper) {
	    return helper.visibleCommands(cmd).reduce((max, command) => {
	      return Math.max(max, helper.subcommandTerm(command).length);
	    }, 0);
	  }

	  /**
	   * Get the longest option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestOptionTermLength(cmd, helper) {
	    return helper.visibleOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest global option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestGlobalOptionTermLength(cmd, helper) {
	    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest argument term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestArgumentTermLength(cmd, helper) {
	    return helper.visibleArguments(cmd).reduce((max, argument) => {
	      return Math.max(max, helper.argumentTerm(argument).length);
	    }, 0);
	  }

	  /**
	   * Get the command usage to be displayed at the top of the built-in help.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandUsage(cmd) {
	    // Usage
	    let cmdName = cmd._name;
	    if (cmd._aliases[0]) {
	      cmdName = cmdName + '|' + cmd._aliases[0];
	    }
	    let ancestorCmdNames = '';
	    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
	      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
	    }
	    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
	  }

	  /**
	   * Get the description for the command.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandDescription(cmd) {
	    // @ts-ignore: overloaded return type
	    return cmd.description();
	  }

	  /**
	   * Get the subcommand summary to show in the list of subcommands.
	   * (Fallback to description for backwards compatibility.)
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandDescription(cmd) {
	    // @ts-ignore: overloaded return type
	    return cmd.summary() || cmd.description();
	  }

	  /**
	   * Get the option description to show in the list of options.
	   *
	   * @param {Option} option
	   * @return {string}
	   */

	  optionDescription(option) {
	    const extraInfo = [];
	    if (option.argChoices) {
	      extraInfo.push(
	      // use stringify to match the display of the default value
	      `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);
	    }
	    if (option.defaultValue !== undefined) {
	      // default for boolean and negated more for programmer than end user,
	      // but show true/false for boolean option as may be for hand-rolled env or config processing.
	      const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === 'boolean';
	      if (showDefault) {
	        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
	      }
	    }
	    // preset for boolean and negated are more for programmer than end user
	    if (option.presetArg !== undefined && option.optional) {
	      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
	    }
	    if (option.envVar !== undefined) {
	      extraInfo.push(`env: ${option.envVar}`);
	    }
	    if (extraInfo.length > 0) {
	      return `${option.description} (${extraInfo.join(', ')})`;
	    }
	    return option.description;
	  }

	  /**
	   * Get the argument description to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @return {string}
	   */

	  argumentDescription(argument) {
	    const extraInfo = [];
	    if (argument.argChoices) {
	      extraInfo.push(
	      // use stringify to match the display of the default value
	      `choices: ${argument.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);
	    }
	    if (argument.defaultValue !== undefined) {
	      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
	    }
	    if (extraInfo.length > 0) {
	      const extraDescripton = `(${extraInfo.join(', ')})`;
	      if (argument.description) {
	        return `${argument.description} ${extraDescripton}`;
	      }
	      return extraDescripton;
	    }
	    return argument.description;
	  }

	  /**
	   * Generate the built-in help text.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {string}
	   */

	  formatHelp(cmd, helper) {
	    const termWidth = helper.padWidth(cmd, helper);
	    const helpWidth = helper.helpWidth || 80;
	    const itemIndentWidth = 2;
	    const itemSeparatorWidth = 2; // between term and description
	    function formatItem(term, description) {
	      if (description) {
	        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
	        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
	      }
	      return term;
	    }
	    function formatList(textArray) {
	      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
	    }

	    // Usage
	    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

	    // Description
	    const commandDescription = helper.commandDescription(cmd);
	    if (commandDescription.length > 0) {
	      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);
	    }

	    // Arguments
	    const argumentList = helper.visibleArguments(cmd).map(argument => {
	      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
	    });
	    if (argumentList.length > 0) {
	      output = output.concat(['Arguments:', formatList(argumentList), '']);
	    }

	    // Options
	    const optionList = helper.visibleOptions(cmd).map(option => {
	      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
	    });
	    if (optionList.length > 0) {
	      output = output.concat(['Options:', formatList(optionList), '']);
	    }
	    if (this.showGlobalOptions) {
	      const globalOptionList = helper.visibleGlobalOptions(cmd).map(option => {
	        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
	      });
	      if (globalOptionList.length > 0) {
	        output = output.concat(['Global Options:', formatList(globalOptionList), '']);
	      }
	    }

	    // Commands
	    const commandList = helper.visibleCommands(cmd).map(cmd => {
	      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
	    });
	    if (commandList.length > 0) {
	      output = output.concat(['Commands:', formatList(commandList), '']);
	    }
	    return output.join('\n');
	  }

	  /**
	   * Calculate the pad width from the maximum term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  padWidth(cmd, helper) {
	    return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
	  }

	  /**
	   * Wrap the given string to width characters per line, with lines after the first indented.
	   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
	   *
	   * @param {string} str
	   * @param {number} width
	   * @param {number} indent
	   * @param {number} [minColumnWidth=40]
	   * @return {string}
	   *
	   */

	  wrap(str, width, indent, minColumnWidth = 40) {
	    // Full \s characters, minus the linefeeds.
	    const indents = ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
	    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
	    const manualIndent = new RegExp(`[\\n][${indents}]+`);
	    if (str.match(manualIndent)) return str;
	    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
	    const columnWidth = width - indent;
	    if (columnWidth < minColumnWidth) return str;
	    const leadingStr = str.slice(0, indent);
	    const columnText = str.slice(indent).replace('\r\n', '\n');
	    const indentString = ' '.repeat(indent);
	    const zeroWidthSpace = '\u200B';
	    const breaks = `\\s${zeroWidthSpace}`;
	    // Match line end (so empty lines don't collapse),
	    // or as much text as will fit in column, or excess text up to first break.
	    const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');
	    const lines = columnText.match(regex) || [];
	    return leadingStr + lines.map((line, i) => {
	      if (line === '\n') return ''; // preserve empty lines
	      return (i > 0 ? indentString : '') + line.trimEnd();
	    }).join('\n');
	  }
	};
	help.Help = Help$3;

	var option = {};

	const {
	  InvalidArgumentError: InvalidArgumentError$2
	} = error;
	let Option$3 = class Option {
	  /**
	   * Initialize a new `Option` with the given `flags` and `description`.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   */

	  constructor(flags, description) {
	    this.flags = flags;
	    this.description = description || '';
	    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
	    this.optional = flags.includes('['); // A value is optional when the option is specified.
	    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
	    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
	    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
	    const optionFlags = splitOptionFlags(flags);
	    this.short = optionFlags.shortFlag;
	    this.long = optionFlags.longFlag;
	    this.negate = false;
	    if (this.long) {
	      this.negate = this.long.startsWith('--no-');
	    }
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.presetArg = undefined;
	    this.envVar = undefined;
	    this.parseArg = undefined;
	    this.hidden = false;
	    this.argChoices = undefined;
	    this.conflictsWith = [];
	    this.implied = undefined;
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Option}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
	   * The custom processing (parseArg) is called.
	   *
	   * @example
	   * new Option('--color').default('GREYSCALE').preset('RGB');
	   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
	   *
	   * @param {*} arg
	   * @return {Option}
	   */

	  preset(arg) {
	    this.presetArg = arg;
	    return this;
	  }

	  /**
	   * Add option name(s) that conflict with this option.
	   * An error will be displayed if conflicting options are found during parsing.
	   *
	   * @example
	   * new Option('--rgb').conflicts('cmyk');
	   * new Option('--js').conflicts(['ts', 'jsx']);
	   *
	   * @param {(string | string[])} names
	   * @return {Option}
	   */

	  conflicts(names) {
	    this.conflictsWith = this.conflictsWith.concat(names);
	    return this;
	  }

	  /**
	   * Specify implied option values for when this option is set and the implied options are not.
	   *
	   * The custom processing (parseArg) is not called on the implied values.
	   *
	   * @example
	   * program
	   *   .addOption(new Option('--log', 'write logging information to file'))
	   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
	   *
	   * @param {Object} impliedOptionValues
	   * @return {Option}
	   */
	  implies(impliedOptionValues) {
	    let newImplied = impliedOptionValues;
	    if (typeof impliedOptionValues === 'string') {
	      // string is not documented, but easy mistake and we can do what user probably intended.
	      newImplied = {
	        [impliedOptionValues]: true
	      };
	    }
	    this.implied = Object.assign(this.implied || {}, newImplied);
	    return this;
	  }

	  /**
	   * Set environment variable to check for option value.
	   *
	   * An environment variable is only used if when processed the current option value is
	   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
	   *
	   * @param {string} name
	   * @return {Option}
	   */

	  env(name) {
	    this.envVar = name;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI option arguments into option values.
	   *
	   * @param {Function} [fn]
	   * @return {Option}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Whether the option is mandatory and must have a value after parsing.
	   *
	   * @param {boolean} [mandatory=true]
	   * @return {Option}
	   */

	  makeOptionMandatory(mandatory = true) {
	    this.mandatory = !!mandatory;
	    return this;
	  }

	  /**
	   * Hide option in help.
	   *
	   * @param {boolean} [hide=true]
	   * @return {Option}
	   */

	  hideHelp(hide = true) {
	    this.hidden = !!hide;
	    return this;
	  }

	  /**
	   * @package internal use only
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }
	    return previous.concat(value);
	  }

	  /**
	   * Only allow option value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Option}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError$2(`Allowed choices are ${this.argChoices.join(', ')}.`);
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Return option name.
	   *
	   * @return {string}
	   */

	  name() {
	    if (this.long) {
	      return this.long.replace(/^--/, '');
	    }
	    return this.short.replace(/^-/, '');
	  }

	  /**
	   * Return option name, in a camelcase format that can be used
	   * as a object attribute key.
	   *
	   * @return {string}
	   */

	  attributeName() {
	    return camelcase(this.name().replace(/^no-/, ''));
	  }

	  /**
	   * Check if `arg` matches the short or long flag.
	   *
	   * @param {string} arg
	   * @return {boolean}
	   * @package internal use only
	   */

	  is(arg) {
	    return this.short === arg || this.long === arg;
	  }

	  /**
	   * Return whether a boolean option.
	   *
	   * Options are one of boolean, negated, required argument, or optional argument.
	   *
	   * @return {boolean}
	   * @package internal use only
	   */

	  isBoolean() {
	    return !this.required && !this.optional && !this.negate;
	  }
	};

	/**
	 * This class is to make it easier to work with dual options, without changing the existing
	 * implementation. We support separate dual options for separate positive and negative options,
	 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
	 * use cases, but is tricky for others where we want separate behaviours despite
	 * the single shared option value.
	 */
	let DualOptions$1 = class DualOptions {
	  /**
	   * @param {Option[]} options
	   */
	  constructor(options) {
	    this.positiveOptions = new Map();
	    this.negativeOptions = new Map();
	    this.dualOptions = new Set();
	    options.forEach(option => {
	      if (option.negate) {
	        this.negativeOptions.set(option.attributeName(), option);
	      } else {
	        this.positiveOptions.set(option.attributeName(), option);
	      }
	    });
	    this.negativeOptions.forEach((value, key) => {
	      if (this.positiveOptions.has(key)) {
	        this.dualOptions.add(key);
	      }
	    });
	  }

	  /**
	   * Did the value come from the option, and not from possible matching dual option?
	   *
	   * @param {*} value
	   * @param {Option} option
	   * @returns {boolean}
	   */
	  valueFromOption(value, option) {
	    const optionKey = option.attributeName();
	    if (!this.dualOptions.has(optionKey)) return true;

	    // Use the value to deduce if (probably) came from the option.
	    const preset = this.negativeOptions.get(optionKey).presetArg;
	    const negativeValue = preset !== undefined ? preset : false;
	    return option.negate === (negativeValue === value);
	  }
	};

	/**
	 * Convert string from kebab-case to camelCase.
	 *
	 * @param {string} str
	 * @return {string}
	 * @private
	 */

	function camelcase(str) {
	  return str.split('-').reduce((str, word) => {
	    return str + word[0].toUpperCase() + word.slice(1);
	  });
	}

	/**
	 * Split the short and long flag out of something like '-m,--mixed <value>'
	 *
	 * @private
	 */

	function splitOptionFlags(flags) {
	  let shortFlag;
	  let longFlag;
	  // Use original very loose parsing to maintain backwards compatibility for now,
	  // which allowed for example unintended `-sw, --short-word` [sic].
	  const flagParts = flags.split(/[ |,]+/);
	  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
	  longFlag = flagParts.shift();
	  // Add support for lone short flag without significantly changing parsing!
	  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
	    shortFlag = longFlag;
	    longFlag = undefined;
	  }
	  return {
	    shortFlag,
	    longFlag
	  };
	}
	option.Option = Option$3;
	option.DualOptions = DualOptions$1;

	var suggestSimilar$2 = {};

	const maxDistance = 3;
	function editDistance(a, b) {
	  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance
	  // Calculating optimal string alignment distance, no substring is edited more than once.
	  // (Simple implementation.)

	  // Quick early exit, return worst case.
	  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);

	  // distance between prefix substrings of a and b
	  const d = [];

	  // pure deletions turn a into empty string
	  for (let i = 0; i <= a.length; i++) {
	    d[i] = [i];
	  }
	  // pure insertions turn empty string into b
	  for (let j = 0; j <= b.length; j++) {
	    d[0][j] = j;
	  }

	  // fill matrix
	  for (let j = 1; j <= b.length; j++) {
	    for (let i = 1; i <= a.length; i++) {
	      let cost = 1;
	      if (a[i - 1] === b[j - 1]) {
	        cost = 0;
	      } else {
	        cost = 1;
	      }
	      d[i][j] = Math.min(d[i - 1][j] + 1,
	      // deletion
	      d[i][j - 1] + 1,
	      // insertion
	      d[i - 1][j - 1] + cost // substitution
	      );
	      // transposition
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
	      }
	    }
	  }
	  return d[a.length][b.length];
	}

	/**
	 * Find close matches, restricted to same number of edits.
	 *
	 * @param {string} word
	 * @param {string[]} candidates
	 * @returns {string}
	 */

	function suggestSimilar$1(word, candidates) {
	  if (!candidates || candidates.length === 0) return '';
	  // remove possible duplicates
	  candidates = Array.from(new Set(candidates));
	  const searchingOptions = word.startsWith('--');
	  if (searchingOptions) {
	    word = word.slice(2);
	    candidates = candidates.map(candidate => candidate.slice(2));
	  }
	  let similar = [];
	  let bestDistance = maxDistance;
	  const minSimilarity = 0.4;
	  candidates.forEach(candidate => {
	    if (candidate.length <= 1) return; // no one character guesses

	    const distance = editDistance(word, candidate);
	    const length = Math.max(word.length, candidate.length);
	    const similarity = (length - distance) / length;
	    if (similarity > minSimilarity) {
	      if (distance < bestDistance) {
	        // better edit distance, throw away previous worse matches
	        bestDistance = distance;
	        similar = [candidate];
	      } else if (distance === bestDistance) {
	        similar.push(candidate);
	      }
	    }
	  });
	  similar.sort((a, b) => a.localeCompare(b));
	  if (searchingOptions) {
	    similar = similar.map(candidate => `--${candidate}`);
	  }
	  if (similar.length > 1) {
	    return `\n(Did you mean one of ${similar.join(', ')}?)`;
	  }
	  if (similar.length === 1) {
	    return `\n(Did you mean ${similar[0]}?)`;
	  }
	  return '';
	}
	suggestSimilar$2.suggestSimilar = suggestSimilar$1;

	const EventEmitter = require$$0$8.EventEmitter;
	const childProcess = require$$1$5;
	const path$d = require$$1$4;
	const fs$l = require$$2$2;
	const process$3 = require$$4$1;
	const {
	  Argument: Argument$2,
	  humanReadableArgName
	} = argument;
	const {
	  CommanderError: CommanderError$2
	} = error;
	const {
	  Help: Help$2
	} = help;
	const {
	  Option: Option$2,
	  DualOptions
	} = option;
	const {
	  suggestSimilar
	} = suggestSimilar$2;
	let Command$2 = class Command extends EventEmitter {
	  /**
	   * Initialize a new `Command`.
	   *
	   * @param {string} [name]
	   */

	  constructor(name) {
	    super();
	    /** @type {Command[]} */
	    this.commands = [];
	    /** @type {Option[]} */
	    this.options = [];
	    this.parent = null;
	    this._allowUnknownOption = false;
	    this._allowExcessArguments = true;
	    /** @type {Argument[]} */
	    this.registeredArguments = [];
	    this._args = this.registeredArguments; // deprecated old name
	    /** @type {string[]} */
	    this.args = []; // cli args with options removed
	    this.rawArgs = [];
	    this.processedArgs = []; // like .args but after custom processing and collecting variadic
	    this._scriptPath = null;
	    this._name = name || '';
	    this._optionValues = {};
	    this._optionValueSources = {}; // default, env, cli etc
	    this._storeOptionsAsProperties = false;
	    this._actionHandler = null;
	    this._executableHandler = false;
	    this._executableFile = null; // custom name for executable
	    this._executableDir = null; // custom search directory for subcommands
	    this._defaultCommandName = null;
	    this._exitCallback = null;
	    this._aliases = [];
	    this._combineFlagAndOptionalValue = true;
	    this._description = '';
	    this._summary = '';
	    this._argsDescription = undefined; // legacy
	    this._enablePositionalOptions = false;
	    this._passThroughOptions = false;
	    this._lifeCycleHooks = {}; // a hash of arrays
	    /** @type {(boolean | string)} */
	    this._showHelpAfterError = false;
	    this._showSuggestionAfterError = true;

	    // see .configureOutput() for docs
	    this._outputConfiguration = {
	      writeOut: str => process$3.stdout.write(str),
	      writeErr: str => process$3.stderr.write(str),
	      getOutHelpWidth: () => process$3.stdout.isTTY ? process$3.stdout.columns : undefined,
	      getErrHelpWidth: () => process$3.stderr.isTTY ? process$3.stderr.columns : undefined,
	      outputError: (str, write) => write(str)
	    };
	    this._hidden = false;
	    /** @type {(Option | null | undefined)} */
	    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
	    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
	    /** @type {Command} */
	    this._helpCommand = undefined; // lazy initialised, inherited
	    this._helpConfiguration = {};
	  }

	  /**
	   * Copy settings that are useful to have in common across root command and subcommands.
	   *
	   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
	   *
	   * @param {Command} sourceCommand
	   * @return {Command} `this` command for chaining
	   */
	  copyInheritedSettings(sourceCommand) {
	    this._outputConfiguration = sourceCommand._outputConfiguration;
	    this._helpOption = sourceCommand._helpOption;
	    this._helpCommand = sourceCommand._helpCommand;
	    this._helpConfiguration = sourceCommand._helpConfiguration;
	    this._exitCallback = sourceCommand._exitCallback;
	    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
	    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
	    this._allowExcessArguments = sourceCommand._allowExcessArguments;
	    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
	    this._showHelpAfterError = sourceCommand._showHelpAfterError;
	    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
	    return this;
	  }

	  /**
	   * @returns {Command[]}
	   * @private
	   */

	  _getCommandAndAncestors() {
	    const result = [];
	    for (let command = this; command; command = command.parent) {
	      result.push(command);
	    }
	    return result;
	  }

	  /**
	   * Define a command.
	   *
	   * There are two styles of command: pay attention to where to put the description.
	   *
	   * @example
	   * // Command implemented using action handler (description is supplied separately to `.command`)
	   * program
	   *   .command('clone <source> [destination]')
	   *   .description('clone a repository into a newly created directory')
	   *   .action((source, destination) => {
	   *     console.log('clone command called');
	   *   });
	   *
	   * // Command implemented using separate executable file (description is second parameter to `.command`)
	   * program
	   *   .command('start <service>', 'start named service')
	   *   .command('stop [service]', 'stop named service, or all if no name supplied');
	   *
	   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
	   * @param {(Object|string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
	   * @param {Object} [execOpts] - configuration options (for executable)
	   * @return {Command} returns new command for action handler, or `this` for executable command
	   */

	  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
	    let desc = actionOptsOrExecDesc;
	    let opts = execOpts;
	    if (typeof desc === 'object' && desc !== null) {
	      opts = desc;
	      desc = null;
	    }
	    opts = opts || {};
	    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
	    const cmd = this.createCommand(name);
	    if (desc) {
	      cmd.description(desc);
	      cmd._executableHandler = true;
	    }
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
	    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
	    if (args) cmd.arguments(args);
	    this._registerCommand(cmd);
	    cmd.parent = this;
	    cmd.copyInheritedSettings(this);
	    if (desc) return this;
	    return cmd;
	  }

	  /**
	   * Factory routine to create a new unattached command.
	   *
	   * See .command() for creating an attached subcommand, which uses this routine to
	   * create the command. You can override createCommand to customise subcommands.
	   *
	   * @param {string} [name]
	   * @return {Command} new command
	   */

	  createCommand(name) {
	    return new Command(name);
	  }

	  /**
	   * You can customise the help with a subclass of Help by overriding createHelp,
	   * or by overriding Help properties using configureHelp().
	   *
	   * @return {Help}
	   */

	  createHelp() {
	    return Object.assign(new Help$2(), this.configureHelp());
	  }

	  /**
	   * You can customise the help by overriding Help properties using configureHelp(),
	   * or with a subclass of Help by overriding createHelp().
	   *
	   * @param {Object} [configuration] - configuration options
	   * @return {(Command|Object)} `this` command for chaining, or stored configuration
	   */

	  configureHelp(configuration) {
	    if (configuration === undefined) return this._helpConfiguration;
	    this._helpConfiguration = configuration;
	    return this;
	  }

	  /**
	   * The default output goes to stdout and stderr. You can customise this for special
	   * applications. You can also customise the display of errors by overriding outputError.
	   *
	   * The configuration properties are all functions:
	   *
	   *     // functions to change where being written, stdout and stderr
	   *     writeOut(str)
	   *     writeErr(str)
	   *     // matching functions to specify width for wrapping help
	   *     getOutHelpWidth()
	   *     getErrHelpWidth()
	   *     // functions based on what is being written out
	   *     outputError(str, write) // used for displaying errors, and not used for displaying help
	   *
	   * @param {Object} [configuration] - configuration options
	   * @return {(Command|Object)} `this` command for chaining, or stored configuration
	   */

	  configureOutput(configuration) {
	    if (configuration === undefined) return this._outputConfiguration;
	    Object.assign(this._outputConfiguration, configuration);
	    return this;
	  }

	  /**
	   * Display the help or a custom message after an error occurs.
	   *
	   * @param {(boolean|string)} [displayHelp]
	   * @return {Command} `this` command for chaining
	   */
	  showHelpAfterError(displayHelp = true) {
	    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
	    this._showHelpAfterError = displayHelp;
	    return this;
	  }

	  /**
	   * Display suggestion of similar commands for unknown commands, or options for unknown options.
	   *
	   * @param {boolean} [displaySuggestion]
	   * @return {Command} `this` command for chaining
	   */
	  showSuggestionAfterError(displaySuggestion = true) {
	    this._showSuggestionAfterError = !!displaySuggestion;
	    return this;
	  }

	  /**
	   * Add a prepared subcommand.
	   *
	   * See .command() for creating an attached subcommand which inherits settings from its parent.
	   *
	   * @param {Command} cmd - new subcommand
	   * @param {Object} [opts] - configuration options
	   * @return {Command} `this` command for chaining
	   */

	  addCommand(cmd, opts) {
	    if (!cmd._name) {
	      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
	    }
	    opts = opts || {};
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

	    this._registerCommand(cmd);
	    cmd.parent = this;
	    cmd._checkForBrokenPassThrough();
	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached argument.
	   *
	   * See .argument() for creating an attached argument, which uses this routine to
	   * create the argument. You can override createArgument to return a custom argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @return {Argument} new argument
	   */

	  createArgument(name, description) {
	    return new Argument$2(name, description);
	  }

	  /**
	   * Define argument syntax for command.
	   *
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @example
	   * program.argument('<input-file>');
	   * program.argument('[output-file]');
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @param {(Function|*)} [fn] - custom argument processing function
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */
	  argument(name, description, fn, defaultValue) {
	    const argument = this.createArgument(name, description);
	    if (typeof fn === 'function') {
	      argument.default(defaultValue).argParser(fn);
	    } else {
	      argument.default(fn);
	    }
	    this.addArgument(argument);
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding multiple at once (without descriptions).
	   *
	   * See also .argument().
	   *
	   * @example
	   * program.arguments('<cmd> [env]');
	   *
	   * @param {string} names
	   * @return {Command} `this` command for chaining
	   */

	  arguments(names) {
	    names.trim().split(/ +/).forEach(detail => {
	      this.argument(detail);
	    });
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding a prepared argument.
	   *
	   * @param {Argument} argument
	   * @return {Command} `this` command for chaining
	   */
	  addArgument(argument) {
	    const previousArgument = this.registeredArguments.slice(-1)[0];
	    if (previousArgument && previousArgument.variadic) {
	      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
	    }
	    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
	      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
	    }
	    this.registeredArguments.push(argument);
	    return this;
	  }

	  /**
	   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
	   *
	   *    program.helpCommand('help [cmd]');
	   *    program.helpCommand('help [cmd]', 'show help');
	   *    program.helpCommand(false); // suppress default help command
	   *    program.helpCommand(true); // add help command even if no subcommands
	   *
	   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
	   * @param {string} [description] - custom description
	   * @return {Command} `this` command for chaining
	   */

	  helpCommand(enableOrNameAndArgs, description) {
	    if (typeof enableOrNameAndArgs === 'boolean') {
	      this._addImplicitHelpCommand = enableOrNameAndArgs;
	      return this;
	    }
	    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
	    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
	    const helpDescription = description ?? 'display help for command';
	    const helpCommand = this.createCommand(helpName);
	    helpCommand.helpOption(false);
	    if (helpArgs) helpCommand.arguments(helpArgs);
	    if (helpDescription) helpCommand.description(helpDescription);
	    this._addImplicitHelpCommand = true;
	    this._helpCommand = helpCommand;
	    return this;
	  }

	  /**
	   * Add prepared custom help command.
	   *
	   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
	   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
	   * @return {Command} `this` command for chaining
	   */
	  addHelpCommand(helpCommand, deprecatedDescription) {
	    // If not passed an object, call through to helpCommand for backwards compatibility,
	    // as addHelpCommand was originally used like helpCommand is now.
	    if (typeof helpCommand !== 'object') {
	      this.helpCommand(helpCommand, deprecatedDescription);
	      return this;
	    }
	    this._addImplicitHelpCommand = true;
	    this._helpCommand = helpCommand;
	    return this;
	  }

	  /**
	   * Lazy create help command.
	   *
	   * @return {(Command|null)}
	   * @package
	   */
	  _getHelpCommand() {
	    const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand('help'));
	    if (hasImplicitHelpCommand) {
	      if (this._helpCommand === undefined) {
	        this.helpCommand(undefined, undefined); // use default name and description
	      }
	      return this._helpCommand;
	    }
	    return null;
	  }

	  /**
	   * Add hook for life cycle event.
	   *
	   * @param {string} event
	   * @param {Function} listener
	   * @return {Command} `this` command for chaining
	   */

	  hook(event, listener) {
	    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
	    if (!allowedValues.includes(event)) {
	      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    if (this._lifeCycleHooks[event]) {
	      this._lifeCycleHooks[event].push(listener);
	    } else {
	      this._lifeCycleHooks[event] = [listener];
	    }
	    return this;
	  }

	  /**
	   * Register callback to use as replacement for calling process.exit.
	   *
	   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
	   * @return {Command} `this` command for chaining
	   */

	  exitOverride(fn) {
	    if (fn) {
	      this._exitCallback = fn;
	    } else {
	      this._exitCallback = err => {
	        if (err.code !== 'commander.executeSubCommandAsync') {
	          throw err;
	        }
	      };
	    }
	    return this;
	  }

	  /**
	   * Call process.exit, and _exitCallback if defined.
	   *
	   * @param {number} exitCode exit code for using with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   * @return never
	   * @private
	   */

	  _exit(exitCode, code, message) {
	    if (this._exitCallback) {
	      this._exitCallback(new CommanderError$2(exitCode, code, message));
	      // Expecting this line is not reached.
	    }
	    process$3.exit(exitCode);
	  }

	  /**
	   * Register callback `fn` for the command.
	   *
	   * @example
	   * program
	   *   .command('serve')
	   *   .description('start service')
	   *   .action(function() {
	   *      // do work here
	   *   });
	   *
	   * @param {Function} fn
	   * @return {Command} `this` command for chaining
	   */

	  action(fn) {
	    const listener = args => {
	      // The .action callback takes an extra parameter which is the command or options.
	      const expectedArgsCount = this.registeredArguments.length;
	      const actionArgs = args.slice(0, expectedArgsCount);
	      if (this._storeOptionsAsProperties) {
	        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
	      } else {
	        actionArgs[expectedArgsCount] = this.opts();
	      }
	      actionArgs.push(this);
	      return fn.apply(this, actionArgs);
	    };
	    this._actionHandler = listener;
	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached option.
	   *
	   * See .option() for creating an attached option, which uses this routine to
	   * create the option. You can override createOption to return a custom option.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @return {Option} new option
	   */

	  createOption(flags, description) {
	    return new Option$2(flags, description);
	  }

	  /**
	   * Wrap parseArgs to catch 'commander.invalidArgument'.
	   *
	   * @param {(Option | Argument)} target
	   * @param {string} value
	   * @param {*} previous
	   * @param {string} invalidArgumentMessage
	   * @private
	   */

	  _callParseArg(target, value, previous, invalidArgumentMessage) {
	    try {
	      return target.parseArg(value, previous);
	    } catch (err) {
	      if (err.code === 'commander.invalidArgument') {
	        const message = `${invalidArgumentMessage} ${err.message}`;
	        this.error(message, {
	          exitCode: err.exitCode,
	          code: err.code
	        });
	      }
	      throw err;
	    }
	  }

	  /**
	   * Check for option flag conflicts.
	   * Register option if no conflicts found, or throw on conflict.
	   *
	   * @param {Option} option
	   * @api private
	   */

	  _registerOption(option) {
	    const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
	    if (matchingOption) {
	      const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
	      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
	    }
	    this.options.push(option);
	  }

	  /**
	   * Check for command name and alias conflicts with existing commands.
	   * Register command if no conflicts found, or throw on conflict.
	   *
	   * @param {Command} command
	   * @api private
	   */

	  _registerCommand(command) {
	    const knownBy = cmd => {
	      return [cmd.name()].concat(cmd.aliases());
	    };
	    const alreadyUsed = knownBy(command).find(name => this._findCommand(name));
	    if (alreadyUsed) {
	      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
	      const newCmd = knownBy(command).join('|');
	      throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
	    }
	    this.commands.push(command);
	  }

	  /**
	   * Add an option.
	   *
	   * @param {Option} option
	   * @return {Command} `this` command for chaining
	   */
	  addOption(option) {
	    this._registerOption(option);
	    const oname = option.name();
	    const name = option.attributeName();

	    // store default value
	    if (option.negate) {
	      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
	      const positiveLongFlag = option.long.replace(/^--no-/, '--');
	      if (!this._findOption(positiveLongFlag)) {
	        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');
	      }
	    } else if (option.defaultValue !== undefined) {
	      this.setOptionValueWithSource(name, option.defaultValue, 'default');
	    }

	    // handler for cli and env supplied values
	    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
	      // val is null for optional option used without an optional-argument.
	      // val is undefined for boolean and negated option.
	      if (val == null && option.presetArg !== undefined) {
	        val = option.presetArg;
	      }

	      // custom processing
	      const oldValue = this.getOptionValue(name);
	      if (val !== null && option.parseArg) {
	        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
	      } else if (val !== null && option.variadic) {
	        val = option._concatValue(val, oldValue);
	      }

	      // Fill-in appropriate missing values. Long winded but easy to follow.
	      if (val == null) {
	        if (option.negate) {
	          val = false;
	        } else if (option.isBoolean() || option.optional) {
	          val = true;
	        } else {
	          val = ''; // not normal, parseArg might have failed or be a mock function for testing
	        }
	      }
	      this.setOptionValueWithSource(name, val, valueSource);
	    };
	    this.on('option:' + oname, val => {
	      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
	      handleOptionValue(val, invalidValueMessage, 'cli');
	    });
	    if (option.envVar) {
	      this.on('optionEnv:' + oname, val => {
	        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
	        handleOptionValue(val, invalidValueMessage, 'env');
	      });
	    }
	    return this;
	  }

	  /**
	   * Internal implementation shared by .option() and .requiredOption()
	   *
	   * @private
	   */
	  _optionEx(config, flags, description, fn, defaultValue) {
	    if (typeof flags === 'object' && flags instanceof Option$2) {
	      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
	    }
	    const option = this.createOption(flags, description);
	    option.makeOptionMandatory(!!config.mandatory);
	    if (typeof fn === 'function') {
	      option.default(defaultValue).argParser(fn);
	    } else if (fn instanceof RegExp) {
	      // deprecated
	      const regex = fn;
	      fn = (val, def) => {
	        const m = regex.exec(val);
	        return m ? m[0] : def;
	      };
	      option.default(defaultValue).argParser(fn);
	    } else {
	      option.default(fn);
	    }
	    return this.addOption(option);
	  }

	  /**
	   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
	   *
	   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
	   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
	   *
	   * See the README for more details, and see also addOption() and requiredOption().
	   *
	   * @example
	   * program
	   *     .option('-p, --pepper', 'add pepper')
	   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
	   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
	   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @param {(Function|*)} [parseArg] - custom option processing function or default value
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */

	  option(flags, description, parseArg, defaultValue) {
	    return this._optionEx({}, flags, description, parseArg, defaultValue);
	  }

	  /**
	  * Add a required option which must have a value after parsing. This usually means
	  * the option must be specified on the command line. (Otherwise the same as .option().)
	  *
	  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
	  *
	  * @param {string} flags
	  * @param {string} [description]
	  * @param {(Function|*)} [parseArg] - custom option processing function or default value
	  * @param {*} [defaultValue]
	  * @return {Command} `this` command for chaining
	  */

	  requiredOption(flags, description, parseArg, defaultValue) {
	    return this._optionEx({
	      mandatory: true
	    }, flags, description, parseArg, defaultValue);
	  }

	  /**
	   * Alter parsing of short flags with optional values.
	   *
	   * @example
	   * // for `.option('-f,--flag [value]'):
	   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
	   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
	   *
	   * @param {boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
	   */
	  combineFlagAndOptionalValue(combine = true) {
	    this._combineFlagAndOptionalValue = !!combine;
	    return this;
	  }

	  /**
	   * Allow unknown options on the command line.
	   *
	   * @param {boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
	   * for unknown options.
	   */
	  allowUnknownOption(allowUnknown = true) {
	    this._allowUnknownOption = !!allowUnknown;
	    return this;
	  }

	  /**
	   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
	   *
	   * @param {boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
	   * for excess arguments.
	   */
	  allowExcessArguments(allowExcess = true) {
	    this._allowExcessArguments = !!allowExcess;
	    return this;
	  }

	  /**
	   * Enable positional options. Positional means global options are specified before subcommands which lets
	   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
	   * The default behaviour is non-positional and global options may appear anywhere on the command line.
	   *
	   * @param {boolean} [positional=true]
	   */
	  enablePositionalOptions(positional = true) {
	    this._enablePositionalOptions = !!positional;
	    return this;
	  }

	  /**
	   * Pass through options that come after command-arguments rather than treat them as command-options,
	   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
	   * positional options to have been enabled on the program (parent commands).
	   * The default behaviour is non-positional and options may appear before or after command-arguments.
	   *
	   * @param {boolean} [passThrough=true]
	   * for unknown options.
	   */
	  passThroughOptions(passThrough = true) {
	    this._passThroughOptions = !!passThrough;
	    this._checkForBrokenPassThrough();
	    return this;
	  }

	  /**
	   * @private
	   */

	  _checkForBrokenPassThrough() {
	    if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
	      throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
	    }
	  }

	  /**
	    * Whether to store option values as properties on command object,
	    * or store separately (specify false). In both cases the option values can be accessed using .opts().
	    *
	    * @param {boolean} [storeAsProperties=true]
	    * @return {Command} `this` command for chaining
	    */

	  storeOptionsAsProperties(storeAsProperties = true) {
	    if (this.options.length) {
	      throw new Error('call .storeOptionsAsProperties() before adding options');
	    }
	    if (Object.keys(this._optionValues).length) {
	      throw new Error('call .storeOptionsAsProperties() before setting option values');
	    }
	    this._storeOptionsAsProperties = !!storeAsProperties;
	    return this;
	  }

	  /**
	   * Retrieve option value.
	   *
	   * @param {string} key
	   * @return {Object} value
	   */

	  getOptionValue(key) {
	    if (this._storeOptionsAsProperties) {
	      return this[key];
	    }
	    return this._optionValues[key];
	  }

	  /**
	   * Store option value.
	   *
	   * @param {string} key
	   * @param {Object} value
	   * @return {Command} `this` command for chaining
	   */

	  setOptionValue(key, value) {
	    return this.setOptionValueWithSource(key, value, undefined);
	  }

	  /**
	    * Store option value and where the value came from.
	    *
	    * @param {string} key
	    * @param {Object} value
	    * @param {string} source - expected values are default/config/env/cli/implied
	    * @return {Command} `this` command for chaining
	    */

	  setOptionValueWithSource(key, value, source) {
	    if (this._storeOptionsAsProperties) {
	      this[key] = value;
	    } else {
	      this._optionValues[key] = value;
	    }
	    this._optionValueSources[key] = source;
	    return this;
	  }

	  /**
	    * Get source of option value.
	    * Expected values are default | config | env | cli | implied
	    *
	    * @param {string} key
	    * @return {string}
	    */

	  getOptionValueSource(key) {
	    return this._optionValueSources[key];
	  }

	  /**
	    * Get source of option value. See also .optsWithGlobals().
	    * Expected values are default | config | env | cli | implied
	    *
	    * @param {string} key
	    * @return {string}
	    */

	  getOptionValueSourceWithGlobals(key) {
	    // global overwrites local, like optsWithGlobals
	    let source;
	    this._getCommandAndAncestors().forEach(cmd => {
	      if (cmd.getOptionValueSource(key) !== undefined) {
	        source = cmd.getOptionValueSource(key);
	      }
	    });
	    return source;
	  }

	  /**
	   * Get user arguments from implied or explicit arguments.
	   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
	   *
	   * @private
	   */

	  _prepareUserArgs(argv, parseOptions) {
	    if (argv !== undefined && !Array.isArray(argv)) {
	      throw new Error('first parameter to parse must be array or undefined');
	    }
	    parseOptions = parseOptions || {};

	    // Default to using process.argv
	    if (argv === undefined) {
	      argv = process$3.argv;
	      // @ts-ignore: unknown property
	      if (process$3.versions && process$3.versions.electron) {
	        parseOptions.from = 'electron';
	      }
	    }
	    this.rawArgs = argv.slice();

	    // make it a little easier for callers by supporting various argv conventions
	    let userArgs;
	    switch (parseOptions.from) {
	      case undefined:
	      case 'node':
	        this._scriptPath = argv[1];
	        userArgs = argv.slice(2);
	        break;
	      case 'electron':
	        // @ts-ignore: unknown property
	        if (process$3.defaultApp) {
	          this._scriptPath = argv[1];
	          userArgs = argv.slice(2);
	        } else {
	          userArgs = argv.slice(1);
	        }
	        break;
	      case 'user':
	        userArgs = argv.slice(0);
	        break;
	      default:
	        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
	    }

	    // Find default name for program from arguments.
	    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
	    this._name = this._name || 'program';
	    return userArgs;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * The default expectation is that the arguments are from node and have the application as argv[0]
	   * and the script being run in argv[1], with user parameters after that.
	   *
	   * @example
	   * program.parse(process.argv);
	   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
	   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv] - optional, defaults to process.argv
	   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
	   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
	   * @return {Command} `this` command for chaining
	   */

	  parse(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    this._parseCommand([], userArgs);
	    return this;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
	   *
	   * The default expectation is that the arguments are from node and have the application as argv[0]
	   * and the script being run in argv[1], with user parameters after that.
	   *
	   * @example
	   * await program.parseAsync(process.argv);
	   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
	   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv]
	   * @param {Object} [parseOptions]
	   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
	   * @return {Promise}
	   */

	  async parseAsync(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    await this._parseCommand([], userArgs);
	    return this;
	  }

	  /**
	   * Execute a sub-command executable.
	   *
	   * @private
	   */

	  _executeSubCommand(subcommand, args) {
	    args = args.slice();
	    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
	    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];
	    function findFile(baseDir, baseName) {
	      // Look for specified file
	      const localBin = path$d.resolve(baseDir, baseName);
	      if (fs$l.existsSync(localBin)) return localBin;

	      // Stop looking if candidate already has an expected extension.
	      if (sourceExt.includes(path$d.extname(baseName))) return undefined;

	      // Try all the extensions.
	      const foundExt = sourceExt.find(ext => fs$l.existsSync(`${localBin}${ext}`));
	      if (foundExt) return `${localBin}${foundExt}`;
	      return undefined;
	    }

	    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // executableFile and executableDir might be full path, or just a name
	    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
	    let executableDir = this._executableDir || '';
	    if (this._scriptPath) {
	      let resolvedScriptPath; // resolve possible symlink for installed npm binary
	      try {
	        resolvedScriptPath = fs$l.realpathSync(this._scriptPath);
	      } catch (err) {
	        resolvedScriptPath = this._scriptPath;
	      }
	      executableDir = path$d.resolve(path$d.dirname(resolvedScriptPath), executableDir);
	    }

	    // Look for a local file in preference to a command in PATH.
	    if (executableDir) {
	      let localFile = findFile(executableDir, executableFile);

	      // Legacy search using prefix of script name instead of command name
	      if (!localFile && !subcommand._executableFile && this._scriptPath) {
	        const legacyName = path$d.basename(this._scriptPath, path$d.extname(this._scriptPath));
	        if (legacyName !== this._name) {
	          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
	        }
	      }
	      executableFile = localFile || executableFile;
	    }
	    launchWithNode = sourceExt.includes(path$d.extname(executableFile));
	    let proc;
	    if (process$3.platform !== 'win32') {
	      if (launchWithNode) {
	        args.unshift(executableFile);
	        // add executable arguments to spawn
	        args = incrementNodeInspectorPort(process$3.execArgv).concat(args);
	        proc = childProcess.spawn(process$3.argv[0], args, {
	          stdio: 'inherit'
	        });
	      } else {
	        proc = childProcess.spawn(executableFile, args, {
	          stdio: 'inherit'
	        });
	      }
	    } else {
	      args.unshift(executableFile);
	      // add executable arguments to spawn
	      args = incrementNodeInspectorPort(process$3.execArgv).concat(args);
	      proc = childProcess.spawn(process$3.execPath, args, {
	        stdio: 'inherit'
	      });
	    }
	    if (!proc.killed) {
	      // testing mainly to avoid leak warnings during unit tests with mocked spawn
	      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
	      signals.forEach(signal => {
	        // @ts-ignore
	        process$3.on(signal, () => {
	          if (proc.killed === false && proc.exitCode === null) {
	            proc.kill(signal);
	          }
	        });
	      });
	    }

	    // By default terminate process when spawned process terminates.
	    const exitCallback = this._exitCallback;
	    proc.on('close', (code, _signal) => {
	      code = code ?? 1; // code is null if spawned process terminated due to a signal
	      if (!exitCallback) {
	        process$3.exit(code);
	      } else {
	        exitCallback(new CommanderError$2(code, 'commander.executeSubCommandAsync', '(close)'));
	      }
	    });
	    proc.on('error', err => {
	      // @ts-ignore
	      if (err.code === 'ENOENT') {
	        const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
	        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
	        throw new Error(executableMissing);
	        // @ts-ignore
	      } else if (err.code === 'EACCES') {
	        throw new Error(`'${executableFile}' not executable`);
	      }
	      if (!exitCallback) {
	        process$3.exit(1);
	      } else {
	        const wrappedError = new CommanderError$2(1, 'commander.executeSubCommandAsync', '(error)');
	        wrappedError.nestedError = err;
	        exitCallback(wrappedError);
	      }
	    });

	    // Store the reference to the child process
	    this.runningCommand = proc;
	  }

	  /**
	   * @private
	   */

	  _dispatchSubcommand(commandName, operands, unknown) {
	    const subCommand = this._findCommand(commandName);
	    if (!subCommand) this.help({
	      error: true
	    });
	    let promiseChain;
	    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
	    promiseChain = this._chainOrCall(promiseChain, () => {
	      if (subCommand._executableHandler) {
	        this._executeSubCommand(subCommand, operands.concat(unknown));
	      } else {
	        return subCommand._parseCommand(operands, unknown);
	      }
	    });
	    return promiseChain;
	  }

	  /**
	   * Invoke help directly if possible, or dispatch if necessary.
	   * e.g. help foo
	   *
	   * @private
	   */

	  _dispatchHelpCommand(subcommandName) {
	    if (!subcommandName) {
	      this.help();
	    }
	    const subCommand = this._findCommand(subcommandName);
	    if (subCommand && !subCommand._executableHandler) {
	      subCommand.help();
	    }

	    // Fallback to parsing the help flag to invoke the help.
	    return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help']);
	  }

	  /**
	   * Check this.args against expected this.registeredArguments.
	   *
	   * @private
	   */

	  _checkNumberOfArguments() {
	    // too few
	    this.registeredArguments.forEach((arg, i) => {
	      if (arg.required && this.args[i] == null) {
	        this.missingArgument(arg.name());
	      }
	    });
	    // too many
	    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
	      return;
	    }
	    if (this.args.length > this.registeredArguments.length) {
	      this._excessArguments(this.args);
	    }
	  }

	  /**
	   * Process this.args using this.registeredArguments and save as this.processedArgs!
	   *
	   * @private
	   */

	  _processArguments() {
	    const myParseArg = (argument, value, previous) => {
	      // Extra processing for nice error message on parsing failure.
	      let parsedValue = value;
	      if (value !== null && argument.parseArg) {
	        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
	        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
	      }
	      return parsedValue;
	    };
	    this._checkNumberOfArguments();
	    const processedArgs = [];
	    this.registeredArguments.forEach((declaredArg, index) => {
	      let value = declaredArg.defaultValue;
	      if (declaredArg.variadic) {
	        // Collect together remaining arguments for passing together as an array.
	        if (index < this.args.length) {
	          value = this.args.slice(index);
	          if (declaredArg.parseArg) {
	            value = value.reduce((processed, v) => {
	              return myParseArg(declaredArg, v, processed);
	            }, declaredArg.defaultValue);
	          }
	        } else if (value === undefined) {
	          value = [];
	        }
	      } else if (index < this.args.length) {
	        value = this.args[index];
	        if (declaredArg.parseArg) {
	          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
	        }
	      }
	      processedArgs[index] = value;
	    });
	    this.processedArgs = processedArgs;
	  }

	  /**
	   * Once we have a promise we chain, but call synchronously until then.
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {Function} fn
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCall(promise, fn) {
	    // thenable
	    if (promise && promise.then && typeof promise.then === 'function') {
	      // already have a promise, chain callback
	      return promise.then(() => fn());
	    }
	    // callback might return a promise
	    return fn();
	  }

	  /**
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {string} event
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCallHooks(promise, event) {
	    let result = promise;
	    const hooks = [];
	    this._getCommandAndAncestors().reverse().filter(cmd => cmd._lifeCycleHooks[event] !== undefined).forEach(hookedCommand => {
	      hookedCommand._lifeCycleHooks[event].forEach(callback => {
	        hooks.push({
	          hookedCommand,
	          callback
	        });
	      });
	    });
	    if (event === 'postAction') {
	      hooks.reverse();
	    }
	    hooks.forEach(hookDetail => {
	      result = this._chainOrCall(result, () => {
	        return hookDetail.callback(hookDetail.hookedCommand, this);
	      });
	    });
	    return result;
	  }

	  /**
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {Command} subCommand
	   * @param {string} event
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCallSubCommandHook(promise, subCommand, event) {
	    let result = promise;
	    if (this._lifeCycleHooks[event] !== undefined) {
	      this._lifeCycleHooks[event].forEach(hook => {
	        result = this._chainOrCall(result, () => {
	          return hook(this, subCommand);
	        });
	      });
	    }
	    return result;
	  }

	  /**
	   * Process arguments in context of this command.
	   * Returns action result, in case it is a promise.
	   *
	   * @private
	   */

	  _parseCommand(operands, unknown) {
	    const parsed = this.parseOptions(unknown);
	    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
	    this._parseOptionsImplied();
	    operands = operands.concat(parsed.operands);
	    unknown = parsed.unknown;
	    this.args = operands.concat(unknown);
	    if (operands && this._findCommand(operands[0])) {
	      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
	    }
	    if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
	      return this._dispatchHelpCommand(operands[1]);
	    }
	    if (this._defaultCommandName) {
	      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
	      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
	    }
	    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
	      // probably missing subcommand and no handler, user needs help (and exit)
	      this.help({
	        error: true
	      });
	    }
	    this._outputHelpIfRequested(parsed.unknown);
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // We do not always call this check to avoid masking a "better" error, like unknown command.
	    const checkForUnknownOptions = () => {
	      if (parsed.unknown.length > 0) {
	        this.unknownOption(parsed.unknown[0]);
	      }
	    };
	    const commandEvent = `command:${this.name()}`;
	    if (this._actionHandler) {
	      checkForUnknownOptions();
	      this._processArguments();
	      let promiseChain;
	      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
	      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
	      if (this.parent) {
	        promiseChain = this._chainOrCall(promiseChain, () => {
	          this.parent.emit(commandEvent, operands, unknown); // legacy
	        });
	      }
	      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
	      return promiseChain;
	    }
	    if (this.parent && this.parent.listenerCount(commandEvent)) {
	      checkForUnknownOptions();
	      this._processArguments();
	      this.parent.emit(commandEvent, operands, unknown); // legacy
	    } else if (operands.length) {
	      if (this._findCommand('*')) {
	        // legacy default command
	        return this._dispatchSubcommand('*', operands, unknown);
	      }
	      if (this.listenerCount('command:*')) {
	        // skip option check, emit event for possible misspelling suggestion
	        this.emit('command:*', operands, unknown);
	      } else if (this.commands.length) {
	        this.unknownCommand();
	      } else {
	        checkForUnknownOptions();
	        this._processArguments();
	      }
	    } else if (this.commands.length) {
	      checkForUnknownOptions();
	      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
	      this.help({
	        error: true
	      });
	    } else {
	      checkForUnknownOptions();
	      this._processArguments();
	      // fall through for caller to handle after calling .parse()
	    }
	  }

	  /**
	   * Find matching command.
	   *
	   * @private
	   */
	  _findCommand(name) {
	    if (!name) return undefined;
	    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
	  }

	  /**
	   * Return an option matching `arg` if any.
	   *
	   * @param {string} arg
	   * @return {Option}
	   * @package internal use only
	   */

	  _findOption(arg) {
	    return this.options.find(option => option.is(arg));
	  }

	  /**
	   * Display an error message if a mandatory option does not have a value.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @private
	   */

	  _checkForMissingMandatoryOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach(cmd => {
	      cmd.options.forEach(anOption => {
	        if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
	          cmd.missingMandatoryOptionValue(anOption);
	        }
	      });
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together in this.
	   *
	   * @private
	   */
	  _checkForConflictingLocalOptions() {
	    const definedNonDefaultOptions = this.options.filter(option => {
	      const optionKey = option.attributeName();
	      if (this.getOptionValue(optionKey) === undefined) {
	        return false;
	      }
	      return this.getOptionValueSource(optionKey) !== 'default';
	    });
	    const optionsWithConflicting = definedNonDefaultOptions.filter(option => option.conflictsWith.length > 0);
	    optionsWithConflicting.forEach(option => {
	      const conflictingAndDefined = definedNonDefaultOptions.find(defined => option.conflictsWith.includes(defined.attributeName()));
	      if (conflictingAndDefined) {
	        this._conflictingOption(option, conflictingAndDefined);
	      }
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @private
	   */
	  _checkForConflictingOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach(cmd => {
	      cmd._checkForConflictingLocalOptions();
	    });
	  }

	  /**
	   * Parse options from `argv` removing known options,
	   * and return argv split into operands and unknown arguments.
	   *
	   * Examples:
	   *
	   *     argv => operands, unknown
	   *     --known kkk op => [op], []
	   *     op --known kkk => [op], []
	   *     sub --unknown uuu op => [sub], [--unknown uuu op]
	   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
	   *
	   * @param {string[]} argv
	   * @return {{operands: string[], unknown: string[]}}
	   */

	  parseOptions(argv) {
	    const operands = []; // operands, not options or values
	    const unknown = []; // first unknown option and remaining unknown args
	    let dest = operands;
	    const args = argv.slice();
	    function maybeOption(arg) {
	      return arg.length > 1 && arg[0] === '-';
	    }

	    // parse options
	    let activeVariadicOption = null;
	    while (args.length) {
	      const arg = args.shift();

	      // literal
	      if (arg === '--') {
	        if (dest === unknown) dest.push(arg);
	        dest.push(...args);
	        break;
	      }
	      if (activeVariadicOption && !maybeOption(arg)) {
	        this.emit(`option:${activeVariadicOption.name()}`, arg);
	        continue;
	      }
	      activeVariadicOption = null;
	      if (maybeOption(arg)) {
	        const option = this._findOption(arg);
	        // recognised option, call listener to assign value with possible custom processing
	        if (option) {
	          if (option.required) {
	            const value = args.shift();
	            if (value === undefined) this.optionMissingArgument(option);
	            this.emit(`option:${option.name()}`, value);
	          } else if (option.optional) {
	            let value = null;
	            // historical behaviour is optional value is following arg unless an option
	            if (args.length > 0 && !maybeOption(args[0])) {
	              value = args.shift();
	            }
	            this.emit(`option:${option.name()}`, value);
	          } else {
	            // boolean flag
	            this.emit(`option:${option.name()}`);
	          }
	          activeVariadicOption = option.variadic ? option : null;
	          continue;
	        }
	      }

	      // Look for combo options following single dash, eat first one if known.
	      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
	        const option = this._findOption(`-${arg[1]}`);
	        if (option) {
	          if (option.required || option.optional && this._combineFlagAndOptionalValue) {
	            // option with value following in same argument
	            this.emit(`option:${option.name()}`, arg.slice(2));
	          } else {
	            // boolean option, emit and put back remainder of arg for further processing
	            this.emit(`option:${option.name()}`);
	            args.unshift(`-${arg.slice(2)}`);
	          }
	          continue;
	        }
	      }

	      // Look for known long flag with value, like --foo=bar
	      if (/^--[^=]+=/.test(arg)) {
	        const index = arg.indexOf('=');
	        const option = this._findOption(arg.slice(0, index));
	        if (option && (option.required || option.optional)) {
	          this.emit(`option:${option.name()}`, arg.slice(index + 1));
	          continue;
	        }
	      }

	      // Not a recognised option by this command.
	      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

	      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
	      if (maybeOption(arg)) {
	        dest = unknown;
	      }

	      // If using positionalOptions, stop processing our options at subcommand.
	      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
	        if (this._findCommand(arg)) {
	          operands.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
	          operands.push(arg);
	          if (args.length > 0) operands.push(...args);
	          break;
	        } else if (this._defaultCommandName) {
	          unknown.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        }
	      }

	      // If using passThroughOptions, stop processing options at first command-argument.
	      if (this._passThroughOptions) {
	        dest.push(arg);
	        if (args.length > 0) dest.push(...args);
	        break;
	      }

	      // add arg
	      dest.push(arg);
	    }
	    return {
	      operands,
	      unknown
	    };
	  }

	  /**
	   * Return an object containing local option values as key-value pairs.
	   *
	   * @return {Object}
	   */
	  opts() {
	    if (this._storeOptionsAsProperties) {
	      // Preserve original behaviour so backwards compatible when still using properties
	      const result = {};
	      const len = this.options.length;
	      for (let i = 0; i < len; i++) {
	        const key = this.options[i].attributeName();
	        result[key] = key === this._versionOptionName ? this._version : this[key];
	      }
	      return result;
	    }
	    return this._optionValues;
	  }

	  /**
	   * Return an object containing merged local and global option values as key-value pairs.
	   *
	   * @return {Object}
	   */
	  optsWithGlobals() {
	    // globals overwrite locals
	    return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
	  }

	  /**
	   * Display error message and exit (or call exitOverride).
	   *
	   * @param {string} message
	   * @param {Object} [errorOptions]
	   * @param {string} [errorOptions.code] - an id string representing the error
	   * @param {number} [errorOptions.exitCode] - used with process.exit
	   */
	  error(message, errorOptions) {
	    // output handling
	    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
	    if (typeof this._showHelpAfterError === 'string') {
	      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
	    } else if (this._showHelpAfterError) {
	      this._outputConfiguration.writeErr('\n');
	      this.outputHelp({
	        error: true
	      });
	    }

	    // exit handling
	    const config = errorOptions || {};
	    const exitCode = config.exitCode || 1;
	    const code = config.code || 'commander.error';
	    this._exit(exitCode, code, message);
	  }

	  /**
	   * Apply any option related environment variables, if option does
	   * not have a value from cli or client code.
	   *
	   * @private
	   */
	  _parseOptionsEnv() {
	    this.options.forEach(option => {
	      if (option.envVar && option.envVar in process$3.env) {
	        const optionKey = option.attributeName();
	        // Priority check. Do not overwrite cli or options from unknown source (client-code).
	        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
	          if (option.required || option.optional) {
	            // option can take a value
	            // keep very simple, optional always takes value
	            this.emit(`optionEnv:${option.name()}`, process$3.env[option.envVar]);
	          } else {
	            // boolean
	            // keep very simple, only care that envVar defined and not the value
	            this.emit(`optionEnv:${option.name()}`);
	          }
	        }
	      }
	    });
	  }

	  /**
	   * Apply any implied option values, if option is undefined or default value.
	   *
	   * @private
	   */
	  _parseOptionsImplied() {
	    const dualHelper = new DualOptions(this.options);
	    const hasCustomOptionValue = optionKey => {
	      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));
	    };
	    this.options.filter(option => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach(option => {
	      Object.keys(option.implied).filter(impliedKey => !hasCustomOptionValue(impliedKey)).forEach(impliedKey => {
	        this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
	      });
	    });
	  }

	  /**
	   * Argument `name` is missing.
	   *
	   * @param {string} name
	   * @private
	   */

	  missingArgument(name) {
	    const message = `error: missing required argument '${name}'`;
	    this.error(message, {
	      code: 'commander.missingArgument'
	    });
	  }

	  /**
	   * `Option` is missing an argument.
	   *
	   * @param {Option} option
	   * @private
	   */

	  optionMissingArgument(option) {
	    const message = `error: option '${option.flags}' argument missing`;
	    this.error(message, {
	      code: 'commander.optionMissingArgument'
	    });
	  }

	  /**
	   * `Option` does not have a value, and is a mandatory option.
	   *
	   * @param {Option} option
	   * @private
	   */

	  missingMandatoryOptionValue(option) {
	    const message = `error: required option '${option.flags}' not specified`;
	    this.error(message, {
	      code: 'commander.missingMandatoryOptionValue'
	    });
	  }

	  /**
	   * `Option` conflicts with another option.
	   *
	   * @param {Option} option
	   * @param {Option} conflictingOption
	   * @private
	   */
	  _conflictingOption(option, conflictingOption) {
	    // The calling code does not know whether a negated option is the source of the
	    // value, so do some work to take an educated guess.
	    const findBestOptionFromValue = option => {
	      const optionKey = option.attributeName();
	      const optionValue = this.getOptionValue(optionKey);
	      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());
	      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());
	      if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
	        return negativeOption;
	      }
	      return positiveOption || option;
	    };
	    const getErrorMessage = option => {
	      const bestOption = findBestOptionFromValue(option);
	      const optionKey = bestOption.attributeName();
	      const source = this.getOptionValueSource(optionKey);
	      if (source === 'env') {
	        return `environment variable '${bestOption.envVar}'`;
	      }
	      return `option '${bestOption.flags}'`;
	    };
	    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
	    this.error(message, {
	      code: 'commander.conflictingOption'
	    });
	  }

	  /**
	   * Unknown option `flag`.
	   *
	   * @param {string} flag
	   * @private
	   */

	  unknownOption(flag) {
	    if (this._allowUnknownOption) return;
	    let suggestion = '';
	    if (flag.startsWith('--') && this._showSuggestionAfterError) {
	      // Looping to pick up the global options too
	      let candidateFlags = [];
	      let command = this;
	      do {
	        const moreFlags = command.createHelp().visibleOptions(command).filter(option => option.long).map(option => option.long);
	        candidateFlags = candidateFlags.concat(moreFlags);
	        command = command.parent;
	      } while (command && !command._enablePositionalOptions);
	      suggestion = suggestSimilar(flag, candidateFlags);
	    }
	    const message = `error: unknown option '${flag}'${suggestion}`;
	    this.error(message, {
	      code: 'commander.unknownOption'
	    });
	  }

	  /**
	   * Excess arguments, more than expected.
	   *
	   * @param {string[]} receivedArgs
	   * @private
	   */

	  _excessArguments(receivedArgs) {
	    if (this._allowExcessArguments) return;
	    const expected = this.registeredArguments.length;
	    const s = expected === 1 ? '' : 's';
	    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
	    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
	    this.error(message, {
	      code: 'commander.excessArguments'
	    });
	  }

	  /**
	   * Unknown command.
	   *
	   * @private
	   */

	  unknownCommand() {
	    const unknownName = this.args[0];
	    let suggestion = '';
	    if (this._showSuggestionAfterError) {
	      const candidateNames = [];
	      this.createHelp().visibleCommands(this).forEach(command => {
	        candidateNames.push(command.name());
	        // just visible alias
	        if (command.alias()) candidateNames.push(command.alias());
	      });
	      suggestion = suggestSimilar(unknownName, candidateNames);
	    }
	    const message = `error: unknown command '${unknownName}'${suggestion}`;
	    this.error(message, {
	      code: 'commander.unknownCommand'
	    });
	  }

	  /**
	   * Get or set the program version.
	   *
	   * This method auto-registers the "-V, --version" option which will print the version number.
	   *
	   * You can optionally supply the flags and description to override the defaults.
	   *
	   * @param {string} [str]
	   * @param {string} [flags]
	   * @param {string} [description]
	   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
	   */

	  version(str, flags, description) {
	    if (str === undefined) return this._version;
	    this._version = str;
	    flags = flags || '-V, --version';
	    description = description || 'output the version number';
	    const versionOption = this.createOption(flags, description);
	    this._versionOptionName = versionOption.attributeName();
	    this._registerOption(versionOption);
	    this.on('option:' + versionOption.name(), () => {
	      this._outputConfiguration.writeOut(`${str}\n`);
	      this._exit(0, 'commander.version', str);
	    });
	    return this;
	  }

	  /**
	   * Set the description.
	   *
	   * @param {string} [str]
	   * @param {Object} [argsDescription]
	   * @return {(string|Command)}
	   */
	  description(str, argsDescription) {
	    if (str === undefined && argsDescription === undefined) return this._description;
	    this._description = str;
	    if (argsDescription) {
	      this._argsDescription = argsDescription;
	    }
	    return this;
	  }

	  /**
	   * Set the summary. Used when listed as subcommand of parent.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */
	  summary(str) {
	    if (str === undefined) return this._summary;
	    this._summary = str;
	    return this;
	  }

	  /**
	   * Set an alias for the command.
	   *
	   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string} [alias]
	   * @return {(string|Command)}
	   */

	  alias(alias) {
	    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

	    /** @type {Command} */
	    let command = this;
	    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
	      // assume adding alias for last added executable subcommand, rather than this
	      command = this.commands[this.commands.length - 1];
	    }
	    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');
	    const matchingCommand = this.parent?._findCommand(alias);
	    if (matchingCommand) {
	      // c.f. _registerCommand
	      const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join('|');
	      throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
	    }
	    command._aliases.push(alias);
	    return this;
	  }

	  /**
	   * Set aliases for the command.
	   *
	   * Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string[]} [aliases]
	   * @return {(string[]|Command)}
	   */

	  aliases(aliases) {
	    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
	    if (aliases === undefined) return this._aliases;
	    aliases.forEach(alias => this.alias(alias));
	    return this;
	  }

	  /**
	   * Set / get the command usage `str`.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */

	  usage(str) {
	    if (str === undefined) {
	      if (this._usage) return this._usage;
	      const args = this.registeredArguments.map(arg => {
	        return humanReadableArgName(arg);
	      });
	      return [].concat(this.options.length || this._helpOption !== null ? '[options]' : [], this.commands.length ? '[command]' : [], this.registeredArguments.length ? args : []).join(' ');
	    }
	    this._usage = str;
	    return this;
	  }

	  /**
	   * Get or set the name of the command.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */

	  name(str) {
	    if (str === undefined) return this._name;
	    this._name = str;
	    return this;
	  }

	  /**
	   * Set the name of the command from script filename, such as process.argv[1],
	   * or require.main.filename, or __filename.
	   *
	   * (Used internally and public although not documented in README.)
	   *
	   * @example
	   * program.nameFromFilename(require.main.filename);
	   *
	   * @param {string} filename
	   * @return {Command}
	   */

	  nameFromFilename(filename) {
	    this._name = path$d.basename(filename, path$d.extname(filename));
	    return this;
	  }

	  /**
	   * Get or set the directory for searching for executable subcommands of this command.
	   *
	   * @example
	   * program.executableDir(__dirname);
	   * // or
	   * program.executableDir('subcommands');
	   *
	   * @param {string} [path]
	   * @return {(string|null|Command)}
	   */

	  executableDir(path) {
	    if (path === undefined) return this._executableDir;
	    this._executableDir = path;
	    return this;
	  }

	  /**
	   * Return program help documentation.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
	   * @return {string}
	   */

	  helpInformation(contextOptions) {
	    const helper = this.createHelp();
	    if (helper.helpWidth === undefined) {
	      helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
	    }
	    return helper.formatHelp(this, helper);
	  }

	  /**
	   * @private
	   */

	  _getHelpContext(contextOptions) {
	    contextOptions = contextOptions || {};
	    const context = {
	      error: !!contextOptions.error
	    };
	    let write;
	    if (context.error) {
	      write = arg => this._outputConfiguration.writeErr(arg);
	    } else {
	      write = arg => this._outputConfiguration.writeOut(arg);
	    }
	    context.write = contextOptions.write || write;
	    context.command = this;
	    return context;
	  }

	  /**
	   * Output help information for this command.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  outputHelp(contextOptions) {
	    let deprecatedCallback;
	    if (typeof contextOptions === 'function') {
	      deprecatedCallback = contextOptions;
	      contextOptions = undefined;
	    }
	    const context = this._getHelpContext(contextOptions);
	    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));
	    this.emit('beforeHelp', context);
	    let helpInformation = this.helpInformation(context);
	    if (deprecatedCallback) {
	      helpInformation = deprecatedCallback(helpInformation);
	      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
	        throw new Error('outputHelp callback must return a string or a Buffer');
	      }
	    }
	    context.write(helpInformation);
	    if (this._getHelpOption()?.long) {
	      this.emit(this._getHelpOption().long); // deprecated
	    }
	    this.emit('afterHelp', context);
	    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));
	  }

	  /**
	   * You can pass in flags and a description to customise the built-in help option.
	   * Pass in false to disable the built-in help option.
	   *
	   * @example
	   * program.helpOption('-?, --help' 'show help'); // customise
	   * program.helpOption(false); // disable
	   *
	   * @param {(string | boolean)} flags
	   * @param {string} [description]
	   * @return {Command} `this` command for chaining
	   */

	  helpOption(flags, description) {
	    // Support disabling built-in help option.
	    if (typeof flags === 'boolean') {
	      if (flags) {
	        this._helpOption = this._helpOption ?? undefined; // preserve existing option
	      } else {
	        this._helpOption = null; // disable
	      }
	      return this;
	    }

	    // Customise flags and description.
	    flags = flags ?? '-h, --help';
	    description = description ?? 'display help for command';
	    this._helpOption = this.createOption(flags, description);
	    return this;
	  }

	  /**
	   * Lazy create help option.
	   * Returns null if has been disabled with .helpOption(false).
	   *
	   * @returns {(Option | null)} the help option
	   * @package internal use only
	   */
	  _getHelpOption() {
	    // Lazy create help option on demand.
	    if (this._helpOption === undefined) {
	      this.helpOption(undefined, undefined);
	    }
	    return this._helpOption;
	  }

	  /**
	   * Supply your own option to use for the built-in help option.
	   * This is an alternative to using helpOption() to customise the flags and description etc.
	   *
	   * @param {Option} option
	   * @return {Command} `this` command for chaining
	   */
	  addHelpOption(option) {
	    this._helpOption = option;
	    return this;
	  }

	  /**
	   * Output help information and exit.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  help(contextOptions) {
	    this.outputHelp(contextOptions);
	    let exitCode = process$3.exitCode || 0;
	    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
	      exitCode = 1;
	    }
	    // message: do not have all displayed text available so only passing placeholder.
	    this._exit(exitCode, 'commander.help', '(outputHelp)');
	  }

	  /**
	   * Add additional text to be displayed with the built-in help.
	   *
	   * Position is 'before' or 'after' to affect just this command,
	   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
	   *
	   * @param {string} position - before or after built-in help
	   * @param {(string | Function)} text - string to add, or a function returning a string
	   * @return {Command} `this` command for chaining
	   */
	  addHelpText(position, text) {
	    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
	    if (!allowedValues.includes(position)) {
	      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    const helpEvent = `${position}Help`;
	    this.on(helpEvent, context => {
	      let helpStr;
	      if (typeof text === 'function') {
	        helpStr = text({
	          error: context.error,
	          command: context.command
	        });
	      } else {
	        helpStr = text;
	      }
	      // Ignore falsy value when nothing to output.
	      if (helpStr) {
	        context.write(`${helpStr}\n`);
	      }
	    });
	    return this;
	  }

	  /**
	   * Output help information if help flags specified
	   *
	   * @param {Array} args - array of options to search for help flags
	   * @private
	   */

	  _outputHelpIfRequested(args) {
	    const helpOption = this._getHelpOption();
	    const helpRequested = helpOption && args.find(arg => helpOption.is(arg));
	    if (helpRequested) {
	      this.outputHelp();
	      // (Do not have all displayed text available so only passing placeholder.)
	      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
	    }
	  }
	};

	/**
	 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	 *
	 * @param {string[]} args - array of arguments from node.execArgv
	 * @returns {string[]}
	 * @private
	 */

	function incrementNodeInspectorPort(args) {
	  // Testing for these options:
	  //  --inspect[=[host:]port]
	  //  --inspect-brk[=[host:]port]
	  //  --inspect-port=[host:]port
	  return args.map(arg => {
	    if (!arg.startsWith('--inspect')) {
	      return arg;
	    }
	    let debugOption;
	    let debugHost = '127.0.0.1';
	    let debugPort = '9229';
	    let match;
	    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
	      // e.g. --inspect
	      debugOption = match[1];
	    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
	      debugOption = match[1];
	      if (/^\d+$/.test(match[3])) {
	        // e.g. --inspect=1234
	        debugPort = match[3];
	      } else {
	        // e.g. --inspect=localhost
	        debugHost = match[3];
	      }
	    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
	      // e.g. --inspect=localhost:1234
	      debugOption = match[1];
	      debugHost = match[3];
	      debugPort = match[4];
	    }
	    if (debugOption && debugPort !== '0') {
	      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
	    }
	    return arg;
	  });
	}
	command.Command = Command$2;

	const {
	  Argument: Argument$1
	} = argument;
	const {
	  Command: Command$1
	} = command;
	const {
	  CommanderError: CommanderError$1,
	  InvalidArgumentError: InvalidArgumentError$1
	} = error;
	const {
	  Help: Help$1
	} = help;
	const {
	  Option: Option$1
	} = option;
	commander.program = new Command$1();
	commander.createCommand = name => new Command$1(name);
	commander.createOption = (flags, description) => new Option$1(flags, description);
	commander.createArgument = (name, description) => new Argument$1(name, description);

	/**
	 * Expose classes
	 */

	commander.Command = Command$1;
	commander.Option = Option$1;
	commander.Argument = Argument$1;
	commander.Help = Help$1;
	commander.CommanderError = CommanderError$1;
	commander.InvalidArgumentError = InvalidArgumentError$1;
	commander.InvalidOptionArgumentError = InvalidArgumentError$1; // Deprecated

	// wrapper to provide named exports for ESM.
	const {
	  program: program$1,
	  createCommand,
	  createArgument,
	  createOption,
	  CommanderError,
	  InvalidArgumentError,
	  InvalidOptionArgumentError,
	  // deprecated old name
	  Command,
	  Argument,
	  Option,
	  Help
	} = commander;

	function ownKeys(e, r) {
	  var t = Object.keys(e);
	  if (Object.getOwnPropertySymbols) {
	    var o = Object.getOwnPropertySymbols(e);
	    r && (o = o.filter(function (r) {
	      return Object.getOwnPropertyDescriptor(e, r).enumerable;
	    })), t.push.apply(t, o);
	  }
	  return t;
	}
	function _objectSpread2(e) {
	  for (var r = 1; r < arguments.length; r++) {
	    var t = null != arguments[r] ? arguments[r] : {};
	    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
	      _defineProperty$1(e, r, t[r]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	    });
	  }
	  return e;
	}
	function _regeneratorRuntime() {
	  _regeneratorRuntime = function () {
	    return e;
	  };
	  var t,
	    e = {},
	    r = Object.prototype,
	    n = r.hasOwnProperty,
	    o = Object.defineProperty || function (t, e, r) {
	      t[e] = r.value;
	    },
	    i = "function" == typeof Symbol ? Symbol : {},
	    a = i.iterator || "@@iterator",
	    c = i.asyncIterator || "@@asyncIterator",
	    u = i.toStringTag || "@@toStringTag";
	  function define(t, e, r) {
	    return Object.defineProperty(t, e, {
	      value: r,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), t[e];
	  }
	  try {
	    define({}, "");
	  } catch (t) {
	    define = function (t, e, r) {
	      return t[e] = r;
	    };
	  }
	  function wrap(t, e, r, n) {
	    var i = e && e.prototype instanceof Generator ? e : Generator,
	      a = Object.create(i.prototype),
	      c = new Context(n || []);
	    return o(a, "_invoke", {
	      value: makeInvokeMethod(t, r, c)
	    }), a;
	  }
	  function tryCatch(t, e, r) {
	    try {
	      return {
	        type: "normal",
	        arg: t.call(e, r)
	      };
	    } catch (t) {
	      return {
	        type: "throw",
	        arg: t
	      };
	    }
	  }
	  e.wrap = wrap;
	  var h = "suspendedStart",
	    l = "suspendedYield",
	    f = "executing",
	    s = "completed",
	    y = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var p = {};
	  define(p, a, function () {
	    return this;
	  });
	  var d = Object.getPrototypeOf,
	    v = d && d(d(values([])));
	  v && v !== r && n.call(v, a) && (p = v);
	  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
	  function defineIteratorMethods(t) {
	    ["next", "throw", "return"].forEach(function (e) {
	      define(t, e, function (t) {
	        return this._invoke(e, t);
	      });
	    });
	  }
	  function AsyncIterator(t, e) {
	    function invoke(r, o, i, a) {
	      var c = tryCatch(t[r], t, o);
	      if ("throw" !== c.type) {
	        var u = c.arg,
	          h = u.value;
	        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
	          invoke("next", t, i, a);
	        }, function (t) {
	          invoke("throw", t, i, a);
	        }) : e.resolve(h).then(function (t) {
	          u.value = t, i(u);
	        }, function (t) {
	          return invoke("throw", t, i, a);
	        });
	      }
	      a(c.arg);
	    }
	    var r;
	    o(this, "_invoke", {
	      value: function (t, n) {
	        function callInvokeWithMethodAndArg() {
	          return new e(function (e, r) {
	            invoke(t, n, e, r);
	          });
	        }
	        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(e, r, n) {
	    var o = h;
	    return function (i, a) {
	      if (o === f) throw Error("Generator is already running");
	      if (o === s) {
	        if ("throw" === i) throw a;
	        return {
	          value: t,
	          done: !0
	        };
	      }
	      for (n.method = i, n.arg = a;;) {
	        var c = n.delegate;
	        if (c) {
	          var u = maybeInvokeDelegate(c, n);
	          if (u) {
	            if (u === y) continue;
	            return u;
	          }
	        }
	        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
	          if (o === h) throw o = s, n.arg;
	          n.dispatchException(n.arg);
	        } else "return" === n.method && n.abrupt("return", n.arg);
	        o = f;
	        var p = tryCatch(e, r, n);
	        if ("normal" === p.type) {
	          if (o = n.done ? s : l, p.arg === y) continue;
	          return {
	            value: p.arg,
	            done: n.done
	          };
	        }
	        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(e, r) {
	    var n = r.method,
	      o = e.iterator[n];
	    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
	    var i = tryCatch(o, e.iterator, r.arg);
	    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
	    var a = i.arg;
	    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
	  }
	  function pushTryEntry(t) {
	    var e = {
	      tryLoc: t[0]
	    };
	    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
	  }
	  function resetTryEntry(t) {
	    var e = t.completion || {};
	    e.type = "normal", delete e.arg, t.completion = e;
	  }
	  function Context(t) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], t.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(e) {
	    if (e || "" === e) {
	      var r = e[a];
	      if (r) return r.call(e);
	      if ("function" == typeof e.next) return e;
	      if (!isNaN(e.length)) {
	        var o = -1,
	          i = function next() {
	            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
	            return next.value = t, next.done = !0, next;
	          };
	        return i.next = i;
	      }
	    }
	    throw new TypeError(typeof e + " is not iterable");
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), o(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
	    var e = "function" == typeof t && t.constructor;
	    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
	  }, e.mark = function (t) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
	  }, e.awrap = function (t) {
	    return {
	      __await: t
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
	    return this;
	  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
	    void 0 === i && (i = Promise);
	    var a = new AsyncIterator(wrap(t, r, n, o), i);
	    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
	      return t.done ? t.value : a.next();
	    });
	  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
	    return this;
	  }), define(g, "toString", function () {
	    return "[object Generator]";
	  }), e.keys = function (t) {
	    var e = Object(t),
	      r = [];
	    for (var n in e) r.push(n);
	    return r.reverse(), function next() {
	      for (; r.length;) {
	        var t = r.pop();
	        if (t in e) return next.value = t, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, e.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function (e) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
	    },
	    stop: function () {
	      this.done = !0;
	      var t = this.tryEntries[0].completion;
	      if ("throw" === t.type) throw t.arg;
	      return this.rval;
	    },
	    dispatchException: function (e) {
	      if (this.done) throw e;
	      var r = this;
	      function handle(n, o) {
	        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
	      }
	      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
	        var i = this.tryEntries[o],
	          a = i.completion;
	        if ("root" === i.tryLoc) return handle("end");
	        if (i.tryLoc <= this.prev) {
	          var c = n.call(i, "catchLoc"),
	            u = n.call(i, "finallyLoc");
	          if (c && u) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          } else if (c) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	          } else {
	            if (!u) throw Error("try statement without catch or finally");
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function (t, e) {
	      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
	        var o = this.tryEntries[r];
	        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
	          var i = o;
	          break;
	        }
	      }
	      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
	      var a = i ? i.completion : {};
	      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
	    },
	    complete: function (t, e) {
	      if ("throw" === t.type) throw t.arg;
	      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
	    },
	    finish: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
	      }
	    },
	    catch: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.tryLoc === t) {
	          var n = r.completion;
	          if ("throw" === n.type) {
	            var o = n.arg;
	            resetTryEntry(r);
	          }
	          return o;
	        }
	      }
	      throw Error("illegal catch attempt");
	    },
	    delegateYield: function (e, r, n) {
	      return this.delegate = {
	        iterator: values(e),
	        resultName: r,
	        nextLoc: n
	      }, "next" === this.method && (this.arg = t), y;
	    }
	  }, e;
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r || "default");
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}
	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }
	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}
	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	      args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);
	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }
	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }
	      _next(undefined);
	    });
	  };
	}
	function _defineProperty$1(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}
	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}
	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	const ANSI_BACKGROUND_OFFSET = 10;
	const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;
	const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;
	const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
	const styles$2 = {
	  modifier: {
	    reset: [0, 0],
	    // 21 isn't widely supported and 22 does the same thing
	    bold: [1, 22],
	    dim: [2, 22],
	    italic: [3, 23],
	    underline: [4, 24],
	    overline: [53, 55],
	    inverse: [7, 27],
	    hidden: [8, 28],
	    strikethrough: [9, 29]
	  },
	  color: {
	    black: [30, 39],
	    red: [31, 39],
	    green: [32, 39],
	    yellow: [33, 39],
	    blue: [34, 39],
	    magenta: [35, 39],
	    cyan: [36, 39],
	    white: [37, 39],
	    // Bright color
	    blackBright: [90, 39],
	    gray: [90, 39],
	    // Alias of `blackBright`
	    grey: [90, 39],
	    // Alias of `blackBright`
	    redBright: [91, 39],
	    greenBright: [92, 39],
	    yellowBright: [93, 39],
	    blueBright: [94, 39],
	    magentaBright: [95, 39],
	    cyanBright: [96, 39],
	    whiteBright: [97, 39]
	  },
	  bgColor: {
	    bgBlack: [40, 49],
	    bgRed: [41, 49],
	    bgGreen: [42, 49],
	    bgYellow: [43, 49],
	    bgBlue: [44, 49],
	    bgMagenta: [45, 49],
	    bgCyan: [46, 49],
	    bgWhite: [47, 49],
	    // Bright color
	    bgBlackBright: [100, 49],
	    bgGray: [100, 49],
	    // Alias of `bgBlackBright`
	    bgGrey: [100, 49],
	    // Alias of `bgBlackBright`
	    bgRedBright: [101, 49],
	    bgGreenBright: [102, 49],
	    bgYellowBright: [103, 49],
	    bgBlueBright: [104, 49],
	    bgMagentaBright: [105, 49],
	    bgCyanBright: [106, 49],
	    bgWhiteBright: [107, 49]
	  }
	};
	Object.keys(styles$2.modifier);
	const foregroundColorNames = Object.keys(styles$2.color);
	const backgroundColorNames = Object.keys(styles$2.bgColor);
	[...foregroundColorNames, ...backgroundColorNames];
	function assembleStyles() {
	  const codes = new Map();
	  for (const [groupName, group] of Object.entries(styles$2)) {
	    for (const [styleName, style] of Object.entries(group)) {
	      styles$2[styleName] = {
	        open: `\u001B[${style[0]}m`,
	        close: `\u001B[${style[1]}m`
	      };
	      group[styleName] = styles$2[styleName];
	      codes.set(style[0], style[1]);
	    }
	    Object.defineProperty(styles$2, groupName, {
	      value: group,
	      enumerable: false
	    });
	  }
	  Object.defineProperty(styles$2, 'codes', {
	    value: codes,
	    enumerable: false
	  });
	  styles$2.color.close = '\u001B[39m';
	  styles$2.bgColor.close = '\u001B[49m';
	  styles$2.color.ansi = wrapAnsi16();
	  styles$2.color.ansi256 = wrapAnsi256();
	  styles$2.color.ansi16m = wrapAnsi16m();
	  styles$2.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	  styles$2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	  styles$2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	  // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	  Object.defineProperties(styles$2, {
	    rgbToAnsi256: {
	      value(red, green, blue) {
	        // We use the extended greyscale palette here, with the exception of
	        // black and white. normal palette only has 4 greyscale shades.
	        if (red === green && green === blue) {
	          if (red < 8) {
	            return 16;
	          }
	          if (red > 248) {
	            return 231;
	          }
	          return Math.round((red - 8) / 247 * 24) + 232;
	        }
	        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
	      },
	      enumerable: false
	    },
	    hexToRgb: {
	      value(hex) {
	        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
	        if (!matches) {
	          return [0, 0, 0];
	        }
	        let [colorString] = matches;
	        if (colorString.length === 3) {
	          colorString = [...colorString].map(character => character + character).join('');
	        }
	        const integer = Number.parseInt(colorString, 16);
	        return [/* eslint-disable no-bitwise */
	        integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF
	        /* eslint-enable no-bitwise */];
	      },
	      enumerable: false
	    },
	    hexToAnsi256: {
	      value: hex => styles$2.rgbToAnsi256(...styles$2.hexToRgb(hex)),
	      enumerable: false
	    },
	    ansi256ToAnsi: {
	      value(code) {
	        if (code < 8) {
	          return 30 + code;
	        }
	        if (code < 16) {
	          return 90 + (code - 8);
	        }
	        let red;
	        let green;
	        let blue;
	        if (code >= 232) {
	          red = ((code - 232) * 10 + 8) / 255;
	          green = red;
	          blue = red;
	        } else {
	          code -= 16;
	          const remainder = code % 36;
	          red = Math.floor(code / 36) / 5;
	          green = Math.floor(remainder / 6) / 5;
	          blue = remainder % 6 / 5;
	        }
	        const value = Math.max(red, green, blue) * 2;
	        if (value === 0) {
	          return 30;
	        }

	        // eslint-disable-next-line no-bitwise
	        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
	        if (value === 2) {
	          result += 60;
	        }
	        return result;
	      },
	      enumerable: false
	    },
	    rgbToAnsi: {
	      value: (red, green, blue) => styles$2.ansi256ToAnsi(styles$2.rgbToAnsi256(red, green, blue)),
	      enumerable: false
	    },
	    hexToAnsi: {
	      value: hex => styles$2.ansi256ToAnsi(styles$2.hexToAnsi256(hex)),
	      enumerable: false
	    }
	  });
	  return styles$2;
	}
	const ansiStyles$3 = assembleStyles();

	/* eslint-env browser */

	const level = (() => {
	  if (navigator.userAgentData) {
	    const brand = navigator.userAgentData.brands.find(({
	      brand
	    }) => brand === 'Chromium');
	    if (brand && brand.version > 93) {
	      return 3;
	    }
	  }
	  if (/\b(Chrome|Chromium)\//.test(navigator.userAgent)) {
	    return 1;
	  }
	  return 0;
	})();
	const colorSupport = level !== 0 && {
	  level,
	  hasBasic: true,
	  has256: level >= 2,
	  has16m: level >= 3
	};
	const supportsColor$1 = {
	  stdout: colorSupport,
	  stderr: colorSupport
	};

	// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
	function stringReplaceAll$2(string, substring, replacer) {
	  let index = string.indexOf(substring);
	  if (index === -1) {
	    return string;
	  }
	  const substringLength = substring.length;
	  let endIndex = 0;
	  let returnValue = '';
	  do {
	    returnValue += string.slice(endIndex, index) + substring + replacer;
	    endIndex = index + substringLength;
	    index = string.indexOf(substring, endIndex);
	  } while (index !== -1);
	  returnValue += string.slice(endIndex);
	  return returnValue;
	}
	function stringEncaseCRLFWithFirstIndex$2(string, prefix, postfix, index) {
	  let endIndex = 0;
	  let returnValue = '';
	  do {
	    const gotCR = string[index - 1] === '\r';
	    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
	    endIndex = index + 1;
	    index = string.indexOf('\n', endIndex);
	  } while (index !== -1);
	  returnValue += string.slice(endIndex);
	  return returnValue;
	}

	const {
	  stdout: stdoutColor$1,
	  stderr: stderrColor$1
	} = supportsColor$1;
	const GENERATOR = Symbol('GENERATOR');
	const STYLER = Symbol('STYLER');
	const IS_EMPTY = Symbol('IS_EMPTY');

	// `supportsColor.level`  `ansiStyles.color[name]` mapping
	const levelMapping$1 = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
	const styles$1 = Object.create(null);
	const applyOptions$1 = (object, options = {}) => {
	  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
	    throw new Error('The `level` option should be an integer from 0 to 3');
	  }

	  // Detect level if not set manually
	  const colorLevel = stdoutColor$1 ? stdoutColor$1.level : 0;
	  object.level = options.level === undefined ? colorLevel : options.level;
	};
	const chalkFactory$1 = options => {
	  const chalk = (...strings) => strings.join(' ');
	  applyOptions$1(chalk, options);
	  Object.setPrototypeOf(chalk, createChalk.prototype);
	  return chalk;
	};
	function createChalk(options) {
	  return chalkFactory$1(options);
	}
	Object.setPrototypeOf(createChalk.prototype, Function.prototype);
	for (const [styleName, style] of Object.entries(ansiStyles$3)) {
	  styles$1[styleName] = {
	    get() {
	      const builder = createBuilder$1(this, createStyler$1(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
	      Object.defineProperty(this, styleName, {
	        value: builder
	      });
	      return builder;
	    }
	  };
	}
	styles$1.visible = {
	  get() {
	    const builder = createBuilder$1(this, this[STYLER], true);
	    Object.defineProperty(this, 'visible', {
	      value: builder
	    });
	    return builder;
	  }
	};
	const getModelAnsi = (model, level, type, ...arguments_) => {
	  if (model === 'rgb') {
	    if (level === 'ansi16m') {
	      return ansiStyles$3[type].ansi16m(...arguments_);
	    }
	    if (level === 'ansi256') {
	      return ansiStyles$3[type].ansi256(ansiStyles$3.rgbToAnsi256(...arguments_));
	    }
	    return ansiStyles$3[type].ansi(ansiStyles$3.rgbToAnsi(...arguments_));
	  }
	  if (model === 'hex') {
	    return getModelAnsi('rgb', level, type, ...ansiStyles$3.hexToRgb(...arguments_));
	  }
	  return ansiStyles$3[type][model](...arguments_);
	};
	const usedModels$1 = ['rgb', 'hex', 'ansi256'];
	for (const model of usedModels$1) {
	  styles$1[model] = {
	    get() {
	      const {
	        level
	      } = this;
	      return function (...arguments_) {
	        const styler = createStyler$1(getModelAnsi(model, levelMapping$1[level], 'color', ...arguments_), ansiStyles$3.color.close, this[STYLER]);
	        return createBuilder$1(this, styler, this[IS_EMPTY]);
	      };
	    }
	  };
	  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	  styles$1[bgModel] = {
	    get() {
	      const {
	        level
	      } = this;
	      return function (...arguments_) {
	        const styler = createStyler$1(getModelAnsi(model, levelMapping$1[level], 'bgColor', ...arguments_), ansiStyles$3.bgColor.close, this[STYLER]);
	        return createBuilder$1(this, styler, this[IS_EMPTY]);
	      };
	    }
	  };
	}
	const proto$1 = Object.defineProperties(() => {}, {
	  ...styles$1,
	  level: {
	    enumerable: true,
	    get() {
	      return this[GENERATOR].level;
	    },
	    set(level) {
	      this[GENERATOR].level = level;
	    }
	  }
	});
	const createStyler$1 = (open, close, parent) => {
	  let openAll;
	  let closeAll;
	  if (parent === undefined) {
	    openAll = open;
	    closeAll = close;
	  } else {
	    openAll = parent.openAll + open;
	    closeAll = close + parent.closeAll;
	  }
	  return {
	    open,
	    close,
	    openAll,
	    closeAll,
	    parent
	  };
	};
	const createBuilder$1 = (self, _styler, _isEmpty) => {
	  // Single argument is hot path, implicit coercion is faster than anything
	  // eslint-disable-next-line no-implicit-coercion
	  const builder = (...arguments_) => applyStyle$1(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));

	  // We alter the prototype because we must return a function, but there is
	  // no way to create a function with a different prototype
	  Object.setPrototypeOf(builder, proto$1);
	  builder[GENERATOR] = self;
	  builder[STYLER] = _styler;
	  builder[IS_EMPTY] = _isEmpty;
	  return builder;
	};
	const applyStyle$1 = (self, string) => {
	  if (self.level <= 0 || !string) {
	    return self[IS_EMPTY] ? '' : string;
	  }
	  let styler = self[STYLER];
	  if (styler === undefined) {
	    return string;
	  }
	  const {
	    openAll,
	    closeAll
	  } = styler;
	  if (string.includes('\u001B')) {
	    while (styler !== undefined) {
	      // Replace any instances already present with a re-opening code
	      // otherwise only the part of the string until said closing code
	      // will be colored, and the rest will simply be 'plain'.
	      string = stringReplaceAll$2(string, styler.close, styler.open);
	      styler = styler.parent;
	    }
	  }

	  // We can move both next actions out of loop, because remaining actions in loop won't have
	  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	  const lfIndex = string.indexOf('\n');
	  if (lfIndex !== -1) {
	    string = stringEncaseCRLFWithFirstIndex$2(string, closeAll, openAll, lfIndex);
	  }
	  return openAll + string + closeAll;
	};
	Object.defineProperties(createChalk.prototype, styles$1);
	const chalk$3 = createChalk();
	createChalk({
	  level: stderrColor$1 ? stderrColor$1.level : 0
	});

	/**
	 * chalk
	 * Antd
	 */

	const cError = text => console.log(chalk$3.hex("#f5222d").bold(text));
	const cSuccess = text => console.log(chalk$3.hex("#52c41a").bold(text));
	const wSuccess = text => chalk$3.hex("#52c41a").bold(text);

	const resolvePkg = async context => {
	  const filePath = path$e.join(context, "package.json");
	  if (fs$m.existsSync(filePath)) {
	    try {
	      const packageJsonContent = await fs$m.promises.readFile(filePath, "utf-8");
	      return JSON.parse(packageJsonContent);
	    } catch (error) {
	      console.error(error);
	    }
	  } else {
	    return {};
	  }
	};

	var onetime$3 = {exports: {}};

	var mimicFn$2 = {exports: {}};

	const mimicFn$1 = (to, from) => {
	  for (const prop of Reflect.ownKeys(from)) {
	    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
	  }
	  return to;
	};
	mimicFn$2.exports = mimicFn$1;
	// TODO: Remove this for the next major release
	mimicFn$2.exports.default = mimicFn$1;
	var mimicFnExports = mimicFn$2.exports;

	const mimicFn = mimicFnExports;
	const calledFunctions = new WeakMap();
	const onetime$1 = (function_, options = {}) => {
	  if (typeof function_ !== 'function') {
	    throw new TypeError('Expected a function');
	  }
	  let returnValue;
	  let callCount = 0;
	  const functionName = function_.displayName || function_.name || '<anonymous>';
	  const onetime = function (...arguments_) {
	    calledFunctions.set(onetime, ++callCount);
	    if (callCount === 1) {
	      returnValue = function_.apply(this, arguments_);
	      function_ = null;
	    } else if (options.throw === true) {
	      throw new Error(`Function \`${functionName}\` can only be called once`);
	    }
	    return returnValue;
	  };
	  mimicFn(onetime, function_);
	  calledFunctions.set(onetime, callCount);
	  return onetime;
	};
	onetime$3.exports = onetime$1;
	// TODO: Remove this for the next major release
	onetime$3.exports.default = onetime$1;
	onetime$3.exports.callCount = function_ => {
	  if (!calledFunctions.has(function_)) {
	    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
	  }
	  return calledFunctions.get(function_);
	};
	var onetimeExports = onetime$3.exports;
	var onetime$2 = /*@__PURE__*/getDefaultExportFromCjs(onetimeExports);

	var signalExit$2 = {exports: {}};

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$2 = {}.toString;

	var isArray$f = Array.isArray || function (arr) {
	  return toString$2.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */


	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$3.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	var _kMaxLength = kMaxLength();

	function kMaxLength () {
	  return Buffer$3.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$3.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$3(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$3 (arg, encodingOrOffset, length) {
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$3)) {
	    return new Buffer$3(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from$1(this, arg, encodingOrOffset, length)
	}

	Buffer$3.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$3._augment = function (arr) {
	  arr.__proto__ = Buffer$3.prototype;
	  return arr
	};

	function from$1 (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$3.from = function (value, encodingOrOffset, length) {
	  return from$1(null, value, encodingOrOffset, length)
	};

	if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	  Buffer$3.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$3.__proto__ = Uint8Array;
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer$3[Symbol.species] === Buffer$3) ;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$3.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$3.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$3.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$3.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike$1 (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$3.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike$1(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike$1(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$f(obj.data)) {
	      return fromArrayLike$1(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0;
	  }
	  return Buffer$3.alloc(+length)
	}
	Buffer$3.isBuffer = isBuffer$5;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$3.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$3.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$3.concat = function concat (list, length) {
	  if (!isArray$f(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$3.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$3.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$3.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$3.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$3.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$3.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$3.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$3.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$3.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$3.compare(this, b) === 0
	};

	Buffer$3.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$3.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$3.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$3.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$3.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$3.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$3.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$3.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$3.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$3.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$3.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$3(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$3.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$3.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$3.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$3.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$3.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$3.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$3.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$3.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$3.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$3.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$3.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$3.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$3.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$3.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$3.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$3.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$3.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$3.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$3.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$3.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$3.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$3.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$3.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$3.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$3.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$3.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$3.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$3.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$3.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$3(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$5(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var _polyfillNode_buffer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Buffer: Buffer$3,
		INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
		SlowBuffer: SlowBuffer,
		isBuffer: isBuffer$5,
		kMaxLength: _kMaxLength
	});

	var inherits$3;
	if (typeof Object.create === 'function'){
	  inherits$3 = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits$3 = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$4 = inherits$3;

	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
	  function getOwnPropertyDescriptors(obj) {
	    var keys = Object.keys(obj);
	    var descriptors = {};
	    for (var i = 0; i < keys.length; i++) {
	      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
	    }
	    return descriptors;
	  };

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect$1(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject$9(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect$1(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (browser$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (browser$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (browser$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = browser$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect$1(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect$1.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect$1.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect$1.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect$1.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction$4(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect$1 &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction$4(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$e(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction$4(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$e(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$e(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$e(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNullOrUndefined(arg) {
	  return arg == null;
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isSymbol$4(arg) {
	  return typeof arg === 'symbol';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp(re) {
	  return isObject$9(re) && objectToString$2(re) === '[object RegExp]';
	}

	function isObject$9(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate(d) {
	  return isObject$9(d) && objectToString$2(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject$9(e) &&
	      (objectToString$2(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction$4(arg) {
	  return typeof arg === 'function';
	}

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}

	function isBuffer$4(maybeBuf) {
	  return Buffer$3.isBuffer(maybeBuf);
	}

	function objectToString$2(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	function log() {
	  console.log('%s - %s', timestamp(), format.apply(null, arguments));
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject$9(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$e(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

	function promisify(original) {
	  if (typeof original !== 'function')
	    throw new TypeError('The "original" argument must be of type Function');

	  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
	    var fn = original[kCustomPromisifiedSymbol];
	    if (typeof fn !== 'function') {
	      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
	    }
	    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	      value: fn, enumerable: false, writable: false, configurable: true
	    });
	    return fn;
	  }

	  function fn() {
	    var promiseResolve, promiseReject;
	    var promise = new Promise(function (resolve, reject) {
	      promiseResolve = resolve;
	      promiseReject = reject;
	    });

	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }
	    args.push(function (err, value) {
	      if (err) {
	        promiseReject(err);
	      } else {
	        promiseResolve(value);
	      }
	    });

	    try {
	      original.apply(this, args);
	    } catch (err) {
	      promiseReject(err);
	    }

	    return promise;
	  }

	  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

	  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	    value: fn, enumerable: false, writable: false, configurable: true
	  });
	  return Object.defineProperties(
	    fn,
	    getOwnPropertyDescriptors(original)
	  );
	}

	promisify.custom = kCustomPromisifiedSymbol;

	function callbackifyOnRejected(reason, cb) {
	  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
	  // Because `null` is a special error value in callbacks which means "no error
	  // occurred", we error-wrap so the callback consumer can distinguish between
	  // "the promise rejected with null" or "the promise fulfilled with undefined".
	  if (!reason) {
	    var newReason = new Error('Promise was rejected with a falsy value');
	    newReason.reason = reason;
	    reason = newReason;
	  }
	  return cb(reason);
	}

	function callbackify(original) {
	  if (typeof original !== 'function') {
	    throw new TypeError('The "original" argument must be of type Function');
	  }

	  // We DO NOT return the promise as it gives the user a false sense that
	  // the promise is actually somehow related to the callback's execution
	  // and that the callback throwing will reject the promise.
	  function callbackified() {
	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }

	    var maybeCb = args.pop();
	    if (typeof maybeCb !== 'function') {
	      throw new TypeError('The last argument must be of type Function');
	    }
	    var self = this;
	    var cb = function() {
	      return maybeCb.apply(self, arguments);
	    };
	    // In true node style we process the callback on `nextTick` with all the
	    // implications (stack, `uncaughtException`, `async_hooks`)
	    original.apply(this, args)
	      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
	        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
	  }

	  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
	  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
	  return callbackified;
	}

	var _polyfillNode_util = {
	  inherits: inherits$4,
	  _extend: _extend,
	  log: log,
	  isBuffer: isBuffer$4,
	  isPrimitive: isPrimitive,
	  isFunction: isFunction$4,
	  isError: isError,
	  isDate: isDate,
	  isObject: isObject$9,
	  isRegExp: isRegExp,
	  isUndefined: isUndefined,
	  isSymbol: isSymbol$4,
	  isString: isString,
	  isNumber: isNumber,
	  isNullOrUndefined: isNullOrUndefined,
	  isNull: isNull,
	  isBoolean: isBoolean,
	  isArray: isArray$e,
	  inspect: inspect$1,
	  deprecate: deprecate,
	  format: format,
	  debuglog: debuglog,
	  promisify: promisify,
	  callbackify: callbackify,
	};

	var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		_extend: _extend,
		callbackify: callbackify,
		debuglog: debuglog,
		default: _polyfillNode_util,
		deprecate: deprecate,
		format: format,
		inherits: inherits$4,
		inspect: inspect$1,
		isArray: isArray$e,
		isBoolean: isBoolean,
		isBuffer: isBuffer$4,
		isDate: isDate,
		isError: isError,
		isFunction: isFunction$4,
		isNull: isNull,
		isNullOrUndefined: isNullOrUndefined,
		isNumber: isNumber,
		isObject: isObject$9,
		isPrimitive: isPrimitive,
		isRegExp: isRegExp,
		isString: isString,
		isSymbol: isSymbol$4,
		isUndefined: isUndefined,
		log: log,
		promisify: promisify
	});

	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	var hasOwn$1 = Object.prototype.hasOwnProperty;

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn$1.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	var pSlice = Array.prototype.slice;
	var _functionsHaveNames;
	function functionsHaveNames() {
	  if (typeof _functionsHaveNames !== 'undefined') {
	    return _functionsHaveNames;
	  }
	  return _functionsHaveNames = (function () {
	    return function foo() {}.name === 'foo';
	  }());
	}
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer$5(arrbuf)) {
	    return false;
	  }
	  if (typeof global$1.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	function assert$1(value, message) {
	  if (!value) fail(value, true, message, '==', ok);
	}

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex$1 = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!isFunction$4(func)) {
	    return;
	  }
	  if (functionsHaveNames()) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex$1);
	  return match && match[1];
	}
	assert$1.AssertionError = AssertionError;
	function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	}

	// assert.AssertionError instanceof Error
	inherits$4(AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames() || !isFunction$4(something)) {
	    return inspect$1(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert$1.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', ok);
	}
	assert$1.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	assert$1.equal = equal;
	function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', equal);
	}

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	assert$1.notEqual = notEqual;
	function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', notEqual);
	  }
	}

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	assert$1.deepEqual = deepEqual;
	function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', deepEqual);
	  }
	}
	assert$1.deepStrictEqual = deepStrictEqual;
	function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
	  }
	}

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer$5(actual) && isBuffer$5(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (isDate(actual) && isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (isRegExp(actual) && isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer$5(actual) !== isBuffer$5(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments$3(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (isPrimitive(a) || isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments$3(a);
	  var bIsArgs = isArguments$3(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	assert$1.notDeepEqual = notDeepEqual;
	function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
	  }
	}

	assert$1.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	assert$1.strictEqual = strictEqual;
	function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', strictEqual);
	  }
	}

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	assert$1.notStrictEqual = notStrictEqual;
	function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', notStrictEqual);
	  }
	}

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	assert$1.throws = throws;
	function throws(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	}

	// EXTENSION! This is annoying to write outside this module.
	assert$1.doesNotThrow = doesNotThrow;
	function doesNotThrow(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	}

	assert$1.ifError = ifError;
	function ifError(err) {
	  if (err) throw err;
	}

	var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AssertionError: AssertionError,
		assert: ok,
		deepEqual: deepEqual,
		deepStrictEqual: deepStrictEqual,
		default: assert$1,
		doesNotThrow: doesNotThrow,
		equal: equal,
		fail: fail,
		ifError: ifError,
		notDeepEqual: notDeepEqual,
		notDeepStrictEqual: notDeepStrictEqual,
		notEqual: notEqual,
		notStrictEqual: notStrictEqual,
		ok: ok,
		strictEqual: strictEqual,
		throws: throws
	});

	var require$$5$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

	var signals$1 = {exports: {}};

	var hasRequiredSignals;
	function requireSignals() {
	  if (hasRequiredSignals) return signals$1.exports;
	  hasRequiredSignals = 1;
	  (function (module) {
	    // This is not the set of all possible signals.
	    //
	    // It IS, however, the set of all signals that trigger
	    // an exit on either Linux or BSD systems.  Linux is a
	    // superset of the signal names supported on BSD, and
	    // the unknown signals just fail to register, so we can
	    // catch that easily enough.
	    //
	    // Don't bother with SIGKILL.  It's uncatchable, which
	    // means that we can't fire any callbacks anyway.
	    //
	    // If a user does happen to register a handler on a non-
	    // fatal signal like SIGWINCH or something, and then
	    // exit, it'll end up firing `process.emit('exit')`, so
	    // the handler will be fired anyway.
	    //
	    // SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
	    // artificially, inherently leave the process in a
	    // state from which it is not safe to try and enter JS
	    // listeners.
	    module.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];
	    if (process.platform !== 'win32') {
	      module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'
	      // should detect profiler and enable/disable accordingly.
	      // see #21
	      // 'SIGPROF'
	      );
	    }
	    if (process.platform === 'linux') {
	      module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');
	    }
	  })(signals$1);
	  return signals$1.exports;
	}

	// Note: since nyc uses this module to output coverage, any lines
	// that are in the direct sync flow of nyc's outputCoverage are
	// ignored, since we can never get coverage for them.
	// grab a reference to node's real process object right away
	var process$2 = commonjsGlobal.process;
	const processOk = function (process) {
	  return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
	};

	// some kind of non-node environment, just no-op
	/* istanbul ignore if */
	if (!processOk(process$2)) {
	  signalExit$2.exports = function () {
	    return function () {};
	  };
	} else {
	  var assert = require$$5$1;
	  var signals = requireSignals();
	  var isWin = /^win/i.test(process$2.platform);
	  var EE = require$$0$8;
	  /* istanbul ignore if */
	  if (typeof EE !== 'function') {
	    EE = EE.EventEmitter;
	  }
	  var emitter;
	  if (process$2.__signal_exit_emitter__) {
	    emitter = process$2.__signal_exit_emitter__;
	  } else {
	    emitter = process$2.__signal_exit_emitter__ = new EE();
	    emitter.count = 0;
	    emitter.emitted = {};
	  }

	  // Because this emitter is a global, we have to check to see if a
	  // previous version of this library failed to enable infinite listeners.
	  // I know what you're about to say.  But literally everything about
	  // signal-exit is a compromise with evil.  Get used to it.
	  if (!emitter.infinite) {
	    emitter.setMaxListeners(Infinity);
	    emitter.infinite = true;
	  }
	  signalExit$2.exports = function (cb, opts) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return function () {};
	    }
	    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');
	    if (loaded === false) {
	      load();
	    }
	    var ev = 'exit';
	    if (opts && opts.alwaysLast) {
	      ev = 'afterexit';
	    }
	    var remove = function () {
	      emitter.removeListener(ev, cb);
	      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
	        unload();
	      }
	    };
	    emitter.on(ev, cb);
	    return remove;
	  };
	  var unload = function unload() {
	    if (!loaded || !processOk(commonjsGlobal.process)) {
	      return;
	    }
	    loaded = false;
	    signals.forEach(function (sig) {
	      try {
	        process$2.removeListener(sig, sigListeners[sig]);
	      } catch (er) {}
	    });
	    process$2.emit = originalProcessEmit;
	    process$2.reallyExit = originalProcessReallyExit;
	    emitter.count -= 1;
	  };
	  signalExit$2.exports.unload = unload;
	  var emit = function emit(event, code, signal) {
	    /* istanbul ignore if */
	    if (emitter.emitted[event]) {
	      return;
	    }
	    emitter.emitted[event] = true;
	    emitter.emit(event, code, signal);
	  };

	  // { <signal>: <listener fn>, ... }
	  var sigListeners = {};
	  signals.forEach(function (sig) {
	    sigListeners[sig] = function listener() {
	      /* istanbul ignore if */
	      if (!processOk(commonjsGlobal.process)) {
	        return;
	      }
	      // If there are no other listeners, an exit is coming!
	      // Simplest way: remove us and then re-send the signal.
	      // We know that this will kill the process, so we can
	      // safely emit now.
	      var listeners = process$2.listeners(sig);
	      if (listeners.length === emitter.count) {
	        unload();
	        emit('exit', null, sig);
	        /* istanbul ignore next */
	        emit('afterexit', null, sig);
	        /* istanbul ignore next */
	        if (isWin && sig === 'SIGHUP') {
	          // "SIGHUP" throws an `ENOSYS` error on Windows,
	          // so use a supported signal instead
	          sig = 'SIGINT';
	        }
	        /* istanbul ignore next */
	        process$2.kill(process$2.pid, sig);
	      }
	    };
	  });
	  signalExit$2.exports.signals = function () {
	    return signals;
	  };
	  var loaded = false;
	  var load = function load() {
	    if (loaded || !processOk(commonjsGlobal.process)) {
	      return;
	    }
	    loaded = true;

	    // This is the number of onSignalExit's that are in play.
	    // It's important so that we can count the correct number of
	    // listeners on signals, and don't wait for the other one to
	    // handle it instead of us.
	    emitter.count += 1;
	    signals = signals.filter(function (sig) {
	      try {
	        process$2.on(sig, sigListeners[sig]);
	        return true;
	      } catch (er) {
	        return false;
	      }
	    });
	    process$2.emit = processEmit;
	    process$2.reallyExit = processReallyExit;
	  };
	  signalExit$2.exports.load = load;
	  var originalProcessReallyExit = process$2.reallyExit;
	  var processReallyExit = function processReallyExit(code) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return;
	    }
	    process$2.exitCode = code || /* istanbul ignore next */0;
	    emit('exit', process$2.exitCode, null);
	    /* istanbul ignore next */
	    emit('afterexit', process$2.exitCode, null);
	    /* istanbul ignore next */
	    originalProcessReallyExit.call(process$2, process$2.exitCode);
	  };
	  var originalProcessEmit = process$2.emit;
	  var processEmit = function processEmit(ev, arg) {
	    if (ev === 'exit' && processOk(commonjsGlobal.process)) {
	      /* istanbul ignore else */
	      if (arg !== undefined) {
	        process$2.exitCode = arg;
	      }
	      var ret = originalProcessEmit.apply(this, arguments);
	      /* istanbul ignore next */
	      emit('exit', process$2.exitCode, null);
	      /* istanbul ignore next */
	      emit('afterexit', process$2.exitCode, null);
	      /* istanbul ignore next */
	      return ret;
	    } else {
	      return originalProcessEmit.apply(this, arguments);
	    }
	  };
	}
	var signalExitExports = signalExit$2.exports;
	var signalExit$1 = /*@__PURE__*/getDefaultExportFromCjs(signalExitExports);

	const restoreCursor$1 = onetime$2(() => {
	  signalExit$1(() => {
	    process$4.stderr.write('\u001B[?25h');
	  }, {
	    alwaysLast: true
	  });
	});

	let isHidden = false;
	const cliCursor$3 = {};
	cliCursor$3.show = (writableStream = process$4.stderr) => {
	  if (!writableStream.isTTY) {
	    return;
	  }
	  isHidden = false;
	  writableStream.write('\u001B[?25h');
	};
	cliCursor$3.hide = (writableStream = process$4.stderr) => {
	  if (!writableStream.isTTY) {
	    return;
	  }
	  restoreCursor$1();
	  isHidden = true;
	  writableStream.write('\u001B[?25l');
	};
	cliCursor$3.toggle = (force, writableStream) => {
	  if (force !== undefined) {
	    isHidden = force;
	  }
	  if (isHidden) {
	    cliCursor$3.show(writableStream);
	  } else {
	    cliCursor$3.hide(writableStream);
	  }
	};

	var dots = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots2 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots3 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots4 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots5 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots6 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots7 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots8 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots9 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots10 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots11 = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots12 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots13 = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dots8Bit = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var sand = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var line = {
		interval: 130,
		frames: [
			"-",
			"\\",
			"|",
			"/"
		]
	};
	var line2 = {
		interval: 100,
		frames: [
			"",
			"-",
			"",
			"",
			"",
			"-"
		]
	};
	var pipe = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var simpleDots = {
		interval: 400,
		frames: [
			".  ",
			".. ",
			"...",
			"   "
		]
	};
	var simpleDotsScrolling = {
		interval: 200,
		frames: [
			".  ",
			".. ",
			"...",
			" ..",
			"  .",
			"   "
		]
	};
	var star = {
		interval: 70,
		frames: [
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var star2 = {
		interval: 80,
		frames: [
			"+",
			"x",
			"*"
		]
	};
	var flip = {
		interval: 70,
		frames: [
			"_",
			"_",
			"_",
			"-",
			"`",
			"`",
			"'",
			"",
			"-",
			"_",
			"_",
			"_"
		]
	};
	var hamburger = {
		interval: 100,
		frames: [
			"",
			"",
			""
		]
	};
	var growVertical = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var growHorizontal = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var balloon = {
		interval: 140,
		frames: [
			" ",
			".",
			"o",
			"O",
			"@",
			"*",
			" "
		]
	};
	var balloon2 = {
		interval: 120,
		frames: [
			".",
			"o",
			"O",
			"",
			"O",
			"o",
			"."
		]
	};
	var noise = {
		interval: 100,
		frames: [
			"",
			"",
			""
		]
	};
	var bounce = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var boxBounce = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var boxBounce2 = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var triangle = {
		interval: 50,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var binary = {
		interval: 80,
		frames: [
			"010010",
			"001100",
			"100101",
			"111010",
			"111101",
			"010111",
			"101011",
			"111000",
			"110011",
			"110101"
		]
	};
	var arc = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var circle = {
		interval: 120,
		frames: [
			"",
			"",
			""
		]
	};
	var squareCorners = {
		interval: 180,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var circleQuarters = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var circleHalves = {
		interval: 50,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var squish = {
		interval: 100,
		frames: [
			"",
			""
		]
	};
	var toggle = {
		interval: 250,
		frames: [
			"",
			""
		]
	};
	var toggle2 = {
		interval: 80,
		frames: [
			"",
			""
		]
	};
	var toggle3 = {
		interval: 120,
		frames: [
			"",
			""
		]
	};
	var toggle4 = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			""
		]
	};
	var toggle5 = {
		interval: 100,
		frames: [
			"",
			""
		]
	};
	var toggle6 = {
		interval: 300,
		frames: [
			"",
			""
		]
	};
	var toggle7 = {
		interval: 80,
		frames: [
			"",
			""
		]
	};
	var toggle8 = {
		interval: 100,
		frames: [
			"",
			""
		]
	};
	var toggle9 = {
		interval: 100,
		frames: [
			"",
			""
		]
	};
	var toggle10 = {
		interval: 100,
		frames: [
			"",
			"",
			""
		]
	};
	var toggle11 = {
		interval: 50,
		frames: [
			"",
			""
		]
	};
	var toggle12 = {
		interval: 120,
		frames: [
			"",
			""
		]
	};
	var toggle13 = {
		interval: 80,
		frames: [
			"=",
			"*",
			"-"
		]
	};
	var arrow = {
		interval: 100,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var arrow2 = {
		interval: 80,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var arrow3 = {
		interval: 120,
		frames: [
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var bouncingBar = {
		interval: 80,
		frames: [
			"[    ]",
			"[=   ]",
			"[==  ]",
			"[=== ]",
			"[====]",
			"[ ===]",
			"[  ==]",
			"[   =]",
			"[    ]",
			"[   =]",
			"[  ==]",
			"[ ===]",
			"[====]",
			"[=== ]",
			"[==  ]",
			"[=   ]"
		]
	};
	var bouncingBall = {
		interval: 80,
		frames: [
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )",
			"(     )"
		]
	};
	var smiley = {
		interval: 200,
		frames: [
			" ",
			" "
		]
	};
	var monkey = {
		interval: 300,
		frames: [
			" ",
			" ",
			" ",
			" "
		]
	};
	var hearts = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var clock = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var earth = {
		interval: 180,
		frames: [
			" ",
			" ",
			" "
		]
	};
	var material = {
		interval: 17,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var moon = {
		interval: 80,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var runner = {
		interval: 140,
		frames: [
			" ",
			" "
		]
	};
	var pong = {
		interval: 80,
		frames: [
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       "
		]
	};
	var shark = {
		interval: 120,
		frames: [
			"|\\____________",
			"_|\\___________",
			"__|\\__________",
			"___|\\_________",
			"____|\\________",
			"_____|\\_______",
			"______|\\______",
			"_______|\\_____",
			"________|\\____",
			"_________|\\___",
			"__________|\\__",
			"___________|\\_",
			"____________|\\",
			"____________/|",
			"___________/|_",
			"__________/|__",
			"_________/|___",
			"________/|____",
			"_______/|_____",
			"______/|______",
			"_____/|_______",
			"____/|________",
			"___/|_________",
			"__/|__________",
			"_/|___________",
			"/|____________"
		]
	};
	var dqpb = {
		interval: 100,
		frames: [
			"d",
			"q",
			"p",
			"b"
		]
	};
	var weather = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var christmas = {
		interval: 400,
		frames: [
			"",
			""
		]
	};
	var grenade = {
		interval: 80,
		frames: [
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  |",
			"  ",
			"  ",
			"  ",
			"  ",
			"   ",
			"   ",
			"   "
		]
	};
	var point = {
		interval: 125,
		frames: [
			"",
			"",
			"",
			"",
			""
		]
	};
	var layer = {
		interval: 150,
		frames: [
			"-",
			"=",
			""
		]
	};
	var betaWave = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var fingerDance = {
		interval: 160,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var fistBump = {
		interval: 80,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var soccerHeader = {
		interval: 80,
		frames: [
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         "
		]
	};
	var mindblown = {
		interval: 160,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var speaker = {
		interval: 160,
		frames: [
			" ",
			" ",
			" ",
			" "
		]
	};
	var orangePulse = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var bluePulse = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var orangeBluePulse = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var timeTravel = {
		interval: 100,
		frames: [
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" ",
			" "
		]
	};
	var aesthetic = {
		interval: 80,
		frames: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	};
	var dwarfFortress = {
		interval: 80,
		frames: [
			"   ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"  ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   ",
			"    ",
			"    ",
			"    ",
			"    ",
			"    ",
			"    ",
			"    ",
			"    ",
			"    ",
			"     ",
			"     ",
			"     ",
			"     ",
			"     ",
			"     ",
			"     ",
			"     ",
			"     ",
			"      ",
			"      ",
			"      ",
			"      ",
			"      ",
			"      ",
			"      ",
			"      ",
			"      ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"       ",
			"        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"         ",
			"          ",
			"          ",
			"          ",
			"          ",
			"          ",
			"          ",
			"          ",
			"          ",
			"          ",
			"           ",
			"          &",
			"         &",
			"         &",
			"         &",
			"        & ",
			"         & ",
			"        &  ",
			"        &  ",
			"       &   ",
			"       &   ",
			"      &    ",
			"      &    ",
			"      &     ",
			"      &     ",
			"     &     ",
			"     &     ",
			"    &      ",
			"    &      ",
			"   &      ",
			"   &      ",
			"  &       ",
			"  &       ",
			" &       ",
			" &       ",
			"&        ",
			"&        ",
			"        ",
			"        ",
			"        ",
			"        ",
			"       ",
			"       ",
			"       ",
			"       ",
			"      ",
			"      ",
			"      ",
			"      ",
			"     ",
			"     ",
			"     ",
			"     ",
			"    ",
			"    ",
			"    ",
			"    ",
			"   ",
			"   ",
			"   ",
			"   ",
			"   "
		]
	};
	var require$$0$7 = {
		dots: dots,
		dots2: dots2,
		dots3: dots3,
		dots4: dots4,
		dots5: dots5,
		dots6: dots6,
		dots7: dots7,
		dots8: dots8,
		dots9: dots9,
		dots10: dots10,
		dots11: dots11,
		dots12: dots12,
		dots13: dots13,
		dots8Bit: dots8Bit,
		sand: sand,
		line: line,
		line2: line2,
		pipe: pipe,
		simpleDots: simpleDots,
		simpleDotsScrolling: simpleDotsScrolling,
		star: star,
		star2: star2,
		flip: flip,
		hamburger: hamburger,
		growVertical: growVertical,
		growHorizontal: growHorizontal,
		balloon: balloon,
		balloon2: balloon2,
		noise: noise,
		bounce: bounce,
		boxBounce: boxBounce,
		boxBounce2: boxBounce2,
		triangle: triangle,
		binary: binary,
		arc: arc,
		circle: circle,
		squareCorners: squareCorners,
		circleQuarters: circleQuarters,
		circleHalves: circleHalves,
		squish: squish,
		toggle: toggle,
		toggle2: toggle2,
		toggle3: toggle3,
		toggle4: toggle4,
		toggle5: toggle5,
		toggle6: toggle6,
		toggle7: toggle7,
		toggle8: toggle8,
		toggle9: toggle9,
		toggle10: toggle10,
		toggle11: toggle11,
		toggle12: toggle12,
		toggle13: toggle13,
		arrow: arrow,
		arrow2: arrow2,
		arrow3: arrow3,
		bouncingBar: bouncingBar,
		bouncingBall: bouncingBall,
		smiley: smiley,
		monkey: monkey,
		hearts: hearts,
		clock: clock,
		earth: earth,
		material: material,
		moon: moon,
		runner: runner,
		pong: pong,
		shark: shark,
		dqpb: dqpb,
		weather: weather,
		christmas: christmas,
		grenade: grenade,
		point: point,
		layer: layer,
		betaWave: betaWave,
		fingerDance: fingerDance,
		fistBump: fistBump,
		soccerHeader: soccerHeader,
		mindblown: mindblown,
		speaker: speaker,
		orangePulse: orangePulse,
		bluePulse: bluePulse,
		orangeBluePulse: orangeBluePulse,
		timeTravel: timeTravel,
		aesthetic: aesthetic,
		dwarfFortress: dwarfFortress
	};

	const spinners = Object.assign({}, require$$0$7); // eslint-disable-line import/extensions

	const spinnersList = Object.keys(spinners);
	Object.defineProperty(spinners, 'random', {
	  get() {
	    const randomIndex = Math.floor(Math.random() * spinnersList.length);
	    const spinnerName = spinnersList[randomIndex];
	    return spinners[spinnerName];
	  }
	});
	var cliSpinners$1 = spinners;
	var cliSpinners$2 = /*@__PURE__*/getDefaultExportFromCjs(cliSpinners$1);

	const logSymbols$2 = {
	  info: '',
	  success: '',
	  warning: '',
	  error: ''
	};

	function ansiRegex$2({
	  onlyFirst = false
	} = {}) {
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
	  return new RegExp(pattern, onlyFirst ? undefined : 'g');
	}

	const regex = ansiRegex$2();
	function stripAnsi$5(string) {
	  if (typeof string !== 'string') {
	    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	  }

	  // Even though the regex is global, we don't need to reset the `.lastIndex`
	  // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	  // and doing it manually has a performance penalty.
	  return string.replace(regex, '');
	}

	// Generated code.

	function isAmbiguous(x) {
	  return x === 0xA1 || x === 0xA4 || x === 0xA7 || x === 0xA8 || x === 0xAA || x === 0xAD || x === 0xAE || x >= 0xB0 && x <= 0xB4 || x >= 0xB6 && x <= 0xBA || x >= 0xBC && x <= 0xBF || x === 0xC6 || x === 0xD0 || x === 0xD7 || x === 0xD8 || x >= 0xDE && x <= 0xE1 || x === 0xE6 || x >= 0xE8 && x <= 0xEA || x === 0xEC || x === 0xED || x === 0xF0 || x === 0xF2 || x === 0xF3 || x >= 0xF7 && x <= 0xFA || x === 0xFC || x === 0xFE || x === 0x101 || x === 0x111 || x === 0x113 || x === 0x11B || x === 0x126 || x === 0x127 || x === 0x12B || x >= 0x131 && x <= 0x133 || x === 0x138 || x >= 0x13F && x <= 0x142 || x === 0x144 || x >= 0x148 && x <= 0x14B || x === 0x14D || x === 0x152 || x === 0x153 || x === 0x166 || x === 0x167 || x === 0x16B || x === 0x1CE || x === 0x1D0 || x === 0x1D2 || x === 0x1D4 || x === 0x1D6 || x === 0x1D8 || x === 0x1DA || x === 0x1DC || x === 0x251 || x === 0x261 || x === 0x2C4 || x === 0x2C7 || x >= 0x2C9 && x <= 0x2CB || x === 0x2CD || x === 0x2D0 || x >= 0x2D8 && x <= 0x2DB || x === 0x2DD || x === 0x2DF || x >= 0x300 && x <= 0x36F || x >= 0x391 && x <= 0x3A1 || x >= 0x3A3 && x <= 0x3A9 || x >= 0x3B1 && x <= 0x3C1 || x >= 0x3C3 && x <= 0x3C9 || x === 0x401 || x >= 0x410 && x <= 0x44F || x === 0x451 || x === 0x2010 || x >= 0x2013 && x <= 0x2016 || x === 0x2018 || x === 0x2019 || x === 0x201C || x === 0x201D || x >= 0x2020 && x <= 0x2022 || x >= 0x2024 && x <= 0x2027 || x === 0x2030 || x === 0x2032 || x === 0x2033 || x === 0x2035 || x === 0x203B || x === 0x203E || x === 0x2074 || x === 0x207F || x >= 0x2081 && x <= 0x2084 || x === 0x20AC || x === 0x2103 || x === 0x2105 || x === 0x2109 || x === 0x2113 || x === 0x2116 || x === 0x2121 || x === 0x2122 || x === 0x2126 || x === 0x212B || x === 0x2153 || x === 0x2154 || x >= 0x215B && x <= 0x215E || x >= 0x2160 && x <= 0x216B || x >= 0x2170 && x <= 0x2179 || x === 0x2189 || x >= 0x2190 && x <= 0x2199 || x === 0x21B8 || x === 0x21B9 || x === 0x21D2 || x === 0x21D4 || x === 0x21E7 || x === 0x2200 || x === 0x2202 || x === 0x2203 || x === 0x2207 || x === 0x2208 || x === 0x220B || x === 0x220F || x === 0x2211 || x === 0x2215 || x === 0x221A || x >= 0x221D && x <= 0x2220 || x === 0x2223 || x === 0x2225 || x >= 0x2227 && x <= 0x222C || x === 0x222E || x >= 0x2234 && x <= 0x2237 || x === 0x223C || x === 0x223D || x === 0x2248 || x === 0x224C || x === 0x2252 || x === 0x2260 || x === 0x2261 || x >= 0x2264 && x <= 0x2267 || x === 0x226A || x === 0x226B || x === 0x226E || x === 0x226F || x === 0x2282 || x === 0x2283 || x === 0x2286 || x === 0x2287 || x === 0x2295 || x === 0x2299 || x === 0x22A5 || x === 0x22BF || x === 0x2312 || x >= 0x2460 && x <= 0x24E9 || x >= 0x24EB && x <= 0x254B || x >= 0x2550 && x <= 0x2573 || x >= 0x2580 && x <= 0x258F || x >= 0x2592 && x <= 0x2595 || x === 0x25A0 || x === 0x25A1 || x >= 0x25A3 && x <= 0x25A9 || x === 0x25B2 || x === 0x25B3 || x === 0x25B6 || x === 0x25B7 || x === 0x25BC || x === 0x25BD || x === 0x25C0 || x === 0x25C1 || x >= 0x25C6 && x <= 0x25C8 || x === 0x25CB || x >= 0x25CE && x <= 0x25D1 || x >= 0x25E2 && x <= 0x25E5 || x === 0x25EF || x === 0x2605 || x === 0x2606 || x === 0x2609 || x === 0x260E || x === 0x260F || x === 0x261C || x === 0x261E || x === 0x2640 || x === 0x2642 || x === 0x2660 || x === 0x2661 || x >= 0x2663 && x <= 0x2665 || x >= 0x2667 && x <= 0x266A || x === 0x266C || x === 0x266D || x === 0x266F || x === 0x269E || x === 0x269F || x === 0x26BF || x >= 0x26C6 && x <= 0x26CD || x >= 0x26CF && x <= 0x26D3 || x >= 0x26D5 && x <= 0x26E1 || x === 0x26E3 || x === 0x26E8 || x === 0x26E9 || x >= 0x26EB && x <= 0x26F1 || x === 0x26F4 || x >= 0x26F6 && x <= 0x26F9 || x === 0x26FB || x === 0x26FC || x === 0x26FE || x === 0x26FF || x === 0x273D || x >= 0x2776 && x <= 0x277F || x >= 0x2B56 && x <= 0x2B59 || x >= 0x3248 && x <= 0x324F || x >= 0xE000 && x <= 0xF8FF || x >= 0xFE00 && x <= 0xFE0F || x === 0xFFFD || x >= 0x1F100 && x <= 0x1F10A || x >= 0x1F110 && x <= 0x1F12D || x >= 0x1F130 && x <= 0x1F169 || x >= 0x1F170 && x <= 0x1F18D || x === 0x1F18F || x === 0x1F190 || x >= 0x1F19B && x <= 0x1F1AC || x >= 0xE0100 && x <= 0xE01EF || x >= 0xF0000 && x <= 0xFFFFD || x >= 0x100000 && x <= 0x10FFFD;
	}
	function isFullWidth(x) {
	  return x === 0x3000 || x >= 0xFF01 && x <= 0xFF60 || x >= 0xFFE0 && x <= 0xFFE6;
	}
	function isWide(x) {
	  return x >= 0x1100 && x <= 0x115F || x === 0x231A || x === 0x231B || x === 0x2329 || x === 0x232A || x >= 0x23E9 && x <= 0x23EC || x === 0x23F0 || x === 0x23F3 || x === 0x25FD || x === 0x25FE || x === 0x2614 || x === 0x2615 || x >= 0x2648 && x <= 0x2653 || x === 0x267F || x === 0x2693 || x === 0x26A1 || x === 0x26AA || x === 0x26AB || x === 0x26BD || x === 0x26BE || x === 0x26C4 || x === 0x26C5 || x === 0x26CE || x === 0x26D4 || x === 0x26EA || x === 0x26F2 || x === 0x26F3 || x === 0x26F5 || x === 0x26FA || x === 0x26FD || x === 0x2705 || x === 0x270A || x === 0x270B || x === 0x2728 || x === 0x274C || x === 0x274E || x >= 0x2753 && x <= 0x2755 || x === 0x2757 || x >= 0x2795 && x <= 0x2797 || x === 0x27B0 || x === 0x27BF || x === 0x2B1B || x === 0x2B1C || x === 0x2B50 || x === 0x2B55 || x >= 0x2E80 && x <= 0x2E99 || x >= 0x2E9B && x <= 0x2EF3 || x >= 0x2F00 && x <= 0x2FD5 || x >= 0x2FF0 && x <= 0x2FFF || x >= 0x3001 && x <= 0x303E || x >= 0x3041 && x <= 0x3096 || x >= 0x3099 && x <= 0x30FF || x >= 0x3105 && x <= 0x312F || x >= 0x3131 && x <= 0x318E || x >= 0x3190 && x <= 0x31E3 || x >= 0x31EF && x <= 0x321E || x >= 0x3220 && x <= 0x3247 || x >= 0x3250 && x <= 0x4DBF || x >= 0x4E00 && x <= 0xA48C || x >= 0xA490 && x <= 0xA4C6 || x >= 0xA960 && x <= 0xA97C || x >= 0xAC00 && x <= 0xD7A3 || x >= 0xF900 && x <= 0xFAFF || x >= 0xFE10 && x <= 0xFE19 || x >= 0xFE30 && x <= 0xFE52 || x >= 0xFE54 && x <= 0xFE66 || x >= 0xFE68 && x <= 0xFE6B || x >= 0x16FE0 && x <= 0x16FE4 || x === 0x16FF0 || x === 0x16FF1 || x >= 0x17000 && x <= 0x187F7 || x >= 0x18800 && x <= 0x18CD5 || x >= 0x18D00 && x <= 0x18D08 || x >= 0x1AFF0 && x <= 0x1AFF3 || x >= 0x1AFF5 && x <= 0x1AFFB || x === 0x1AFFD || x === 0x1AFFE || x >= 0x1B000 && x <= 0x1B122 || x === 0x1B132 || x >= 0x1B150 && x <= 0x1B152 || x === 0x1B155 || x >= 0x1B164 && x <= 0x1B167 || x >= 0x1B170 && x <= 0x1B2FB || x === 0x1F004 || x === 0x1F0CF || x === 0x1F18E || x >= 0x1F191 && x <= 0x1F19A || x >= 0x1F200 && x <= 0x1F202 || x >= 0x1F210 && x <= 0x1F23B || x >= 0x1F240 && x <= 0x1F248 || x === 0x1F250 || x === 0x1F251 || x >= 0x1F260 && x <= 0x1F265 || x >= 0x1F300 && x <= 0x1F320 || x >= 0x1F32D && x <= 0x1F335 || x >= 0x1F337 && x <= 0x1F37C || x >= 0x1F37E && x <= 0x1F393 || x >= 0x1F3A0 && x <= 0x1F3CA || x >= 0x1F3CF && x <= 0x1F3D3 || x >= 0x1F3E0 && x <= 0x1F3F0 || x === 0x1F3F4 || x >= 0x1F3F8 && x <= 0x1F43E || x === 0x1F440 || x >= 0x1F442 && x <= 0x1F4FC || x >= 0x1F4FF && x <= 0x1F53D || x >= 0x1F54B && x <= 0x1F54E || x >= 0x1F550 && x <= 0x1F567 || x === 0x1F57A || x === 0x1F595 || x === 0x1F596 || x === 0x1F5A4 || x >= 0x1F5FB && x <= 0x1F64F || x >= 0x1F680 && x <= 0x1F6C5 || x === 0x1F6CC || x >= 0x1F6D0 && x <= 0x1F6D2 || x >= 0x1F6D5 && x <= 0x1F6D7 || x >= 0x1F6DC && x <= 0x1F6DF || x === 0x1F6EB || x === 0x1F6EC || x >= 0x1F6F4 && x <= 0x1F6FC || x >= 0x1F7E0 && x <= 0x1F7EB || x === 0x1F7F0 || x >= 0x1F90C && x <= 0x1F93A || x >= 0x1F93C && x <= 0x1F945 || x >= 0x1F947 && x <= 0x1F9FF || x >= 0x1FA70 && x <= 0x1FA7C || x >= 0x1FA80 && x <= 0x1FA88 || x >= 0x1FA90 && x <= 0x1FABD || x >= 0x1FABF && x <= 0x1FAC5 || x >= 0x1FACE && x <= 0x1FADB || x >= 0x1FAE0 && x <= 0x1FAE8 || x >= 0x1FAF0 && x <= 0x1FAF8 || x >= 0x20000 && x <= 0x2FFFD || x >= 0x30000 && x <= 0x3FFFD;
	}

	function validate(codePoint) {
	  if (!Number.isSafeInteger(codePoint)) {
	    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
	  }
	}
	function eastAsianWidth(codePoint, {
	  ambiguousAsWide = false
	} = {}) {
	  validate(codePoint);
	  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
	    return 2;
	  }
	  return 1;
	}

	var emojiRegex$2 = (() => {
	  // https://mths.be/emoji
	  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
	});

	const segmenter = new Intl.Segmenter();
	function stringWidth$4(string, options = {}) {
	  if (typeof string !== 'string' || string.length === 0) {
	    return 0;
	  }
	  const {
	    ambiguousIsNarrow = true,
	    countAnsiEscapeCodes = false
	  } = options;
	  if (!countAnsiEscapeCodes) {
	    string = stripAnsi$5(string);
	  }
	  if (string.length === 0) {
	    return 0;
	  }
	  let width = 0;
	  const eastAsianWidthOptions = {
	    ambiguousAsWide: !ambiguousIsNarrow
	  };
	  for (const {
	    segment: character
	  } of segmenter.segment(string)) {
	    const codePoint = character.codePointAt(0);

	    // Ignore control characters
	    if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) {
	      continue;
	    }

	    // Ignore combining characters
	    if (codePoint >= 0x3_00 && codePoint <= 0x3_6F) {
	      continue;
	    }
	    if (emojiRegex$2().test(character)) {
	      width += 2;
	      continue;
	    }
	    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	  }
	  return width;
	}

	function isInteractive$2({
	  stream = process.stdout
	} = {}) {
	  return Boolean(stream && stream.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env));
	}

	function isUnicodeSupported$4() {
	  if (process$4.platform !== 'win32') {
	    return process$4.env.TERM !== 'linux'; // Linux console (kernel)
	  }
	  return Boolean(process$4.env.WT_SESSION) // Windows Terminal
	  || Boolean(process$4.env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
	  || process$4.env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
	  || process$4.env.TERM_PROGRAM === 'Terminus-Sublime' || process$4.env.TERM_PROGRAM === 'vscode' || process$4.env.TERM === 'xterm-256color' || process$4.env.TERM === 'alacritty' || process$4.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
	}

	const ASCII_ETX_CODE$1 = 0x03; // Ctrl+C emits this code

	let StdinDiscarder$1 = class StdinDiscarder {
	  #activeCount = 0;
	  start() {
	    this.#activeCount++;
	    if (this.#activeCount === 1) {
	      this.#realStart();
	    }
	  }
	  stop() {
	    if (this.#activeCount <= 0) {
	      throw new Error('`stop` called more times than `start`');
	    }
	    this.#activeCount--;
	    if (this.#activeCount === 0) {
	      this.#realStop();
	    }
	  }
	  #realStart() {
	    // No known way to make it work reliably on Windows.
	    if (process$4.platform === 'win32' || !process$4.stdin.isTTY) {
	      return;
	    }
	    process$4.stdin.setRawMode(true);
	    process$4.stdin.on('data', this.#handleInput);
	    process$4.stdin.resume();
	  }
	  #realStop() {
	    if (!process$4.stdin.isTTY) {
	      return;
	    }
	    process$4.stdin.off('data', this.#handleInput);
	    process$4.stdin.pause();
	    process$4.stdin.setRawMode(false);
	  }
	  #handleInput(chunk) {
	    // Allow Ctrl+C to gracefully exit.
	    if (chunk[0] === ASCII_ETX_CODE$1) {
	      process$4.emit('SIGINT');
	    }
	  }
	};
	const stdinDiscarder$1 = new StdinDiscarder$1();

	let Ora$1 = class Ora {
	  #linesToClear = 0;
	  #isDiscardingStdin = false;
	  #lineCount = 0;
	  #frameIndex = 0;
	  #options;
	  #spinner;
	  #stream;
	  #id;
	  #initialInterval;
	  #isEnabled;
	  #isSilent;
	  #indent;
	  #text;
	  #prefixText;
	  #suffixText;
	  color;
	  constructor(options) {
	    if (typeof options === 'string') {
	      options = {
	        text: options
	      };
	    }
	    this.#options = {
	      color: 'cyan',
	      stream: process$4.stderr,
	      discardStdin: true,
	      hideCursor: true,
	      ...options
	    };

	    // Public
	    this.color = this.#options.color;

	    // It's important that these use the public setters.
	    this.spinner = this.#options.spinner;
	    this.#initialInterval = this.#options.interval;
	    this.#stream = this.#options.stream;
	    this.#isEnabled = typeof this.#options.isEnabled === 'boolean' ? this.#options.isEnabled : isInteractive$2({
	      stream: this.#stream
	    });
	    this.#isSilent = typeof this.#options.isSilent === 'boolean' ? this.#options.isSilent : false;

	    // Set *after* `this.#stream`.
	    // It's important that these use the public setters.
	    this.text = this.#options.text;
	    this.prefixText = this.#options.prefixText;
	    this.suffixText = this.#options.suffixText;
	    this.indent = this.#options.indent;
	    if (process$4.env.NODE_ENV === 'test') {
	      this._stream = this.#stream;
	      this._isEnabled = this.#isEnabled;
	      Object.defineProperty(this, '_linesToClear', {
	        get() {
	          return this.#linesToClear;
	        },
	        set(newValue) {
	          this.#linesToClear = newValue;
	        }
	      });
	      Object.defineProperty(this, '_frameIndex', {
	        get() {
	          return this.#frameIndex;
	        }
	      });
	      Object.defineProperty(this, '_lineCount', {
	        get() {
	          return this.#lineCount;
	        }
	      });
	    }
	  }
	  get indent() {
	    return this.#indent;
	  }
	  set indent(indent = 0) {
	    if (!(indent >= 0 && Number.isInteger(indent))) {
	      throw new Error('The `indent` option must be an integer from 0 and up');
	    }
	    this.#indent = indent;
	    this.#updateLineCount();
	  }
	  get interval() {
	    return this.#initialInterval ?? this.#spinner.interval ?? 100;
	  }
	  get spinner() {
	    return this.#spinner;
	  }
	  set spinner(spinner) {
	    this.#frameIndex = 0;
	    this.#initialInterval = undefined;
	    if (typeof spinner === 'object') {
	      if (spinner.frames === undefined) {
	        throw new Error('The given spinner must have a `frames` property');
	      }
	      this.#spinner = spinner;
	    } else if (!isUnicodeSupported$4()) {
	      this.#spinner = cliSpinners$2.line;
	    } else if (spinner === undefined) {
	      // Set default spinner
	      this.#spinner = cliSpinners$2.dots;
	    } else if (spinner !== 'default' && cliSpinners$2[spinner]) {
	      this.#spinner = cliSpinners$2[spinner];
	    } else {
	      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
	    }
	  }
	  get text() {
	    return this.#text;
	  }
	  set text(value = '') {
	    this.#text = value;
	    this.#updateLineCount();
	  }
	  get prefixText() {
	    return this.#prefixText;
	  }
	  set prefixText(value = '') {
	    this.#prefixText = value;
	    this.#updateLineCount();
	  }
	  get suffixText() {
	    return this.#suffixText;
	  }
	  set suffixText(value = '') {
	    this.#suffixText = value;
	    this.#updateLineCount();
	  }
	  get isSpinning() {
	    return this.#id !== undefined;
	  }
	  #getFullPrefixText(prefixText = this.#prefixText, postfix = ' ') {
	    if (typeof prefixText === 'string' && prefixText !== '') {
	      return prefixText + postfix;
	    }
	    if (typeof prefixText === 'function') {
	      return prefixText() + postfix;
	    }
	    return '';
	  }
	  #getFullSuffixText(suffixText = this.#suffixText, prefix = ' ') {
	    if (typeof suffixText === 'string' && suffixText !== '') {
	      return prefix + suffixText;
	    }
	    if (typeof suffixText === 'function') {
	      return prefix + suffixText();
	    }
	    return '';
	  }
	  #updateLineCount() {
	    const columns = this.#stream.columns ?? 80;
	    const fullPrefixText = this.#getFullPrefixText(this.#prefixText, '-');
	    const fullSuffixText = this.#getFullSuffixText(this.#suffixText, '-');
	    const fullText = ' '.repeat(this.#indent) + fullPrefixText + '--' + this.#text + '--' + fullSuffixText;
	    this.#lineCount = 0;
	    for (const line of stripAnsi$5(fullText).split('\n')) {
	      this.#lineCount += Math.max(1, Math.ceil(stringWidth$4(line, {
	        countAnsiEscapeCodes: true
	      }) / columns));
	    }
	  }
	  get isEnabled() {
	    return this.#isEnabled && !this.#isSilent;
	  }
	  set isEnabled(value) {
	    if (typeof value !== 'boolean') {
	      throw new TypeError('The `isEnabled` option must be a boolean');
	    }
	    this.#isEnabled = value;
	  }
	  get isSilent() {
	    return this.#isSilent;
	  }
	  set isSilent(value) {
	    if (typeof value !== 'boolean') {
	      throw new TypeError('The `isSilent` option must be a boolean');
	    }
	    this.#isSilent = value;
	  }
	  frame() {
	    const {
	      frames
	    } = this.#spinner;
	    let frame = frames[this.#frameIndex];
	    if (this.color) {
	      frame = chalk$3[this.color](frame);
	    }
	    this.#frameIndex = ++this.#frameIndex % frames.length;
	    const fullPrefixText = typeof this.#prefixText === 'string' && this.#prefixText !== '' ? this.#prefixText + ' ' : '';
	    const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
	    const fullSuffixText = typeof this.#suffixText === 'string' && this.#suffixText !== '' ? ' ' + this.#suffixText : '';
	    return fullPrefixText + frame + fullText + fullSuffixText;
	  }
	  clear() {
	    if (!this.#isEnabled || !this.#stream.isTTY) {
	      return this;
	    }
	    this.#stream.cursorTo(0);
	    for (let index = 0; index < this.#linesToClear; index++) {
	      if (index > 0) {
	        this.#stream.moveCursor(0, -1);
	      }
	      this.#stream.clearLine(1);
	    }
	    if (this.#indent || this.lastIndent !== this.#indent) {
	      this.#stream.cursorTo(this.#indent);
	    }
	    this.lastIndent = this.#indent;
	    this.#linesToClear = 0;
	    return this;
	  }
	  render() {
	    if (this.#isSilent) {
	      return this;
	    }
	    this.clear();
	    this.#stream.write(this.frame());
	    this.#linesToClear = this.#lineCount;
	    return this;
	  }
	  start(text) {
	    if (text) {
	      this.text = text;
	    }
	    if (this.#isSilent) {
	      return this;
	    }
	    if (!this.#isEnabled) {
	      if (this.text) {
	        this.#stream.write(`- ${this.text}\n`);
	      }
	      return this;
	    }
	    if (this.isSpinning) {
	      return this;
	    }
	    if (this.#options.hideCursor) {
	      cliCursor$3.hide(this.#stream);
	    }
	    if (this.#options.discardStdin && process$4.stdin.isTTY) {
	      this.#isDiscardingStdin = true;
	      stdinDiscarder$1.start();
	    }
	    this.render();
	    this.#id = setInterval(this.render.bind(this), this.interval);
	    return this;
	  }
	  stop() {
	    if (!this.#isEnabled) {
	      return this;
	    }
	    clearInterval(this.#id);
	    this.#id = undefined;
	    this.#frameIndex = 0;
	    this.clear();
	    if (this.#options.hideCursor) {
	      cliCursor$3.show(this.#stream);
	    }
	    if (this.#options.discardStdin && process$4.stdin.isTTY && this.#isDiscardingStdin) {
	      stdinDiscarder$1.stop();
	      this.#isDiscardingStdin = false;
	    }
	    return this;
	  }
	  succeed(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols$2.success,
	      text
	    });
	  }
	  fail(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols$2.error,
	      text
	    });
	  }
	  warn(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols$2.warning,
	      text
	    });
	  }
	  info(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols$2.info,
	      text
	    });
	  }
	  stopAndPersist(options = {}) {
	    if (this.#isSilent) {
	      return this;
	    }
	    const prefixText = options.prefixText ?? this.#prefixText;
	    const fullPrefixText = this.#getFullPrefixText(prefixText, ' ');
	    const symbolText = options.symbol ?? ' ';
	    const text = options.text ?? this.text;
	    const fullText = typeof text === 'string' ? ' ' + text : '';
	    const suffixText = options.suffixText ?? this.#suffixText;
	    const fullSuffixText = this.#getFullSuffixText(suffixText, ' ');
	    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + '\n';
	    this.stop();
	    this.#stream.write(textToWrite);
	    return this;
	  }
	};
	function ora$2(options) {
	  return new Ora$1(options);
	}

	class Loading {
	  constructor() {
	    this.load = null;
	  }
	  start(options) {
	    if (this.load) {
	      this.load = null;
	    }
	    this.load = ora$2(options = {
	      ...options,
	      spinner: "dots"
	    }).start();
	  }
	  stop() {
	    this.load && this.load.stop();
	  }
	  clear() {
	    this.load && this.load.clear();
	  }
	  warn(text) {
	    this.load && this.load.warn(text);
	  }
	  info(text) {
	    this.load && this.load.info(text);
	  }
	  succeed(text) {
	    this.load && this.load.succeed(text);
	  }
	  fail(text) {
	    this.load && this.load.fail(text);
	  }
	}
	const loading = new Loading();

	// import { spawn } from "child_process";
	const {
	  spawn
	} = require("node:child_process");
	const commandSpawn = (...args) => {
	  return new Promise((resolve, reject) => {
	    const childProcess = spawn(...args);
	    // 
	    // childProcess.stdout?.pipe(process.stdout)
	    // 
	    // childProcess.stderr?.pipe(process.stderr)
	    childProcess.on("close", () => {
	      resolve();
	    });
	    childProcess.on("error", err => {
	      reject(err);
	    });
	  });
	};

	var fs$k = {};

	var universalify$1 = {};

	universalify$1.fromCallback = function (fn) {
	  return Object.defineProperty(function (...args) {
	    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);else {
	      return new Promise((resolve, reject) => {
	        args.push((err, res) => err != null ? reject(err) : resolve(res));
	        fn.apply(this, args);
	      });
	    }
	  }, 'name', {
	    value: fn.name
	  });
	};
	universalify$1.fromPromise = function (fn) {
	  return Object.defineProperty(function (...args) {
	    const cb = args[args.length - 1];
	    if (typeof cb !== 'function') return fn.apply(this, args);else {
	      args.pop();
	      fn.apply(this, args).then(r => cb(null, r), cb);
	    }
	  }, 'name', {
	    value: fn.name
	  });
	};

	var RTLD_LAZY = 1;
	var RTLD_NOW = 2;
	var RTLD_GLOBAL = 8;
	var RTLD_LOCAL = 4;
	var E2BIG = 7;
	var EACCES = 13;
	var EADDRINUSE = 48;
	var EADDRNOTAVAIL = 49;
	var EAFNOSUPPORT = 47;
	var EAGAIN = 35;
	var EALREADY = 37;
	var EBADF$1 = 9;
	var EBADMSG = 94;
	var EBUSY = 16;
	var ECANCELED = 89;
	var ECHILD = 10;
	var ECONNABORTED = 53;
	var ECONNREFUSED = 61;
	var ECONNRESET = 54;
	var EDEADLK = 11;
	var EDESTADDRREQ = 39;
	var EDOM = 33;
	var EDQUOT = 69;
	var EEXIST = 17;
	var EFAULT = 14;
	var EFBIG = 27;
	var EHOSTUNREACH = 65;
	var EIDRM = 90;
	var EILSEQ = 92;
	var EINPROGRESS = 36;
	var EINTR = 4;
	var EINVAL = 22;
	var EIO = 5;
	var EISCONN = 56;
	var EISDIR = 21;
	var ELOOP = 62;
	var EMFILE = 24;
	var EMLINK = 31;
	var EMSGSIZE = 40;
	var EMULTIHOP = 95;
	var ENAMETOOLONG = 63;
	var ENETDOWN = 50;
	var ENETRESET = 52;
	var ENETUNREACH = 51;
	var ENFILE = 23;
	var ENOBUFS = 55;
	var ENODATA = 96;
	var ENODEV = 19;
	var ENOENT$1 = 2;
	var ENOEXEC = 8;
	var ENOLCK = 77;
	var ENOLINK = 97;
	var ENOMEM = 12;
	var ENOMSG = 91;
	var ENOPROTOOPT = 42;
	var ENOSPC = 28;
	var ENOSR = 98;
	var ENOSTR = 99;
	var ENOSYS = 78;
	var ENOTCONN = 57;
	var ENOTDIR = 20;
	var ENOTEMPTY = 66;
	var ENOTSOCK = 38;
	var ENOTSUP = 45;
	var ENOTTY = 25;
	var ENXIO = 6;
	var EOPNOTSUPP = 102;
	var EOVERFLOW = 84;
	var EPERM = 1;
	var EPIPE = 32;
	var EPROTO = 100;
	var EPROTONOSUPPORT = 43;
	var EPROTOTYPE = 41;
	var ERANGE = 34;
	var EROFS = 30;
	var ESPIPE = 29;
	var ESRCH = 3;
	var ESTALE = 70;
	var ETIME = 101;
	var ETIMEDOUT = 60;
	var ETXTBSY = 26;
	var EWOULDBLOCK = 35;
	var EXDEV = 18;
	var PRIORITY_LOW = 19;
	var PRIORITY_BELOW_NORMAL = 10;
	var PRIORITY_NORMAL = 0;
	var PRIORITY_ABOVE_NORMAL = -7;
	var PRIORITY_HIGH = -14;
	var PRIORITY_HIGHEST = -20;
	var SIGHUP = 1;
	var SIGINT = 2;
	var SIGQUIT = 3;
	var SIGILL = 4;
	var SIGTRAP = 5;
	var SIGABRT = 6;
	var SIGIOT = 6;
	var SIGBUS = 10;
	var SIGFPE = 8;
	var SIGKILL = 9;
	var SIGUSR1 = 30;
	var SIGSEGV = 11;
	var SIGUSR2 = 31;
	var SIGPIPE = 13;
	var SIGALRM = 14;
	var SIGTERM = 15;
	var SIGCHLD = 20;
	var SIGCONT = 19;
	var SIGSTOP = 17;
	var SIGTSTP = 18;
	var SIGTTIN = 21;
	var SIGTTOU = 22;
	var SIGURG = 16;
	var SIGXCPU = 24;
	var SIGXFSZ = 25;
	var SIGVTALRM = 26;
	var SIGPROF = 27;
	var SIGWINCH = 28;
	var SIGIO = 23;
	var SIGINFO = 29;
	var SIGSYS = 12;
	var UV_FS_SYMLINK_DIR = 1;
	var UV_FS_SYMLINK_JUNCTION = 2;
	var O_RDONLY = 0;
	var O_WRONLY = 1;
	var O_RDWR = 2;
	var UV_DIRENT_UNKNOWN = 0;
	var UV_DIRENT_FILE = 1;
	var UV_DIRENT_DIR = 2;
	var UV_DIRENT_LINK = 3;
	var UV_DIRENT_FIFO = 4;
	var UV_DIRENT_SOCKET = 5;
	var UV_DIRENT_CHAR = 6;
	var UV_DIRENT_BLOCK = 7;
	var S_IFMT = 61440;
	var S_IFREG = 32768;
	var S_IFDIR = 16384;
	var S_IFCHR = 8192;
	var S_IFBLK = 24576;
	var S_IFIFO = 4096;
	var S_IFLNK = 40960;
	var S_IFSOCK = 49152;
	var O_CREAT = 512;
	var O_EXCL = 2048;
	var UV_FS_O_FILEMAP = 0;
	var O_NOCTTY = 131072;
	var O_TRUNC = 1024;
	var O_APPEND = 8;
	var O_DIRECTORY = 1048576;
	var O_NOFOLLOW = 256;
	var O_SYNC = 128;
	var O_DSYNC = 4194304;
	var O_SYMLINK = 2097152;
	var O_NONBLOCK = 4;
	var S_IRWXU = 448;
	var S_IRUSR = 256;
	var S_IWUSR = 128;
	var S_IXUSR = 64;
	var S_IRWXG = 56;
	var S_IRGRP = 32;
	var S_IWGRP = 16;
	var S_IXGRP = 8;
	var S_IRWXO = 7;
	var S_IROTH = 4;
	var S_IWOTH = 2;
	var S_IXOTH = 1;
	var F_OK = 0;
	var R_OK = 4;
	var W_OK = 2;
	var X_OK = 1;
	var UV_FS_COPYFILE_EXCL = 1;
	var COPYFILE_EXCL = 1;
	var UV_FS_COPYFILE_FICLONE = 2;
	var COPYFILE_FICLONE = 2;
	var UV_FS_COPYFILE_FICLONE_FORCE = 4;
	var COPYFILE_FICLONE_FORCE = 4;
	var OPENSSL_VERSION_NUMBER = 805306528;
	var SSL_OP_ALL = 2147485776;
	var SSL_OP_ALLOW_NO_DHE_KEX = 1024;
	var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
	var SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
	var SSL_OP_CISCO_ANYCONNECT = 32768;
	var SSL_OP_COOKIE_EXCHANGE = 8192;
	var SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
	var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
	var SSL_OP_EPHEMERAL_RSA = 0;
	var SSL_OP_LEGACY_SERVER_CONNECT = 4;
	var SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 0;
	var SSL_OP_MICROSOFT_SESS_ID_BUG = 0;
	var SSL_OP_MSIE_SSLV2_RSA_PADDING = 0;
	var SSL_OP_NETSCAPE_CA_DN_BUG = 0;
	var SSL_OP_NETSCAPE_CHALLENGE_BUG = 0;
	var SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = 0;
	var SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 0;
	var SSL_OP_NO_COMPRESSION = 131072;
	var SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
	var SSL_OP_NO_QUERY_MTU = 4096;
	var SSL_OP_NO_RENEGOTIATION = 1073741824;
	var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
	var SSL_OP_NO_SSLv2 = 0;
	var SSL_OP_NO_SSLv3 = 33554432;
	var SSL_OP_NO_TICKET = 16384;
	var SSL_OP_NO_TLSv1 = 67108864;
	var SSL_OP_NO_TLSv1_1 = 268435456;
	var SSL_OP_NO_TLSv1_2 = 134217728;
	var SSL_OP_NO_TLSv1_3 = 536870912;
	var SSL_OP_PKCS1_CHECK_1 = 0;
	var SSL_OP_PKCS1_CHECK_2 = 0;
	var SSL_OP_PRIORITIZE_CHACHA = 2097152;
	var SSL_OP_SINGLE_DH_USE = 0;
	var SSL_OP_SINGLE_ECDH_USE = 0;
	var SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 0;
	var SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 0;
	var SSL_OP_TLS_BLOCK_PADDING_BUG = 0;
	var SSL_OP_TLS_D5_BUG = 0;
	var SSL_OP_TLS_ROLLBACK_BUG = 8388608;
	var ENGINE_METHOD_RSA = 1;
	var ENGINE_METHOD_DSA = 2;
	var ENGINE_METHOD_DH = 4;
	var ENGINE_METHOD_RAND = 8;
	var ENGINE_METHOD_EC = 2048;
	var ENGINE_METHOD_CIPHERS = 64;
	var ENGINE_METHOD_DIGESTS = 128;
	var ENGINE_METHOD_PKEY_METHS = 512;
	var ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
	var ENGINE_METHOD_ALL = 65535;
	var ENGINE_METHOD_NONE = 0;
	var DH_CHECK_P_NOT_SAFE_PRIME = 2;
	var DH_CHECK_P_NOT_PRIME = 1;
	var DH_UNABLE_TO_CHECK_GENERATOR = 4;
	var DH_NOT_SUITABLE_GENERATOR = 8;
	var ALPN_ENABLED = 1;
	var RSA_PKCS1_PADDING = 1;
	var RSA_NO_PADDING = 3;
	var RSA_PKCS1_OAEP_PADDING = 4;
	var RSA_X931_PADDING = 5;
	var RSA_PKCS1_PSS_PADDING = 6;
	var RSA_PSS_SALTLEN_DIGEST = -1;
	var RSA_PSS_SALTLEN_MAX_SIGN = -2;
	var RSA_PSS_SALTLEN_AUTO = -2;
	var defaultCoreCipherList = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA";
	var TLS1_VERSION = 769;
	var TLS1_1_VERSION = 770;
	var TLS1_2_VERSION = 771;
	var TLS1_3_VERSION = 772;
	var POINT_CONVERSION_COMPRESSED = 2;
	var POINT_CONVERSION_UNCOMPRESSED = 4;
	var POINT_CONVERSION_HYBRID = 6;
	var defaultCipherList = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA";
	var _polyfillNode_constants = {
	  RTLD_LAZY: RTLD_LAZY,
	  RTLD_NOW: RTLD_NOW,
	  RTLD_GLOBAL: RTLD_GLOBAL,
	  RTLD_LOCAL: RTLD_LOCAL,
	  E2BIG: E2BIG,
	  EACCES: EACCES,
	  EADDRINUSE: EADDRINUSE,
	  EADDRNOTAVAIL: EADDRNOTAVAIL,
	  EAFNOSUPPORT: EAFNOSUPPORT,
	  EAGAIN: EAGAIN,
	  EALREADY: EALREADY,
	  EBADF: EBADF$1,
	  EBADMSG: EBADMSG,
	  EBUSY: EBUSY,
	  ECANCELED: ECANCELED,
	  ECHILD: ECHILD,
	  ECONNABORTED: ECONNABORTED,
	  ECONNREFUSED: ECONNREFUSED,
	  ECONNRESET: ECONNRESET,
	  EDEADLK: EDEADLK,
	  EDESTADDRREQ: EDESTADDRREQ,
	  EDOM: EDOM,
	  EDQUOT: EDQUOT,
	  EEXIST: EEXIST,
	  EFAULT: EFAULT,
	  EFBIG: EFBIG,
	  EHOSTUNREACH: EHOSTUNREACH,
	  EIDRM: EIDRM,
	  EILSEQ: EILSEQ,
	  EINPROGRESS: EINPROGRESS,
	  EINTR: EINTR,
	  EINVAL: EINVAL,
	  EIO: EIO,
	  EISCONN: EISCONN,
	  EISDIR: EISDIR,
	  ELOOP: ELOOP,
	  EMFILE: EMFILE,
	  EMLINK: EMLINK,
	  EMSGSIZE: EMSGSIZE,
	  EMULTIHOP: EMULTIHOP,
	  ENAMETOOLONG: ENAMETOOLONG,
	  ENETDOWN: ENETDOWN,
	  ENETRESET: ENETRESET,
	  ENETUNREACH: ENETUNREACH,
	  ENFILE: ENFILE,
	  ENOBUFS: ENOBUFS,
	  ENODATA: ENODATA,
	  ENODEV: ENODEV,
	  ENOENT: ENOENT$1,
	  ENOEXEC: ENOEXEC,
	  ENOLCK: ENOLCK,
	  ENOLINK: ENOLINK,
	  ENOMEM: ENOMEM,
	  ENOMSG: ENOMSG,
	  ENOPROTOOPT: ENOPROTOOPT,
	  ENOSPC: ENOSPC,
	  ENOSR: ENOSR,
	  ENOSTR: ENOSTR,
	  ENOSYS: ENOSYS,
	  ENOTCONN: ENOTCONN,
	  ENOTDIR: ENOTDIR,
	  ENOTEMPTY: ENOTEMPTY,
	  ENOTSOCK: ENOTSOCK,
	  ENOTSUP: ENOTSUP,
	  ENOTTY: ENOTTY,
	  ENXIO: ENXIO,
	  EOPNOTSUPP: EOPNOTSUPP,
	  EOVERFLOW: EOVERFLOW,
	  EPERM: EPERM,
	  EPIPE: EPIPE,
	  EPROTO: EPROTO,
	  EPROTONOSUPPORT: EPROTONOSUPPORT,
	  EPROTOTYPE: EPROTOTYPE,
	  ERANGE: ERANGE,
	  EROFS: EROFS,
	  ESPIPE: ESPIPE,
	  ESRCH: ESRCH,
	  ESTALE: ESTALE,
	  ETIME: ETIME,
	  ETIMEDOUT: ETIMEDOUT,
	  ETXTBSY: ETXTBSY,
	  EWOULDBLOCK: EWOULDBLOCK,
	  EXDEV: EXDEV,
	  PRIORITY_LOW: PRIORITY_LOW,
	  PRIORITY_BELOW_NORMAL: PRIORITY_BELOW_NORMAL,
	  PRIORITY_NORMAL: PRIORITY_NORMAL,
	  PRIORITY_ABOVE_NORMAL: PRIORITY_ABOVE_NORMAL,
	  PRIORITY_HIGH: PRIORITY_HIGH,
	  PRIORITY_HIGHEST: PRIORITY_HIGHEST,
	  SIGHUP: SIGHUP,
	  SIGINT: SIGINT,
	  SIGQUIT: SIGQUIT,
	  SIGILL: SIGILL,
	  SIGTRAP: SIGTRAP,
	  SIGABRT: SIGABRT,
	  SIGIOT: SIGIOT,
	  SIGBUS: SIGBUS,
	  SIGFPE: SIGFPE,
	  SIGKILL: SIGKILL,
	  SIGUSR1: SIGUSR1,
	  SIGSEGV: SIGSEGV,
	  SIGUSR2: SIGUSR2,
	  SIGPIPE: SIGPIPE,
	  SIGALRM: SIGALRM,
	  SIGTERM: SIGTERM,
	  SIGCHLD: SIGCHLD,
	  SIGCONT: SIGCONT,
	  SIGSTOP: SIGSTOP,
	  SIGTSTP: SIGTSTP,
	  SIGTTIN: SIGTTIN,
	  SIGTTOU: SIGTTOU,
	  SIGURG: SIGURG,
	  SIGXCPU: SIGXCPU,
	  SIGXFSZ: SIGXFSZ,
	  SIGVTALRM: SIGVTALRM,
	  SIGPROF: SIGPROF,
	  SIGWINCH: SIGWINCH,
	  SIGIO: SIGIO,
	  SIGINFO: SIGINFO,
	  SIGSYS: SIGSYS,
	  UV_FS_SYMLINK_DIR: UV_FS_SYMLINK_DIR,
	  UV_FS_SYMLINK_JUNCTION: UV_FS_SYMLINK_JUNCTION,
	  O_RDONLY: O_RDONLY,
	  O_WRONLY: O_WRONLY,
	  O_RDWR: O_RDWR,
	  UV_DIRENT_UNKNOWN: UV_DIRENT_UNKNOWN,
	  UV_DIRENT_FILE: UV_DIRENT_FILE,
	  UV_DIRENT_DIR: UV_DIRENT_DIR,
	  UV_DIRENT_LINK: UV_DIRENT_LINK,
	  UV_DIRENT_FIFO: UV_DIRENT_FIFO,
	  UV_DIRENT_SOCKET: UV_DIRENT_SOCKET,
	  UV_DIRENT_CHAR: UV_DIRENT_CHAR,
	  UV_DIRENT_BLOCK: UV_DIRENT_BLOCK,
	  S_IFMT: S_IFMT,
	  S_IFREG: S_IFREG,
	  S_IFDIR: S_IFDIR,
	  S_IFCHR: S_IFCHR,
	  S_IFBLK: S_IFBLK,
	  S_IFIFO: S_IFIFO,
	  S_IFLNK: S_IFLNK,
	  S_IFSOCK: S_IFSOCK,
	  O_CREAT: O_CREAT,
	  O_EXCL: O_EXCL,
	  UV_FS_O_FILEMAP: UV_FS_O_FILEMAP,
	  O_NOCTTY: O_NOCTTY,
	  O_TRUNC: O_TRUNC,
	  O_APPEND: O_APPEND,
	  O_DIRECTORY: O_DIRECTORY,
	  O_NOFOLLOW: O_NOFOLLOW,
	  O_SYNC: O_SYNC,
	  O_DSYNC: O_DSYNC,
	  O_SYMLINK: O_SYMLINK,
	  O_NONBLOCK: O_NONBLOCK,
	  S_IRWXU: S_IRWXU,
	  S_IRUSR: S_IRUSR,
	  S_IWUSR: S_IWUSR,
	  S_IXUSR: S_IXUSR,
	  S_IRWXG: S_IRWXG,
	  S_IRGRP: S_IRGRP,
	  S_IWGRP: S_IWGRP,
	  S_IXGRP: S_IXGRP,
	  S_IRWXO: S_IRWXO,
	  S_IROTH: S_IROTH,
	  S_IWOTH: S_IWOTH,
	  S_IXOTH: S_IXOTH,
	  F_OK: F_OK,
	  R_OK: R_OK,
	  W_OK: W_OK,
	  X_OK: X_OK,
	  UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
	  COPYFILE_EXCL: COPYFILE_EXCL,
	  UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
	  COPYFILE_FICLONE: COPYFILE_FICLONE,
	  UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE,
	  COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE,
	  OPENSSL_VERSION_NUMBER: OPENSSL_VERSION_NUMBER,
	  SSL_OP_ALL: SSL_OP_ALL,
	  SSL_OP_ALLOW_NO_DHE_KEX: SSL_OP_ALLOW_NO_DHE_KEX,
	  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
	  SSL_OP_CIPHER_SERVER_PREFERENCE: SSL_OP_CIPHER_SERVER_PREFERENCE,
	  SSL_OP_CISCO_ANYCONNECT: SSL_OP_CISCO_ANYCONNECT,
	  SSL_OP_COOKIE_EXCHANGE: SSL_OP_COOKIE_EXCHANGE,
	  SSL_OP_CRYPTOPRO_TLSEXT_BUG: SSL_OP_CRYPTOPRO_TLSEXT_BUG,
	  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
	  SSL_OP_EPHEMERAL_RSA: SSL_OP_EPHEMERAL_RSA,
	  SSL_OP_LEGACY_SERVER_CONNECT: SSL_OP_LEGACY_SERVER_CONNECT,
	  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER,
	  SSL_OP_MICROSOFT_SESS_ID_BUG: SSL_OP_MICROSOFT_SESS_ID_BUG,
	  SSL_OP_MSIE_SSLV2_RSA_PADDING: SSL_OP_MSIE_SSLV2_RSA_PADDING,
	  SSL_OP_NETSCAPE_CA_DN_BUG: SSL_OP_NETSCAPE_CA_DN_BUG,
	  SSL_OP_NETSCAPE_CHALLENGE_BUG: SSL_OP_NETSCAPE_CHALLENGE_BUG,
	  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG,
	  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG,
	  SSL_OP_NO_COMPRESSION: SSL_OP_NO_COMPRESSION,
	  SSL_OP_NO_ENCRYPT_THEN_MAC: SSL_OP_NO_ENCRYPT_THEN_MAC,
	  SSL_OP_NO_QUERY_MTU: SSL_OP_NO_QUERY_MTU,
	  SSL_OP_NO_RENEGOTIATION: SSL_OP_NO_RENEGOTIATION,
	  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
	  SSL_OP_NO_SSLv2: SSL_OP_NO_SSLv2,
	  SSL_OP_NO_SSLv3: SSL_OP_NO_SSLv3,
	  SSL_OP_NO_TICKET: SSL_OP_NO_TICKET,
	  SSL_OP_NO_TLSv1: SSL_OP_NO_TLSv1,
	  SSL_OP_NO_TLSv1_1: SSL_OP_NO_TLSv1_1,
	  SSL_OP_NO_TLSv1_2: SSL_OP_NO_TLSv1_2,
	  SSL_OP_NO_TLSv1_3: SSL_OP_NO_TLSv1_3,
	  SSL_OP_PKCS1_CHECK_1: SSL_OP_PKCS1_CHECK_1,
	  SSL_OP_PKCS1_CHECK_2: SSL_OP_PKCS1_CHECK_2,
	  SSL_OP_PRIORITIZE_CHACHA: SSL_OP_PRIORITIZE_CHACHA,
	  SSL_OP_SINGLE_DH_USE: SSL_OP_SINGLE_DH_USE,
	  SSL_OP_SINGLE_ECDH_USE: SSL_OP_SINGLE_ECDH_USE,
	  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: SSL_OP_SSLEAY_080_CLIENT_DH_BUG,
	  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG,
	  SSL_OP_TLS_BLOCK_PADDING_BUG: SSL_OP_TLS_BLOCK_PADDING_BUG,
	  SSL_OP_TLS_D5_BUG: SSL_OP_TLS_D5_BUG,
	  SSL_OP_TLS_ROLLBACK_BUG: SSL_OP_TLS_ROLLBACK_BUG,
	  ENGINE_METHOD_RSA: ENGINE_METHOD_RSA,
	  ENGINE_METHOD_DSA: ENGINE_METHOD_DSA,
	  ENGINE_METHOD_DH: ENGINE_METHOD_DH,
	  ENGINE_METHOD_RAND: ENGINE_METHOD_RAND,
	  ENGINE_METHOD_EC: ENGINE_METHOD_EC,
	  ENGINE_METHOD_CIPHERS: ENGINE_METHOD_CIPHERS,
	  ENGINE_METHOD_DIGESTS: ENGINE_METHOD_DIGESTS,
	  ENGINE_METHOD_PKEY_METHS: ENGINE_METHOD_PKEY_METHS,
	  ENGINE_METHOD_PKEY_ASN1_METHS: ENGINE_METHOD_PKEY_ASN1_METHS,
	  ENGINE_METHOD_ALL: ENGINE_METHOD_ALL,
	  ENGINE_METHOD_NONE: ENGINE_METHOD_NONE,
	  DH_CHECK_P_NOT_SAFE_PRIME: DH_CHECK_P_NOT_SAFE_PRIME,
	  DH_CHECK_P_NOT_PRIME: DH_CHECK_P_NOT_PRIME,
	  DH_UNABLE_TO_CHECK_GENERATOR: DH_UNABLE_TO_CHECK_GENERATOR,
	  DH_NOT_SUITABLE_GENERATOR: DH_NOT_SUITABLE_GENERATOR,
	  ALPN_ENABLED: ALPN_ENABLED,
	  RSA_PKCS1_PADDING: RSA_PKCS1_PADDING,
	  RSA_NO_PADDING: RSA_NO_PADDING,
	  RSA_PKCS1_OAEP_PADDING: RSA_PKCS1_OAEP_PADDING,
	  RSA_X931_PADDING: RSA_X931_PADDING,
	  RSA_PKCS1_PSS_PADDING: RSA_PKCS1_PSS_PADDING,
	  RSA_PSS_SALTLEN_DIGEST: RSA_PSS_SALTLEN_DIGEST,
	  RSA_PSS_SALTLEN_MAX_SIGN: RSA_PSS_SALTLEN_MAX_SIGN,
	  RSA_PSS_SALTLEN_AUTO: RSA_PSS_SALTLEN_AUTO,
	  defaultCoreCipherList: defaultCoreCipherList,
	  TLS1_VERSION: TLS1_VERSION,
	  TLS1_1_VERSION: TLS1_1_VERSION,
	  TLS1_2_VERSION: TLS1_2_VERSION,
	  TLS1_3_VERSION: TLS1_3_VERSION,
	  POINT_CONVERSION_COMPRESSED: POINT_CONVERSION_COMPRESSED,
	  POINT_CONVERSION_UNCOMPRESSED: POINT_CONVERSION_UNCOMPRESSED,
	  POINT_CONVERSION_HYBRID: POINT_CONVERSION_HYBRID,
	  defaultCipherList: defaultCipherList
	};

	var _polyfillNode_constants$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ALPN_ENABLED: ALPN_ENABLED,
		COPYFILE_EXCL: COPYFILE_EXCL,
		COPYFILE_FICLONE: COPYFILE_FICLONE,
		COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE,
		DH_CHECK_P_NOT_PRIME: DH_CHECK_P_NOT_PRIME,
		DH_CHECK_P_NOT_SAFE_PRIME: DH_CHECK_P_NOT_SAFE_PRIME,
		DH_NOT_SUITABLE_GENERATOR: DH_NOT_SUITABLE_GENERATOR,
		DH_UNABLE_TO_CHECK_GENERATOR: DH_UNABLE_TO_CHECK_GENERATOR,
		E2BIG: E2BIG,
		EACCES: EACCES,
		EADDRINUSE: EADDRINUSE,
		EADDRNOTAVAIL: EADDRNOTAVAIL,
		EAFNOSUPPORT: EAFNOSUPPORT,
		EAGAIN: EAGAIN,
		EALREADY: EALREADY,
		EBADF: EBADF$1,
		EBADMSG: EBADMSG,
		EBUSY: EBUSY,
		ECANCELED: ECANCELED,
		ECHILD: ECHILD,
		ECONNABORTED: ECONNABORTED,
		ECONNREFUSED: ECONNREFUSED,
		ECONNRESET: ECONNRESET,
		EDEADLK: EDEADLK,
		EDESTADDRREQ: EDESTADDRREQ,
		EDOM: EDOM,
		EDQUOT: EDQUOT,
		EEXIST: EEXIST,
		EFAULT: EFAULT,
		EFBIG: EFBIG,
		EHOSTUNREACH: EHOSTUNREACH,
		EIDRM: EIDRM,
		EILSEQ: EILSEQ,
		EINPROGRESS: EINPROGRESS,
		EINTR: EINTR,
		EINVAL: EINVAL,
		EIO: EIO,
		EISCONN: EISCONN,
		EISDIR: EISDIR,
		ELOOP: ELOOP,
		EMFILE: EMFILE,
		EMLINK: EMLINK,
		EMSGSIZE: EMSGSIZE,
		EMULTIHOP: EMULTIHOP,
		ENAMETOOLONG: ENAMETOOLONG,
		ENETDOWN: ENETDOWN,
		ENETRESET: ENETRESET,
		ENETUNREACH: ENETUNREACH,
		ENFILE: ENFILE,
		ENGINE_METHOD_ALL: ENGINE_METHOD_ALL,
		ENGINE_METHOD_CIPHERS: ENGINE_METHOD_CIPHERS,
		ENGINE_METHOD_DH: ENGINE_METHOD_DH,
		ENGINE_METHOD_DIGESTS: ENGINE_METHOD_DIGESTS,
		ENGINE_METHOD_DSA: ENGINE_METHOD_DSA,
		ENGINE_METHOD_EC: ENGINE_METHOD_EC,
		ENGINE_METHOD_NONE: ENGINE_METHOD_NONE,
		ENGINE_METHOD_PKEY_ASN1_METHS: ENGINE_METHOD_PKEY_ASN1_METHS,
		ENGINE_METHOD_PKEY_METHS: ENGINE_METHOD_PKEY_METHS,
		ENGINE_METHOD_RAND: ENGINE_METHOD_RAND,
		ENGINE_METHOD_RSA: ENGINE_METHOD_RSA,
		ENOBUFS: ENOBUFS,
		ENODATA: ENODATA,
		ENODEV: ENODEV,
		ENOENT: ENOENT$1,
		ENOEXEC: ENOEXEC,
		ENOLCK: ENOLCK,
		ENOLINK: ENOLINK,
		ENOMEM: ENOMEM,
		ENOMSG: ENOMSG,
		ENOPROTOOPT: ENOPROTOOPT,
		ENOSPC: ENOSPC,
		ENOSR: ENOSR,
		ENOSTR: ENOSTR,
		ENOSYS: ENOSYS,
		ENOTCONN: ENOTCONN,
		ENOTDIR: ENOTDIR,
		ENOTEMPTY: ENOTEMPTY,
		ENOTSOCK: ENOTSOCK,
		ENOTSUP: ENOTSUP,
		ENOTTY: ENOTTY,
		ENXIO: ENXIO,
		EOPNOTSUPP: EOPNOTSUPP,
		EOVERFLOW: EOVERFLOW,
		EPERM: EPERM,
		EPIPE: EPIPE,
		EPROTO: EPROTO,
		EPROTONOSUPPORT: EPROTONOSUPPORT,
		EPROTOTYPE: EPROTOTYPE,
		ERANGE: ERANGE,
		EROFS: EROFS,
		ESPIPE: ESPIPE,
		ESRCH: ESRCH,
		ESTALE: ESTALE,
		ETIME: ETIME,
		ETIMEDOUT: ETIMEDOUT,
		ETXTBSY: ETXTBSY,
		EWOULDBLOCK: EWOULDBLOCK,
		EXDEV: EXDEV,
		F_OK: F_OK,
		OPENSSL_VERSION_NUMBER: OPENSSL_VERSION_NUMBER,
		O_APPEND: O_APPEND,
		O_CREAT: O_CREAT,
		O_DIRECTORY: O_DIRECTORY,
		O_DSYNC: O_DSYNC,
		O_EXCL: O_EXCL,
		O_NOCTTY: O_NOCTTY,
		O_NOFOLLOW: O_NOFOLLOW,
		O_NONBLOCK: O_NONBLOCK,
		O_RDONLY: O_RDONLY,
		O_RDWR: O_RDWR,
		O_SYMLINK: O_SYMLINK,
		O_SYNC: O_SYNC,
		O_TRUNC: O_TRUNC,
		O_WRONLY: O_WRONLY,
		POINT_CONVERSION_COMPRESSED: POINT_CONVERSION_COMPRESSED,
		POINT_CONVERSION_HYBRID: POINT_CONVERSION_HYBRID,
		POINT_CONVERSION_UNCOMPRESSED: POINT_CONVERSION_UNCOMPRESSED,
		PRIORITY_ABOVE_NORMAL: PRIORITY_ABOVE_NORMAL,
		PRIORITY_BELOW_NORMAL: PRIORITY_BELOW_NORMAL,
		PRIORITY_HIGH: PRIORITY_HIGH,
		PRIORITY_HIGHEST: PRIORITY_HIGHEST,
		PRIORITY_LOW: PRIORITY_LOW,
		PRIORITY_NORMAL: PRIORITY_NORMAL,
		RSA_NO_PADDING: RSA_NO_PADDING,
		RSA_PKCS1_OAEP_PADDING: RSA_PKCS1_OAEP_PADDING,
		RSA_PKCS1_PADDING: RSA_PKCS1_PADDING,
		RSA_PKCS1_PSS_PADDING: RSA_PKCS1_PSS_PADDING,
		RSA_PSS_SALTLEN_AUTO: RSA_PSS_SALTLEN_AUTO,
		RSA_PSS_SALTLEN_DIGEST: RSA_PSS_SALTLEN_DIGEST,
		RSA_PSS_SALTLEN_MAX_SIGN: RSA_PSS_SALTLEN_MAX_SIGN,
		RSA_X931_PADDING: RSA_X931_PADDING,
		RTLD_GLOBAL: RTLD_GLOBAL,
		RTLD_LAZY: RTLD_LAZY,
		RTLD_LOCAL: RTLD_LOCAL,
		RTLD_NOW: RTLD_NOW,
		R_OK: R_OK,
		SIGABRT: SIGABRT,
		SIGALRM: SIGALRM,
		SIGBUS: SIGBUS,
		SIGCHLD: SIGCHLD,
		SIGCONT: SIGCONT,
		SIGFPE: SIGFPE,
		SIGHUP: SIGHUP,
		SIGILL: SIGILL,
		SIGINFO: SIGINFO,
		SIGINT: SIGINT,
		SIGIO: SIGIO,
		SIGIOT: SIGIOT,
		SIGKILL: SIGKILL,
		SIGPIPE: SIGPIPE,
		SIGPROF: SIGPROF,
		SIGQUIT: SIGQUIT,
		SIGSEGV: SIGSEGV,
		SIGSTOP: SIGSTOP,
		SIGSYS: SIGSYS,
		SIGTERM: SIGTERM,
		SIGTRAP: SIGTRAP,
		SIGTSTP: SIGTSTP,
		SIGTTIN: SIGTTIN,
		SIGTTOU: SIGTTOU,
		SIGURG: SIGURG,
		SIGUSR1: SIGUSR1,
		SIGUSR2: SIGUSR2,
		SIGVTALRM: SIGVTALRM,
		SIGWINCH: SIGWINCH,
		SIGXCPU: SIGXCPU,
		SIGXFSZ: SIGXFSZ,
		SSL_OP_ALL: SSL_OP_ALL,
		SSL_OP_ALLOW_NO_DHE_KEX: SSL_OP_ALLOW_NO_DHE_KEX,
		SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
		SSL_OP_CIPHER_SERVER_PREFERENCE: SSL_OP_CIPHER_SERVER_PREFERENCE,
		SSL_OP_CISCO_ANYCONNECT: SSL_OP_CISCO_ANYCONNECT,
		SSL_OP_COOKIE_EXCHANGE: SSL_OP_COOKIE_EXCHANGE,
		SSL_OP_CRYPTOPRO_TLSEXT_BUG: SSL_OP_CRYPTOPRO_TLSEXT_BUG,
		SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
		SSL_OP_EPHEMERAL_RSA: SSL_OP_EPHEMERAL_RSA,
		SSL_OP_LEGACY_SERVER_CONNECT: SSL_OP_LEGACY_SERVER_CONNECT,
		SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER,
		SSL_OP_MICROSOFT_SESS_ID_BUG: SSL_OP_MICROSOFT_SESS_ID_BUG,
		SSL_OP_MSIE_SSLV2_RSA_PADDING: SSL_OP_MSIE_SSLV2_RSA_PADDING,
		SSL_OP_NETSCAPE_CA_DN_BUG: SSL_OP_NETSCAPE_CA_DN_BUG,
		SSL_OP_NETSCAPE_CHALLENGE_BUG: SSL_OP_NETSCAPE_CHALLENGE_BUG,
		SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG,
		SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG,
		SSL_OP_NO_COMPRESSION: SSL_OP_NO_COMPRESSION,
		SSL_OP_NO_ENCRYPT_THEN_MAC: SSL_OP_NO_ENCRYPT_THEN_MAC,
		SSL_OP_NO_QUERY_MTU: SSL_OP_NO_QUERY_MTU,
		SSL_OP_NO_RENEGOTIATION: SSL_OP_NO_RENEGOTIATION,
		SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
		SSL_OP_NO_SSLv2: SSL_OP_NO_SSLv2,
		SSL_OP_NO_SSLv3: SSL_OP_NO_SSLv3,
		SSL_OP_NO_TICKET: SSL_OP_NO_TICKET,
		SSL_OP_NO_TLSv1: SSL_OP_NO_TLSv1,
		SSL_OP_NO_TLSv1_1: SSL_OP_NO_TLSv1_1,
		SSL_OP_NO_TLSv1_2: SSL_OP_NO_TLSv1_2,
		SSL_OP_NO_TLSv1_3: SSL_OP_NO_TLSv1_3,
		SSL_OP_PKCS1_CHECK_1: SSL_OP_PKCS1_CHECK_1,
		SSL_OP_PKCS1_CHECK_2: SSL_OP_PKCS1_CHECK_2,
		SSL_OP_PRIORITIZE_CHACHA: SSL_OP_PRIORITIZE_CHACHA,
		SSL_OP_SINGLE_DH_USE: SSL_OP_SINGLE_DH_USE,
		SSL_OP_SINGLE_ECDH_USE: SSL_OP_SINGLE_ECDH_USE,
		SSL_OP_SSLEAY_080_CLIENT_DH_BUG: SSL_OP_SSLEAY_080_CLIENT_DH_BUG,
		SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG,
		SSL_OP_TLS_BLOCK_PADDING_BUG: SSL_OP_TLS_BLOCK_PADDING_BUG,
		SSL_OP_TLS_D5_BUG: SSL_OP_TLS_D5_BUG,
		SSL_OP_TLS_ROLLBACK_BUG: SSL_OP_TLS_ROLLBACK_BUG,
		S_IFBLK: S_IFBLK,
		S_IFCHR: S_IFCHR,
		S_IFDIR: S_IFDIR,
		S_IFIFO: S_IFIFO,
		S_IFLNK: S_IFLNK,
		S_IFMT: S_IFMT,
		S_IFREG: S_IFREG,
		S_IFSOCK: S_IFSOCK,
		S_IRGRP: S_IRGRP,
		S_IROTH: S_IROTH,
		S_IRUSR: S_IRUSR,
		S_IRWXG: S_IRWXG,
		S_IRWXO: S_IRWXO,
		S_IRWXU: S_IRWXU,
		S_IWGRP: S_IWGRP,
		S_IWOTH: S_IWOTH,
		S_IWUSR: S_IWUSR,
		S_IXGRP: S_IXGRP,
		S_IXOTH: S_IXOTH,
		S_IXUSR: S_IXUSR,
		TLS1_1_VERSION: TLS1_1_VERSION,
		TLS1_2_VERSION: TLS1_2_VERSION,
		TLS1_3_VERSION: TLS1_3_VERSION,
		TLS1_VERSION: TLS1_VERSION,
		UV_DIRENT_BLOCK: UV_DIRENT_BLOCK,
		UV_DIRENT_CHAR: UV_DIRENT_CHAR,
		UV_DIRENT_DIR: UV_DIRENT_DIR,
		UV_DIRENT_FIFO: UV_DIRENT_FIFO,
		UV_DIRENT_FILE: UV_DIRENT_FILE,
		UV_DIRENT_LINK: UV_DIRENT_LINK,
		UV_DIRENT_SOCKET: UV_DIRENT_SOCKET,
		UV_DIRENT_UNKNOWN: UV_DIRENT_UNKNOWN,
		UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
		UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
		UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE,
		UV_FS_O_FILEMAP: UV_FS_O_FILEMAP,
		UV_FS_SYMLINK_DIR: UV_FS_SYMLINK_DIR,
		UV_FS_SYMLINK_JUNCTION: UV_FS_SYMLINK_JUNCTION,
		W_OK: W_OK,
		X_OK: X_OK,
		default: _polyfillNode_constants,
		defaultCipherList: defaultCipherList,
		defaultCoreCipherList: defaultCoreCipherList
	});

	var require$$0$6 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_constants$1);

	var constants = require$$0$6;
	var origCwd = process.cwd;
	var cwd = null;
	var platform$1 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
	process.cwd = function () {
	  if (!cwd) cwd = origCwd.call(process);
	  return cwd;
	};
	try {
	  process.cwd();
	} catch (er) {}

	// This check is needed until node.js 12 is required
	if (typeof process.chdir === 'function') {
	  var chdir = process.chdir;
	  process.chdir = function (d) {
	    cwd = null;
	    chdir.call(process, d);
	  };
	  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
	}
	var polyfills$1 = patch$1;
	function patch$1(fs) {
	  // (re-)implement some things that are known busted or missing.

	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs);
	  }

	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs);
	  }

	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.

	  fs.chown = chownFix(fs.chown);
	  fs.fchown = chownFix(fs.fchown);
	  fs.lchown = chownFix(fs.lchown);
	  fs.chmod = chmodFix(fs.chmod);
	  fs.fchmod = chmodFix(fs.fchmod);
	  fs.lchmod = chmodFix(fs.lchmod);
	  fs.chownSync = chownFixSync(fs.chownSync);
	  fs.fchownSync = chownFixSync(fs.fchownSync);
	  fs.lchownSync = chownFixSync(fs.lchownSync);
	  fs.chmodSync = chmodFixSync(fs.chmodSync);
	  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
	  fs.lchmodSync = chmodFixSync(fs.lchmodSync);
	  fs.stat = statFix(fs.stat);
	  fs.fstat = statFix(fs.fstat);
	  fs.lstat = statFix(fs.lstat);
	  fs.statSync = statFixSync(fs.statSync);
	  fs.fstatSync = statFixSync(fs.fstatSync);
	  fs.lstatSync = statFixSync(fs.lstatSync);

	  // if lchmod/lchown do not exist, then make them no-ops
	  if (fs.chmod && !fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchmodSync = function () {};
	  }
	  if (fs.chown && !fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchownSync = function () {};
	  }

	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 60 seconds.

	  // Set the timeout this long because some Windows Anti-Virus, such as Parity
	  // bit9, may lock files for up to a minute, causing npm package install
	  // failures. Also, take care to yield the scheduler. Windows scheduling gives
	  // CPU to a busy looping process, which can cause the program causing the lock
	  // contention to be starved of CPU by node, so the contention doesn't resolve.
	  if (platform$1 === "win32") {
	    fs.rename = typeof fs.rename !== 'function' ? fs.rename : function (fs$rename) {
	      function rename(from, to, cb) {
	        var start = Date.now();
	        var backoff = 0;
	        fs$rename(from, to, function CB(er) {
	          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
	            setTimeout(function () {
	              fs.stat(to, function (stater, st) {
	                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
	              });
	            }, backoff);
	            if (backoff < 100) backoff += 10;
	            return;
	          }
	          if (cb) cb(er);
	        });
	      }
	      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
	      return rename;
	    }(fs.rename);
	  }

	  // if read() returns EAGAIN, then just try it again.
	  fs.read = typeof fs.read !== 'function' ? fs.read : function (fs$read) {
	    function read(fd, buffer, offset, length, position, callback_) {
	      var callback;
	      if (callback_ && typeof callback_ === 'function') {
	        var eagCounter = 0;
	        callback = function (er, _, __) {
	          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
	          }
	          callback_.apply(this, arguments);
	        };
	      }
	      return fs$read.call(fs, fd, buffer, offset, length, position, callback);
	    }

	    // This ensures `util.promisify` works as it does for native `fs.read`.
	    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
	    return read;
	  }(fs.read);
	  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function (fs$readSync) {
	    return function (fd, buffer, offset, length, position) {
	      var eagCounter = 0;
	      while (true) {
	        try {
	          return fs$readSync.call(fs, fd, buffer, offset, length, position);
	        } catch (er) {
	          if (er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            continue;
	          }
	          throw er;
	        }
	      }
	    };
	  }(fs.readSync);
	  function patchLchmod(fs) {
	    fs.lchmod = function (path, mode, callback) {
	      fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
	        if (err) {
	          if (callback) callback(err);
	          return;
	        }
	        // prefer to return the chmod error, if one occurs,
	        // but still try to close, and report closing errors if they occur.
	        fs.fchmod(fd, mode, function (err) {
	          fs.close(fd, function (err2) {
	            if (callback) callback(err || err2);
	          });
	        });
	      });
	    };
	    fs.lchmodSync = function (path, mode) {
	      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      var threw = true;
	      var ret;
	      try {
	        ret = fs.fchmodSync(fd, mode);
	        threw = false;
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd);
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd);
	        }
	      }
	      return ret;
	    };
	  }
	  function patchLutimes(fs) {
	    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
	      fs.lutimes = function (path, at, mt, cb) {
	        fs.open(path, constants.O_SYMLINK, function (er, fd) {
	          if (er) {
	            if (cb) cb(er);
	            return;
	          }
	          fs.futimes(fd, at, mt, function (er) {
	            fs.close(fd, function (er2) {
	              if (cb) cb(er || er2);
	            });
	          });
	        });
	      };
	      fs.lutimesSync = function (path, at, mt) {
	        var fd = fs.openSync(path, constants.O_SYMLINK);
	        var ret;
	        var threw = true;
	        try {
	          ret = fs.futimesSync(fd, at, mt);
	          threw = false;
	        } finally {
	          if (threw) {
	            try {
	              fs.closeSync(fd);
	            } catch (er) {}
	          } else {
	            fs.closeSync(fd);
	          }
	        }
	        return ret;
	      };
	    } else if (fs.futimes) {
	      fs.lutimes = function (_a, _b, _c, cb) {
	        if (cb) process.nextTick(cb);
	      };
	      fs.lutimesSync = function () {};
	    }
	  }
	  function chmodFix(orig) {
	    if (!orig) return orig;
	    return function (target, mode, cb) {
	      return orig.call(fs, target, mode, function (er) {
	        if (chownErOk(er)) er = null;
	        if (cb) cb.apply(this, arguments);
	      });
	    };
	  }
	  function chmodFixSync(orig) {
	    if (!orig) return orig;
	    return function (target, mode) {
	      try {
	        return orig.call(fs, target, mode);
	      } catch (er) {
	        if (!chownErOk(er)) throw er;
	      }
	    };
	  }
	  function chownFix(orig) {
	    if (!orig) return orig;
	    return function (target, uid, gid, cb) {
	      return orig.call(fs, target, uid, gid, function (er) {
	        if (chownErOk(er)) er = null;
	        if (cb) cb.apply(this, arguments);
	      });
	    };
	  }
	  function chownFixSync(orig) {
	    if (!orig) return orig;
	    return function (target, uid, gid) {
	      try {
	        return orig.call(fs, target, uid, gid);
	      } catch (er) {
	        if (!chownErOk(er)) throw er;
	      }
	    };
	  }
	  function statFix(orig) {
	    if (!orig) return orig;
	    // Older versions of Node erroneously returned signed integers for
	    // uid + gid.
	    return function (target, options, cb) {
	      if (typeof options === 'function') {
	        cb = options;
	        options = null;
	      }
	      function callback(er, stats) {
	        if (stats) {
	          if (stats.uid < 0) stats.uid += 0x100000000;
	          if (stats.gid < 0) stats.gid += 0x100000000;
	        }
	        if (cb) cb.apply(this, arguments);
	      }
	      return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
	    };
	  }
	  function statFixSync(orig) {
	    if (!orig) return orig;
	    // Older versions of Node erroneously returned signed integers for
	    // uid + gid.
	    return function (target, options) {
	      var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
	      if (stats) {
	        if (stats.uid < 0) stats.uid += 0x100000000;
	        if (stats.gid < 0) stats.gid += 0x100000000;
	      }
	      return stats;
	    };
	  }

	  // ENOSYS means that the fs doesn't support the op. Just ignore
	  // that, because it doesn't matter.
	  //
	  // if there's no getuid, or if getuid() is something other
	  // than 0, and the error is EINVAL or EPERM, then just ignore
	  // it.
	  //
	  // This specific case is a silent failure in cp, install, tar,
	  // and most other unix tools that manage permissions.
	  //
	  // When running as root, or if other types of errors are
	  // encountered, then it's strict.
	  function chownErOk(er) {
	    if (!er) return true;
	    if (er.code === "ENOSYS") return true;
	    var nonroot = !process.getuid || process.getuid() !== 0;
	    if (nonroot) {
	      if (er.code === "EINVAL" || er.code === "EPERM") return true;
	    }
	    return false;
	  }
	}

	function BufferList$2() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}

	BufferList$2.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};

	BufferList$2.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};

	BufferList$2.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};

	BufferList$2.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};

	BufferList$2.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};

	BufferList$2.prototype.concat = function (n) {
	  if (this.length === 0) return Buffer$3.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = Buffer$3.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var isBufferEncoding = Buffer$3.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     };


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	function StringDecoder(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer$3(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	}

	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}

	var _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({
		__proto__: null,
		StringDecoder: StringDecoder
	});

	Readable.ReadableState = ReadableState;

	var debug$1 = debuglog('stream');
	inherits$4(Readable, EventEmitter$1);

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event])
	      emitter.on(event, fn);
	    else if (Array.isArray(emitter._events[event]))
	      emitter._events[event].unshift(fn);
	    else
	      emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	function listenerCount (emitter, type) {
	  return emitter.listeners(type).length;
	}
	function ReadableState(options, stream) {

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList$2();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  EventEmitter$1.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = Buffer$3.from(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug$1('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug$1('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug$1('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug$1('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug$1('reading or ended', doRead);
	  } else if (doRead) {
	    debug$1('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer$3.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug$1('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug$1('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug$1('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug$1('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false);

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug$1('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug$1('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug$1('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug$1('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug$1('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug$1('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug$1('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug$1('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug$1('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug$1('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && src.listeners('data').length) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = EventEmitter$1.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug$1('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug$1('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug$1('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug$1('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug$1('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug$1('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug$1('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug$1('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug$1('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer$3.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	Writable.WritableState = WritableState;
	inherits$4(Writable, EventEmitter$1);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  Object.defineProperty(this, 'buffer', {
	    get: deprecate(function () {
	      return this.getBuffer();
	    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	  });
	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	function Writable(options) {

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  EventEmitter$1.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  nextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer$3.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer$3.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer$3.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer$3.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) nextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	        nextTick(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}

	inherits$4(Duplex, Readable);

	var keys$6 = Object.keys(Writable.prototype);
	for (var v = 0; v < keys$6.length; v++) {
	  var method = keys$6[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	inherits$4(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}

	inherits$4(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	inherits$4(Stream$3, EventEmitter$1);
	Stream$3.Readable = Readable;
	Stream$3.Writable = Writable;
	Stream$3.Duplex = Duplex;
	Stream$3.Transform = Transform;
	Stream$3.PassThrough = PassThrough;

	// Backwards-compat with node 0.4.x
	Stream$3.Stream = Stream$3;

	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream$3() {
	  EventEmitter$1.call(this);
	}

	Stream$3.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EventEmitter$1.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

	var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Duplex: Duplex,
		PassThrough: PassThrough,
		Readable: Readable,
		Stream: Stream$3,
		Transform: Transform,
		Writable: Writable,
		default: Stream$3
	});

	var require$$0$5 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

	var Stream$2 = require$$0$5.Stream;
	var legacyStreams = legacy$1;
	function legacy$1(fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  };
	  function ReadStream(path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);
	    Stream$2.call(this);
	    var self = this;
	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;
	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;
	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	    if (this.encoding) this.setEncoding(this.encoding);
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }
	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }
	      this.pos = this.start;
	    }
	    if (this.fd !== null) {
	      process.nextTick(function () {
	        self._read();
	      });
	      return;
	    }
	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }
	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    });
	  }
	  function WriteStream(path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);
	    Stream$2.call(this);
	    this.path = path;
	    this.fd = null;
	    this.writable = true;
	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;
	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }
	      this.pos = this.start;
	    }
	    this.busy = false;
	    this._queue = [];
	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}

	var clone_1$1 = clone$5;
	var getPrototypeOf = Object.getPrototypeOf || function (obj) {
	  return obj.__proto__;
	};
	function clone$5(obj) {
	  if (obj === null || typeof obj !== 'object') return obj;
	  if (obj instanceof Object) var copy = {
	    __proto__: getPrototypeOf(obj)
	  };else var copy = Object.create(null);
	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
	  });
	  return copy;
	}

	var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

	var fs$j = require$$2$2;
	var polyfills = polyfills$1;
	var legacy = legacyStreams;
	var clone$4 = clone_1$1;
	var util$1 = require$$0$4;

	/* istanbul ignore next - node 0.x polyfill */
	var gracefulQueue;
	var previousSymbol;

	/* istanbul ignore else - node 0.x polyfill */
	if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
	  gracefulQueue = Symbol.for('graceful-fs.queue');
	  // This is used in testing by future versions
	  previousSymbol = Symbol.for('graceful-fs.previous');
	} else {
	  gracefulQueue = '___graceful-fs.queue';
	  previousSymbol = '___graceful-fs.previous';
	}
	function noop$1() {}
	function publishQueue(context, queue) {
	  Object.defineProperty(context, gracefulQueue, {
	    get: function () {
	      return queue;
	    }
	  });
	}
	var debug = noop$1;
	if (util$1.debuglog) debug = util$1.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
	  var m = util$1.format.apply(util$1, arguments);
	  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
	  console.error(m);
	};

	// Once time initialization
	if (!fs$j[gracefulQueue]) {
	  // This queue can be shared by multiple loaded instances
	  var queue = commonjsGlobal[gracefulQueue] || [];
	  publishQueue(fs$j, queue);

	  // Patch fs.close/closeSync to shared queue version, because we need
	  // to retry() whenever a close happens *anywhere* in the program.
	  // This is essential when multiple graceful-fs instances are
	  // in play at the same time.
	  fs$j.close = function (fs$close) {
	    function close(fd, cb) {
	      return fs$close.call(fs$j, fd, function (err) {
	        // This function uses the graceful-fs shared queue
	        if (!err) {
	          resetQueue();
	        }
	        if (typeof cb === 'function') cb.apply(this, arguments);
	      });
	    }
	    Object.defineProperty(close, previousSymbol, {
	      value: fs$close
	    });
	    return close;
	  }(fs$j.close);
	  fs$j.closeSync = function (fs$closeSync) {
	    function closeSync(fd) {
	      // This function uses the graceful-fs shared queue
	      fs$closeSync.apply(fs$j, arguments);
	      resetQueue();
	    }
	    Object.defineProperty(closeSync, previousSymbol, {
	      value: fs$closeSync
	    });
	    return closeSync;
	  }(fs$j.closeSync);
	  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	    process.on('exit', function () {
	      debug(fs$j[gracefulQueue]);
	      require$$5$1.equal(fs$j[gracefulQueue].length, 0);
	    });
	  }
	}
	if (!commonjsGlobal[gracefulQueue]) {
	  publishQueue(commonjsGlobal, fs$j[gracefulQueue]);
	}
	var gracefulFs = patch(clone$4(fs$j));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$j.__patched) {
	  gracefulFs = patch(fs$j);
	  fs$j.__patched = true;
	}
	function patch(fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs);
	  fs.gracefulify = patch;
	  fs.createReadStream = createReadStream;
	  fs.createWriteStream = createWriteStream;
	  var fs$readFile = fs.readFile;
	  fs.readFile = readFile;
	  function readFile(path, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;
	    return go$readFile(path, options, cb);
	    function go$readFile(path, options, cb, startTime) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	        }
	      });
	    }
	  }
	  var fs$writeFile = fs.writeFile;
	  fs.writeFile = writeFile;
	  function writeFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;
	    return go$writeFile(path, data, options, cb);
	    function go$writeFile(path, data, options, cb, startTime) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	        }
	      });
	    }
	  }
	  var fs$appendFile = fs.appendFile;
	  if (fs$appendFile) fs.appendFile = appendFile;
	  function appendFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;
	    return go$appendFile(path, data, options, cb);
	    function go$appendFile(path, data, options, cb, startTime) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	        }
	      });
	    }
	  }
	  var fs$copyFile = fs.copyFile;
	  if (fs$copyFile) fs.copyFile = copyFile;
	  function copyFile(src, dest, flags, cb) {
	    if (typeof flags === 'function') {
	      cb = flags;
	      flags = 0;
	    }
	    return go$copyFile(src, dest, flags, cb);
	    function go$copyFile(src, dest, flags, cb, startTime) {
	      return fs$copyFile(src, dest, flags, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	        }
	      });
	    }
	  }
	  var fs$readdir = fs.readdir;
	  fs.readdir = readdir;
	  var noReaddirOptionVersions = /^v[0-5]\./;
	  function readdir(path, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;
	    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
	      return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
	    } : function go$readdir(path, options, cb, startTime) {
	      return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
	    };
	    return go$readdir(path, options, cb);
	    function fs$readdirCallback(path, options, cb, startTime) {
	      return function (err, files) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (files && files.sort) files.sort();
	          if (typeof cb === 'function') cb.call(this, err, files);
	        }
	      };
	    }
	  }
	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs);
	    ReadStream = legStreams.ReadStream;
	    WriteStream = legStreams.WriteStream;
	  }
	  var fs$ReadStream = fs.ReadStream;
	  if (fs$ReadStream) {
	    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
	    ReadStream.prototype.open = ReadStream$open;
	  }
	  var fs$WriteStream = fs.WriteStream;
	  if (fs$WriteStream) {
	    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
	    WriteStream.prototype.open = WriteStream$open;
	  }
	  Object.defineProperty(fs, 'ReadStream', {
	    get: function () {
	      return ReadStream;
	    },
	    set: function (val) {
	      ReadStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  Object.defineProperty(fs, 'WriteStream', {
	    get: function () {
	      return WriteStream;
	    },
	    set: function (val) {
	      WriteStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  // legacy names
	  var FileReadStream = ReadStream;
	  Object.defineProperty(fs, 'FileReadStream', {
	    get: function () {
	      return FileReadStream;
	    },
	    set: function (val) {
	      FileReadStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  var FileWriteStream = WriteStream;
	  Object.defineProperty(fs, 'FileWriteStream', {
	    get: function () {
	      return FileWriteStream;
	    },
	    set: function (val) {
	      FileWriteStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  function ReadStream(path, options) {
	    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
	  }
	  function ReadStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose) that.destroy();
	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	        that.read();
	      }
	    });
	  }
	  function WriteStream(path, options) {
	    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
	  }
	  function WriteStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy();
	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	      }
	    });
	  }
	  function createReadStream(path, options) {
	    return new fs.ReadStream(path, options);
	  }
	  function createWriteStream(path, options) {
	    return new fs.WriteStream(path, options);
	  }
	  var fs$open = fs.open;
	  fs.open = open;
	  function open(path, flags, mode, cb) {
	    if (typeof mode === 'function') cb = mode, mode = null;
	    return go$open(path, flags, mode, cb);
	    function go$open(path, flags, mode, cb, startTime) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	        }
	      });
	    }
	  }
	  return fs;
	}
	function enqueue(elem) {
	  debug('ENQUEUE', elem[0].name, elem[1]);
	  fs$j[gracefulQueue].push(elem);
	  retry();
	}

	// keep track of the timeout between retry() calls
	var retryTimer;

	// reset the startTime and lastTime to now
	// this resets the start of the 60 second overall timeout as well as the
	// delay between attempts so that we'll retry these jobs sooner
	function resetQueue() {
	  var now = Date.now();
	  for (var i = 0; i < fs$j[gracefulQueue].length; ++i) {
	    // entries that are only a length of 2 are from an older version, don't
	    // bother modifying those since they'll be retried anyway.
	    if (fs$j[gracefulQueue][i].length > 2) {
	      fs$j[gracefulQueue][i][3] = now; // startTime
	      fs$j[gracefulQueue][i][4] = now; // lastTime
	    }
	  }
	  // call retry to make sure we're actively processing the queue
	  retry();
	}
	function retry() {
	  // clear the timer and remove it to help prevent unintended concurrency
	  clearTimeout(retryTimer);
	  retryTimer = undefined;
	  if (fs$j[gracefulQueue].length === 0) return;
	  var elem = fs$j[gracefulQueue].shift();
	  var fn = elem[0];
	  var args = elem[1];
	  // these items may be unset if they were added by an older graceful-fs
	  var err = elem[2];
	  var startTime = elem[3];
	  var lastTime = elem[4];

	  // if we don't have a startTime we have no way of knowing if we've waited
	  // long enough, so go ahead and retry this item now
	  if (startTime === undefined) {
	    debug('RETRY', fn.name, args);
	    fn.apply(null, args);
	  } else if (Date.now() - startTime >= 60000) {
	    // it's been more than 60 seconds total, bail now
	    debug('TIMEOUT', fn.name, args);
	    var cb = args.pop();
	    if (typeof cb === 'function') cb.call(null, err);
	  } else {
	    // the amount of time between the last attempt and right now
	    var sinceAttempt = Date.now() - lastTime;
	    // the amount of time between when we first tried, and when we last tried
	    // rounded up to at least 1
	    var sinceStart = Math.max(lastTime - startTime, 1);
	    // backoff. wait longer than the total time we've been retrying, but only
	    // up to a maximum of 100ms
	    var desiredDelay = Math.min(sinceStart * 1.2, 100);
	    // it's been long enough since the last retry, do it again
	    if (sinceAttempt >= desiredDelay) {
	      debug('RETRY', fn.name, args);
	      fn.apply(null, args.concat([startTime]));
	    } else {
	      // if we can't do this job yet, push it to the end of the queue
	      // and let the next iteration check again
	      fs$j[gracefulQueue].push(elem);
	    }
	  }

	  // schedule our next run if one isn't already scheduled
	  if (retryTimer === undefined) {
	    retryTimer = setTimeout(retry, 0);
	  }
	}

	(function (exports) {

	  // This is adapted from https://github.com/normalize/mz
	  // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
	  const u = universalify$1.fromCallback;
	  const fs = gracefulFs;
	  const api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'opendir', 'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rm', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(key => {
	    // Some commands are not available on some systems. Ex:
	    // fs.cp was added in Node.js v16.7.0
	    // fs.lchown is not available on at least some Linux
	    return typeof fs[key] === 'function';
	  });

	  // Export cloned fs:
	  Object.assign(exports, fs);

	  // Universalify async methods:
	  api.forEach(method => {
	    exports[method] = u(fs[method]);
	  });

	  // We differ from mz/fs in that we still ship the old, broken, fs.exists()
	  // since we are a drop-in replacement for the native module
	  exports.exists = function (filename, callback) {
	    if (typeof callback === 'function') {
	      return fs.exists(filename, callback);
	    }
	    return new Promise(resolve => {
	      return fs.exists(filename, resolve);
	    });
	  };

	  // fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

	  exports.read = function (fd, buffer, offset, length, position, callback) {
	    if (typeof callback === 'function') {
	      return fs.read(fd, buffer, offset, length, position, callback);
	    }
	    return new Promise((resolve, reject) => {
	      fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
	        if (err) return reject(err);
	        resolve({
	          bytesRead,
	          buffer
	        });
	      });
	    });
	  };

	  // Function signature can be
	  // fs.write(fd, buffer[, offset[, length[, position]]], callback)
	  // OR
	  // fs.write(fd, string[, position[, encoding]], callback)
	  // We need to handle both cases, so we use ...args
	  exports.write = function (fd, buffer, ...args) {
	    if (typeof args[args.length - 1] === 'function') {
	      return fs.write(fd, buffer, ...args);
	    }
	    return new Promise((resolve, reject) => {
	      fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
	        if (err) return reject(err);
	        resolve({
	          bytesWritten,
	          buffer
	        });
	      });
	    });
	  };

	  // Function signature is
	  // s.readv(fd, buffers[, position], callback)
	  // We need to handle the optional arg, so we use ...args
	  exports.readv = function (fd, buffers, ...args) {
	    if (typeof args[args.length - 1] === 'function') {
	      return fs.readv(fd, buffers, ...args);
	    }
	    return new Promise((resolve, reject) => {
	      fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
	        if (err) return reject(err);
	        resolve({
	          bytesRead,
	          buffers
	        });
	      });
	    });
	  };

	  // Function signature is
	  // s.writev(fd, buffers[, position], callback)
	  // We need to handle the optional arg, so we use ...args
	  exports.writev = function (fd, buffers, ...args) {
	    if (typeof args[args.length - 1] === 'function') {
	      return fs.writev(fd, buffers, ...args);
	    }
	    return new Promise((resolve, reject) => {
	      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
	        if (err) return reject(err);
	        resolve({
	          bytesWritten,
	          buffers
	        });
	      });
	    });
	  };

	  // fs.realpath.native sometimes not available if fs is monkey-patched
	  if (typeof fs.realpath.native === 'function') {
	    exports.realpath.native = u(fs.realpath.native);
	  } else {
	    process.emitWarning('fs.realpath.native is not a function. Is fs being monkey-patched?', 'Warning', 'fs-extra-WARN0003');
	  }
	})(fs$k);

	var makeDir$1 = {};

	var utils$1 = {};

	const path$c = require$$1$4;

	// https://github.com/nodejs/node/issues/8987
	// https://github.com/libuv/libuv/pull/1088
	utils$1.checkPath = function checkPath(pth) {
	  if (process.platform === 'win32') {
	    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$c.parse(pth).root, ''));
	    if (pathHasInvalidWinCharacters) {
	      const error = new Error(`Path contains invalid characters: ${pth}`);
	      error.code = 'EINVAL';
	      throw error;
	    }
	  }
	};

	const fs$i = fs$k;
	const {
	  checkPath
	} = utils$1;
	const getMode = options => {
	  const defaults = {
	    mode: 0o777
	  };
	  if (typeof options === 'number') return options;
	  return {
	    ...defaults,
	    ...options
	  }.mode;
	};
	makeDir$1.makeDir = async (dir, options) => {
	  checkPath(dir);
	  return fs$i.mkdir(dir, {
	    mode: getMode(options),
	    recursive: true
	  });
	};
	makeDir$1.makeDirSync = (dir, options) => {
	  checkPath(dir);
	  return fs$i.mkdirSync(dir, {
	    mode: getMode(options),
	    recursive: true
	  });
	};

	const u$e = universalify$1.fromPromise;
	const {
	  makeDir: _makeDir,
	  makeDirSync
	} = makeDir$1;
	const makeDir = u$e(_makeDir);
	var mkdirs$2 = {
	  mkdirs: makeDir,
	  mkdirsSync: makeDirSync,
	  // alias
	  mkdirp: makeDir,
	  mkdirpSync: makeDirSync,
	  ensureDir: makeDir,
	  ensureDirSync: makeDirSync
	};

	const u$d = universalify$1.fromPromise;
	const fs$h = fs$k;
	function pathExists$6(path) {
	  return fs$h.access(path).then(() => true).catch(() => false);
	}
	var pathExists_1 = {
	  pathExists: u$d(pathExists$6),
	  pathExistsSync: fs$h.existsSync
	};

	const fs$g = fs$k;
	const u$c = universalify$1.fromPromise;
	async function utimesMillis$1(path, atime, mtime) {
	  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
	  const fd = await fs$g.open(path, 'r+');
	  let closeErr = null;
	  try {
	    await fs$g.futimes(fd, atime, mtime);
	  } finally {
	    try {
	      await fs$g.close(fd);
	    } catch (e) {
	      closeErr = e;
	    }
	  }
	  if (closeErr) {
	    throw closeErr;
	  }
	}
	function utimesMillisSync$1(path, atime, mtime) {
	  const fd = fs$g.openSync(path, 'r+');
	  fs$g.futimesSync(fd, atime, mtime);
	  return fs$g.closeSync(fd);
	}
	var utimes = {
	  utimesMillis: u$c(utimesMillis$1),
	  utimesMillisSync: utimesMillisSync$1
	};

	const fs$f = fs$k;
	const path$b = require$$1$4;
	const u$b = universalify$1.fromPromise;
	function getStats$1(src, dest, opts) {
	  const statFunc = opts.dereference ? file => fs$f.stat(file, {
	    bigint: true
	  }) : file => fs$f.lstat(file, {
	    bigint: true
	  });
	  return Promise.all([statFunc(src), statFunc(dest).catch(err => {
	    if (err.code === 'ENOENT') return null;
	    throw err;
	  })]).then(([srcStat, destStat]) => ({
	    srcStat,
	    destStat
	  }));
	}
	function getStatsSync(src, dest, opts) {
	  let destStat;
	  const statFunc = opts.dereference ? file => fs$f.statSync(file, {
	    bigint: true
	  }) : file => fs$f.lstatSync(file, {
	    bigint: true
	  });
	  const srcStat = statFunc(src);
	  try {
	    destStat = statFunc(dest);
	  } catch (err) {
	    if (err.code === 'ENOENT') return {
	      srcStat,
	      destStat: null
	    };
	    throw err;
	  }
	  return {
	    srcStat,
	    destStat
	  };
	}
	async function checkPaths(src, dest, funcName, opts) {
	  const {
	    srcStat,
	    destStat
	  } = await getStats$1(src, dest, opts);
	  if (destStat) {
	    if (areIdentical$2(srcStat, destStat)) {
	      const srcBaseName = path$b.basename(src);
	      const destBaseName = path$b.basename(dest);
	      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
	        return {
	          srcStat,
	          destStat,
	          isChangingCase: true
	        };
	      }
	      throw new Error('Source and destination must not be the same.');
	    }
	    if (srcStat.isDirectory() && !destStat.isDirectory()) {
	      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
	    }
	    if (!srcStat.isDirectory() && destStat.isDirectory()) {
	      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
	    }
	  }
	  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	    throw new Error(errMsg(src, dest, funcName));
	  }
	  return {
	    srcStat,
	    destStat
	  };
	}
	function checkPathsSync(src, dest, funcName, opts) {
	  const {
	    srcStat,
	    destStat
	  } = getStatsSync(src, dest, opts);
	  if (destStat) {
	    if (areIdentical$2(srcStat, destStat)) {
	      const srcBaseName = path$b.basename(src);
	      const destBaseName = path$b.basename(dest);
	      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
	        return {
	          srcStat,
	          destStat,
	          isChangingCase: true
	        };
	      }
	      throw new Error('Source and destination must not be the same.');
	    }
	    if (srcStat.isDirectory() && !destStat.isDirectory()) {
	      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
	    }
	    if (!srcStat.isDirectory() && destStat.isDirectory()) {
	      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
	    }
	  }
	  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	    throw new Error(errMsg(src, dest, funcName));
	  }
	  return {
	    srcStat,
	    destStat
	  };
	}

	// recursively check if dest parent is a subdirectory of src.
	// It works for all file types including symlinks since it
	// checks the src and dest inodes. It starts from the deepest
	// parent and stops once it reaches the src parent or the root path.
	async function checkParentPaths(src, srcStat, dest, funcName) {
	  const srcParent = path$b.resolve(path$b.dirname(src));
	  const destParent = path$b.resolve(path$b.dirname(dest));
	  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return;
	  let destStat;
	  try {
	    destStat = await fs$f.stat(destParent, {
	      bigint: true
	    });
	  } catch (err) {
	    if (err.code === 'ENOENT') return;
	    throw err;
	  }
	  if (areIdentical$2(srcStat, destStat)) {
	    throw new Error(errMsg(src, dest, funcName));
	  }
	  return checkParentPaths(src, srcStat, destParent, funcName);
	}
	function checkParentPathsSync(src, srcStat, dest, funcName) {
	  const srcParent = path$b.resolve(path$b.dirname(src));
	  const destParent = path$b.resolve(path$b.dirname(dest));
	  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return;
	  let destStat;
	  try {
	    destStat = fs$f.statSync(destParent, {
	      bigint: true
	    });
	  } catch (err) {
	    if (err.code === 'ENOENT') return;
	    throw err;
	  }
	  if (areIdentical$2(srcStat, destStat)) {
	    throw new Error(errMsg(src, dest, funcName));
	  }
	  return checkParentPathsSync(src, srcStat, destParent, funcName);
	}
	function areIdentical$2(srcStat, destStat) {
	  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
	}

	// return true if dest is a subdir of src, otherwise false.
	// It only checks the path strings.
	function isSrcSubdir(src, dest) {
	  const srcArr = path$b.resolve(src).split(path$b.sep).filter(i => i);
	  const destArr = path$b.resolve(dest).split(path$b.sep).filter(i => i);
	  return srcArr.every((cur, i) => destArr[i] === cur);
	}
	function errMsg(src, dest, funcName) {
	  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
	}
	var stat$4 = {
	  // checkPaths
	  checkPaths: u$b(checkPaths),
	  checkPathsSync,
	  // checkParent
	  checkParentPaths: u$b(checkParentPaths),
	  checkParentPathsSync,
	  // Misc
	  isSrcSubdir,
	  areIdentical: areIdentical$2
	};

	const fs$e = fs$k;
	const path$a = require$$1$4;
	const {
	  mkdirs: mkdirs$1
	} = mkdirs$2;
	const {
	  pathExists: pathExists$5
	} = pathExists_1;
	const {
	  utimesMillis
	} = utimes;
	const stat$3 = stat$4;
	async function copy$2(src, dest, opts = {}) {
	  if (typeof opts === 'function') {
	    opts = {
	      filter: opts
	    };
	  }
	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');
	  }
	  const {
	    srcStat,
	    destStat
	  } = await stat$3.checkPaths(src, dest, 'copy', opts);
	  await stat$3.checkParentPaths(src, srcStat, dest, 'copy');
	  const include = await runFilter(src, dest, opts);
	  if (!include) return;

	  // check if the parent of dest exists, and create it if it doesn't exist
	  const destParent = path$a.dirname(dest);
	  const dirExists = await pathExists$5(destParent);
	  if (!dirExists) {
	    await mkdirs$1(destParent);
	  }
	  await getStatsAndPerformCopy(destStat, src, dest, opts);
	}
	async function runFilter(src, dest, opts) {
	  if (!opts.filter) return true;
	  return opts.filter(src, dest);
	}
	async function getStatsAndPerformCopy(destStat, src, dest, opts) {
	  const statFn = opts.dereference ? fs$e.stat : fs$e.lstat;
	  const srcStat = await statFn(src);
	  if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts);
	  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts);
	  if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts);
	  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
	  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
	  throw new Error(`Unknown file: ${src}`);
	}
	async function onFile$1(srcStat, destStat, src, dest, opts) {
	  if (!destStat) return copyFile$1(srcStat, src, dest, opts);
	  if (opts.overwrite) {
	    await fs$e.unlink(dest);
	    return copyFile$1(srcStat, src, dest, opts);
	  }
	  if (opts.errorOnExist) {
	    throw new Error(`'${dest}' already exists`);
	  }
	}
	async function copyFile$1(srcStat, src, dest, opts) {
	  await fs$e.copyFile(src, dest);
	  if (opts.preserveTimestamps) {
	    // Make sure the file is writable before setting the timestamp
	    // otherwise open fails with EPERM when invoked with 'r+'
	    // (through utimes call)
	    if (fileIsNotWritable$1(srcStat.mode)) {
	      await makeFileWritable$1(dest, srcStat.mode);
	    }

	    // Set timestamps and mode correspondingly

	    // Note that The initial srcStat.atime cannot be trusted
	    // because it is modified by the read(2) system call
	    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
	    const updatedSrcStat = await fs$e.stat(src);
	    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
	  }
	  return fs$e.chmod(dest, srcStat.mode);
	}
	function fileIsNotWritable$1(srcMode) {
	  return (srcMode & 0o200) === 0;
	}
	function makeFileWritable$1(dest, srcMode) {
	  return fs$e.chmod(dest, srcMode | 0o200);
	}
	async function onDir$1(srcStat, destStat, src, dest, opts) {
	  // the dest directory might not exist, create it
	  if (!destStat) {
	    await fs$e.mkdir(dest);
	  }
	  const items = await fs$e.readdir(src);

	  // loop through the files in the current directory to copy everything
	  await Promise.all(items.map(async item => {
	    const srcItem = path$a.join(src, item);
	    const destItem = path$a.join(dest, item);

	    // skip the item if it is matches by the filter function
	    const include = await runFilter(srcItem, destItem, opts);
	    if (!include) return;
	    const {
	      destStat
	    } = await stat$3.checkPaths(srcItem, destItem, 'copy', opts);

	    // If the item is a copyable file, `getStatsAndPerformCopy` will copy it
	    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively
	    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);
	  }));
	  if (!destStat) {
	    await fs$e.chmod(dest, srcStat.mode);
	  }
	}
	async function onLink$1(destStat, src, dest, opts) {
	  let resolvedSrc = await fs$e.readlink(src);
	  if (opts.dereference) {
	    resolvedSrc = path$a.resolve(process.cwd(), resolvedSrc);
	  }
	  if (!destStat) {
	    return fs$e.symlink(resolvedSrc, dest);
	  }
	  let resolvedDest = null;
	  try {
	    resolvedDest = await fs$e.readlink(dest);
	  } catch (e) {
	    // dest exists and is a regular file or directory,
	    // Windows may throw UNKNOWN error. If dest already exists,
	    // fs throws error anyway, so no need to guard against it here.
	    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs$e.symlink(resolvedSrc, dest);
	    throw e;
	  }
	  if (opts.dereference) {
	    resolvedDest = path$a.resolve(process.cwd(), resolvedDest);
	  }
	  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
	    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
	  }

	  // do not copy if src is a subdir of dest since unlinking
	  // dest in this case would result in removing src contents
	  // and therefore a broken symlink would be created.
	  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
	    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
	  }

	  // copy the link
	  await fs$e.unlink(dest);
	  return fs$e.symlink(resolvedSrc, dest);
	}
	var copy_1 = copy$2;

	const fs$d = gracefulFs;
	const path$9 = require$$1$4;
	const mkdirsSync$1 = mkdirs$2.mkdirsSync;
	const utimesMillisSync = utimes.utimesMillisSync;
	const stat$2 = stat$4;
	function copySync$1(src, dest, opts) {
	  if (typeof opts === 'function') {
	    opts = {
	      filter: opts
	    };
	  }
	  opts = opts || {};
	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');
	  }
	  const {
	    srcStat,
	    destStat
	  } = stat$2.checkPathsSync(src, dest, 'copy', opts);
	  stat$2.checkParentPathsSync(src, srcStat, dest, 'copy');
	  if (opts.filter && !opts.filter(src, dest)) return;
	  const destParent = path$9.dirname(dest);
	  if (!fs$d.existsSync(destParent)) mkdirsSync$1(destParent);
	  return getStats(destStat, src, dest, opts);
	}
	function getStats(destStat, src, dest, opts) {
	  const statSync = opts.dereference ? fs$d.statSync : fs$d.lstatSync;
	  const srcStat = statSync(src);
	  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
	  throw new Error(`Unknown file: ${src}`);
	}
	function onFile(srcStat, destStat, src, dest, opts) {
	  if (!destStat) return copyFile(srcStat, src, dest, opts);
	  return mayCopyFile(srcStat, src, dest, opts);
	}
	function mayCopyFile(srcStat, src, dest, opts) {
	  if (opts.overwrite) {
	    fs$d.unlinkSync(dest);
	    return copyFile(srcStat, src, dest, opts);
	  } else if (opts.errorOnExist) {
	    throw new Error(`'${dest}' already exists`);
	  }
	}
	function copyFile(srcStat, src, dest, opts) {
	  fs$d.copyFileSync(src, dest);
	  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
	  return setDestMode(dest, srcStat.mode);
	}
	function handleTimestamps(srcMode, src, dest) {
	  // Make sure the file is writable before setting the timestamp
	  // otherwise open fails with EPERM when invoked with 'r+'
	  // (through utimes call)
	  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
	  return setDestTimestamps(src, dest);
	}
	function fileIsNotWritable(srcMode) {
	  return (srcMode & 0o200) === 0;
	}
	function makeFileWritable(dest, srcMode) {
	  return setDestMode(dest, srcMode | 0o200);
	}
	function setDestMode(dest, srcMode) {
	  return fs$d.chmodSync(dest, srcMode);
	}
	function setDestTimestamps(src, dest) {
	  // The initial srcStat.atime cannot be trusted
	  // because it is modified by the read(2) system call
	  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
	  const updatedSrcStat = fs$d.statSync(src);
	  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
	}
	function onDir(srcStat, destStat, src, dest, opts) {
	  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
	  return copyDir(src, dest, opts);
	}
	function mkDirAndCopy(srcMode, src, dest, opts) {
	  fs$d.mkdirSync(dest);
	  copyDir(src, dest, opts);
	  return setDestMode(dest, srcMode);
	}
	function copyDir(src, dest, opts) {
	  fs$d.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));
	}
	function copyDirItem(item, src, dest, opts) {
	  const srcItem = path$9.join(src, item);
	  const destItem = path$9.join(dest, item);
	  if (opts.filter && !opts.filter(srcItem, destItem)) return;
	  const {
	    destStat
	  } = stat$2.checkPathsSync(srcItem, destItem, 'copy', opts);
	  return getStats(destStat, srcItem, destItem, opts);
	}
	function onLink(destStat, src, dest, opts) {
	  let resolvedSrc = fs$d.readlinkSync(src);
	  if (opts.dereference) {
	    resolvedSrc = path$9.resolve(process.cwd(), resolvedSrc);
	  }
	  if (!destStat) {
	    return fs$d.symlinkSync(resolvedSrc, dest);
	  } else {
	    let resolvedDest;
	    try {
	      resolvedDest = fs$d.readlinkSync(dest);
	    } catch (err) {
	      // dest exists and is a regular file or directory,
	      // Windows may throw UNKNOWN error. If dest already exists,
	      // fs throws error anyway, so no need to guard against it here.
	      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$d.symlinkSync(resolvedSrc, dest);
	      throw err;
	    }
	    if (opts.dereference) {
	      resolvedDest = path$9.resolve(process.cwd(), resolvedDest);
	    }
	    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
	      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
	    }

	    // prevent copy if src is a subdir of dest since unlinking
	    // dest in this case would result in removing src contents
	    // and therefore a broken symlink would be created.
	    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
	      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
	    }
	    return copyLink(resolvedSrc, dest);
	  }
	}
	function copyLink(resolvedSrc, dest) {
	  fs$d.unlinkSync(dest);
	  return fs$d.symlinkSync(resolvedSrc, dest);
	}
	var copySync_1 = copySync$1;

	const u$a = universalify$1.fromPromise;
	var copy$1 = {
	  copy: u$a(copy_1),
	  copySync: copySync_1
	};

	const fs$c = gracefulFs;
	const u$9 = universalify$1.fromCallback;
	function remove$2(path, callback) {
	  fs$c.rm(path, {
	    recursive: true,
	    force: true
	  }, callback);
	}
	function removeSync$1(path) {
	  fs$c.rmSync(path, {
	    recursive: true,
	    force: true
	  });
	}
	var remove_1 = {
	  remove: u$9(remove$2),
	  removeSync: removeSync$1
	};

	const u$8 = universalify$1.fromPromise;
	const fs$b = fs$k;
	const path$8 = require$$1$4;
	const mkdir$3 = mkdirs$2;
	const remove$1 = remove_1;
	const emptyDir = u$8(async function emptyDir(dir) {
	  let items;
	  try {
	    items = await fs$b.readdir(dir);
	  } catch {
	    return mkdir$3.mkdirs(dir);
	  }
	  return Promise.all(items.map(item => remove$1.remove(path$8.join(dir, item))));
	});
	function emptyDirSync(dir) {
	  let items;
	  try {
	    items = fs$b.readdirSync(dir);
	  } catch {
	    return mkdir$3.mkdirsSync(dir);
	  }
	  items.forEach(item => {
	    item = path$8.join(dir, item);
	    remove$1.removeSync(item);
	  });
	}
	var empty$1 = {
	  emptyDirSync,
	  emptydirSync: emptyDirSync,
	  emptyDir,
	  emptydir: emptyDir
	};

	const u$7 = universalify$1.fromPromise;
	const path$7 = require$$1$4;
	const fs$a = fs$k;
	const mkdir$2 = mkdirs$2;
	async function createFile$1(file) {
	  let stats;
	  try {
	    stats = await fs$a.stat(file);
	  } catch {}
	  if (stats && stats.isFile()) return;
	  const dir = path$7.dirname(file);
	  let dirStats = null;
	  try {
	    dirStats = await fs$a.stat(dir);
	  } catch (err) {
	    // if the directory doesn't exist, make it
	    if (err.code === 'ENOENT') {
	      await mkdir$2.mkdirs(dir);
	      await fs$a.writeFile(file, '');
	      return;
	    } else {
	      throw err;
	    }
	  }
	  if (dirStats.isDirectory()) {
	    await fs$a.writeFile(file, '');
	  } else {
	    // parent is not a directory
	    // This is just to cause an internal ENOTDIR error to be thrown
	    await fs$a.readdir(dir);
	  }
	}
	function createFileSync$1(file) {
	  let stats;
	  try {
	    stats = fs$a.statSync(file);
	  } catch {}
	  if (stats && stats.isFile()) return;
	  const dir = path$7.dirname(file);
	  try {
	    if (!fs$a.statSync(dir).isDirectory()) {
	      // parent is not a directory
	      // This is just to cause an internal ENOTDIR error to be thrown
	      fs$a.readdirSync(dir);
	    }
	  } catch (err) {
	    // If the stat call above failed because the directory doesn't exist, create it
	    if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);else throw err;
	  }
	  fs$a.writeFileSync(file, '');
	}
	var file$1 = {
	  createFile: u$7(createFile$1),
	  createFileSync: createFileSync$1
	};

	const u$6 = universalify$1.fromPromise;
	const path$6 = require$$1$4;
	const fs$9 = fs$k;
	const mkdir$1 = mkdirs$2;
	const {
	  pathExists: pathExists$4
	} = pathExists_1;
	const {
	  areIdentical: areIdentical$1
	} = stat$4;
	async function createLink$1(srcpath, dstpath) {
	  let dstStat;
	  try {
	    dstStat = await fs$9.lstat(dstpath);
	  } catch {
	    // ignore error
	  }
	  let srcStat;
	  try {
	    srcStat = await fs$9.lstat(srcpath);
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureLink');
	    throw err;
	  }
	  if (dstStat && areIdentical$1(srcStat, dstStat)) return;
	  const dir = path$6.dirname(dstpath);
	  const dirExists = await pathExists$4(dir);
	  if (!dirExists) {
	    await mkdir$1.mkdirs(dir);
	  }
	  await fs$9.link(srcpath, dstpath);
	}
	function createLinkSync$1(srcpath, dstpath) {
	  let dstStat;
	  try {
	    dstStat = fs$9.lstatSync(dstpath);
	  } catch {}
	  try {
	    const srcStat = fs$9.lstatSync(srcpath);
	    if (dstStat && areIdentical$1(srcStat, dstStat)) return;
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureLink');
	    throw err;
	  }
	  const dir = path$6.dirname(dstpath);
	  const dirExists = fs$9.existsSync(dir);
	  if (dirExists) return fs$9.linkSync(srcpath, dstpath);
	  mkdir$1.mkdirsSync(dir);
	  return fs$9.linkSync(srcpath, dstpath);
	}
	var link = {
	  createLink: u$6(createLink$1),
	  createLinkSync: createLinkSync$1
	};

	const path$5 = require$$1$4;
	const fs$8 = fs$k;
	const {
	  pathExists: pathExists$3
	} = pathExists_1;
	const u$5 = universalify$1.fromPromise;

	/**
	 * Function that returns two types of paths, one relative to symlink, and one
	 * relative to the current working directory. Checks if path is absolute or
	 * relative. If the path is relative, this function checks if the path is
	 * relative to symlink or relative to current working directory. This is an
	 * initiative to find a smarter `srcpath` to supply when building symlinks.
	 * This allows you to determine which path to use out of one of three possible
	 * types of source paths. The first is an absolute path. This is detected by
	 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
	 * see if it exists. If it does it's used, if not an error is returned
	 * (callback)/ thrown (sync). The other two options for `srcpath` are a
	 * relative url. By default Node's `fs.symlink` works by creating a symlink
	 * using `dstpath` and expects the `srcpath` to be relative to the newly
	 * created symlink. If you provide a `srcpath` that does not exist on the file
	 * system it results in a broken symlink. To minimize this, the function
	 * checks to see if the 'relative to symlink' source file exists, and if it
	 * does it will use it. If it does not, it checks if there's a file that
	 * exists that is relative to the current working directory, if does its used.
	 * This preserves the expectations of the original fs.symlink spec and adds
	 * the ability to pass in `relative to current working direcotry` paths.
	 */

	async function symlinkPaths$1(srcpath, dstpath) {
	  if (path$5.isAbsolute(srcpath)) {
	    try {
	      await fs$8.lstat(srcpath);
	    } catch (err) {
	      err.message = err.message.replace('lstat', 'ensureSymlink');
	      throw err;
	    }
	    return {
	      toCwd: srcpath,
	      toDst: srcpath
	    };
	  }
	  const dstdir = path$5.dirname(dstpath);
	  const relativeToDst = path$5.join(dstdir, srcpath);
	  const exists = await pathExists$3(relativeToDst);
	  if (exists) {
	    return {
	      toCwd: relativeToDst,
	      toDst: srcpath
	    };
	  }
	  try {
	    await fs$8.lstat(srcpath);
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureSymlink');
	    throw err;
	  }
	  return {
	    toCwd: srcpath,
	    toDst: path$5.relative(dstdir, srcpath)
	  };
	}
	function symlinkPathsSync$1(srcpath, dstpath) {
	  if (path$5.isAbsolute(srcpath)) {
	    const exists = fs$8.existsSync(srcpath);
	    if (!exists) throw new Error('absolute srcpath does not exist');
	    return {
	      toCwd: srcpath,
	      toDst: srcpath
	    };
	  }
	  const dstdir = path$5.dirname(dstpath);
	  const relativeToDst = path$5.join(dstdir, srcpath);
	  const exists = fs$8.existsSync(relativeToDst);
	  if (exists) {
	    return {
	      toCwd: relativeToDst,
	      toDst: srcpath
	    };
	  }
	  const srcExists = fs$8.existsSync(srcpath);
	  if (!srcExists) throw new Error('relative srcpath does not exist');
	  return {
	    toCwd: srcpath,
	    toDst: path$5.relative(dstdir, srcpath)
	  };
	}
	var symlinkPaths_1 = {
	  symlinkPaths: u$5(symlinkPaths$1),
	  symlinkPathsSync: symlinkPathsSync$1
	};

	const fs$7 = fs$k;
	const u$4 = universalify$1.fromPromise;
	async function symlinkType$1(srcpath, type) {
	  if (type) return type;
	  let stats;
	  try {
	    stats = await fs$7.lstat(srcpath);
	  } catch {
	    return 'file';
	  }
	  return stats && stats.isDirectory() ? 'dir' : 'file';
	}
	function symlinkTypeSync$1(srcpath, type) {
	  if (type) return type;
	  let stats;
	  try {
	    stats = fs$7.lstatSync(srcpath);
	  } catch {
	    return 'file';
	  }
	  return stats && stats.isDirectory() ? 'dir' : 'file';
	}
	var symlinkType_1 = {
	  symlinkType: u$4(symlinkType$1),
	  symlinkTypeSync: symlinkTypeSync$1
	};

	const u$3 = universalify$1.fromPromise;
	const path$4 = require$$1$4;
	const fs$6 = fs$k;
	const {
	  mkdirs,
	  mkdirsSync
	} = mkdirs$2;
	const {
	  symlinkPaths,
	  symlinkPathsSync
	} = symlinkPaths_1;
	const {
	  symlinkType,
	  symlinkTypeSync
	} = symlinkType_1;
	const {
	  pathExists: pathExists$2
	} = pathExists_1;
	const {
	  areIdentical
	} = stat$4;
	async function createSymlink$1(srcpath, dstpath, type) {
	  let stats;
	  try {
	    stats = await fs$6.lstat(dstpath);
	  } catch {}
	  if (stats && stats.isSymbolicLink()) {
	    const [srcStat, dstStat] = await Promise.all([fs$6.stat(srcpath), fs$6.stat(dstpath)]);
	    if (areIdentical(srcStat, dstStat)) return;
	  }
	  const relative = await symlinkPaths(srcpath, dstpath);
	  srcpath = relative.toDst;
	  const toType = await symlinkType(relative.toCwd, type);
	  const dir = path$4.dirname(dstpath);
	  if (!(await pathExists$2(dir))) {
	    await mkdirs(dir);
	  }
	  return fs$6.symlink(srcpath, dstpath, toType);
	}
	function createSymlinkSync$1(srcpath, dstpath, type) {
	  let stats;
	  try {
	    stats = fs$6.lstatSync(dstpath);
	  } catch {}
	  if (stats && stats.isSymbolicLink()) {
	    const srcStat = fs$6.statSync(srcpath);
	    const dstStat = fs$6.statSync(dstpath);
	    if (areIdentical(srcStat, dstStat)) return;
	  }
	  const relative = symlinkPathsSync(srcpath, dstpath);
	  srcpath = relative.toDst;
	  type = symlinkTypeSync(relative.toCwd, type);
	  const dir = path$4.dirname(dstpath);
	  const exists = fs$6.existsSync(dir);
	  if (exists) return fs$6.symlinkSync(srcpath, dstpath, type);
	  mkdirsSync(dir);
	  return fs$6.symlinkSync(srcpath, dstpath, type);
	}
	var symlink = {
	  createSymlink: u$3(createSymlink$1),
	  createSymlinkSync: createSymlinkSync$1
	};

	const {
	  createFile,
	  createFileSync
	} = file$1;
	const {
	  createLink,
	  createLinkSync
	} = link;
	const {
	  createSymlink,
	  createSymlinkSync
	} = symlink;
	var ensure = {
	  // file
	  createFile,
	  createFileSync,
	  ensureFile: createFile,
	  ensureFileSync: createFileSync,
	  // link
	  createLink,
	  createLinkSync,
	  ensureLink: createLink,
	  ensureLinkSync: createLinkSync,
	  // symlink
	  createSymlink,
	  createSymlinkSync,
	  ensureSymlink: createSymlink,
	  ensureSymlinkSync: createSymlinkSync
	};

	function stringify$3(obj, {
	  EOL = '\n',
	  finalEOL = true,
	  replacer = null,
	  spaces
	} = {}) {
	  const EOF = finalEOL ? EOL : '';
	  const str = JSON.stringify(obj, replacer, spaces);
	  return str.replace(/\n/g, EOL) + EOF;
	}
	function stripBom$1(content) {
	  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
	  if (Buffer.isBuffer(content)) content = content.toString('utf8');
	  return content.replace(/^\uFEFF/, '');
	}
	var utils = {
	  stringify: stringify$3,
	  stripBom: stripBom$1
	};

	let _fs;
	try {
	  _fs = gracefulFs;
	} catch (_) {
	  _fs = require$$2$2;
	}
	const universalify = universalify$1;
	const {
	  stringify: stringify$2,
	  stripBom
	} = utils;
	async function _readFile(file, options = {}) {
	  if (typeof options === 'string') {
	    options = {
	      encoding: options
	    };
	  }
	  const fs = options.fs || _fs;
	  const shouldThrow = 'throws' in options ? options.throws : true;
	  let data = await universalify.fromCallback(fs.readFile)(file, options);
	  data = stripBom(data);
	  let obj;
	  try {
	    obj = JSON.parse(data, options ? options.reviver : null);
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = `${file}: ${err.message}`;
	      throw err;
	    } else {
	      return null;
	    }
	  }
	  return obj;
	}
	const readFile = universalify.fromPromise(_readFile);
	function readFileSync(file, options = {}) {
	  if (typeof options === 'string') {
	    options = {
	      encoding: options
	    };
	  }
	  const fs = options.fs || _fs;
	  const shouldThrow = 'throws' in options ? options.throws : true;
	  try {
	    let content = fs.readFileSync(file, options);
	    content = stripBom(content);
	    return JSON.parse(content, options.reviver);
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = `${file}: ${err.message}`;
	      throw err;
	    } else {
	      return null;
	    }
	  }
	}
	async function _writeFile(file, obj, options = {}) {
	  const fs = options.fs || _fs;
	  const str = stringify$2(obj, options);
	  await universalify.fromCallback(fs.writeFile)(file, str, options);
	}
	const writeFile$1 = universalify.fromPromise(_writeFile);
	function writeFileSync(file, obj, options = {}) {
	  const fs = options.fs || _fs;
	  const str = stringify$2(obj, options);
	  // not sure if fs.writeFileSync returns anything, but just in case
	  return fs.writeFileSync(file, str, options);
	}
	const jsonfile$1 = {
	  readFile,
	  readFileSync,
	  writeFile: writeFile$1,
	  writeFileSync
	};
	var jsonfile_1 = jsonfile$1;

	const jsonFile$1 = jsonfile_1;
	var jsonfile = {
	  // jsonfile exports
	  readJson: jsonFile$1.readFile,
	  readJsonSync: jsonFile$1.readFileSync,
	  writeJson: jsonFile$1.writeFile,
	  writeJsonSync: jsonFile$1.writeFileSync
	};

	const u$2 = universalify$1.fromPromise;
	const fs$5 = fs$k;
	const path$3 = require$$1$4;
	const mkdir = mkdirs$2;
	const pathExists$1 = pathExists_1.pathExists;
	async function outputFile$1(file, data, encoding = 'utf-8') {
	  const dir = path$3.dirname(file);
	  if (!(await pathExists$1(dir))) {
	    await mkdir.mkdirs(dir);
	  }
	  return fs$5.writeFile(file, data, encoding);
	}
	function outputFileSync$1(file, ...args) {
	  const dir = path$3.dirname(file);
	  if (!fs$5.existsSync(dir)) {
	    mkdir.mkdirsSync(dir);
	  }
	  fs$5.writeFileSync(file, ...args);
	}
	var outputFile_1 = {
	  outputFile: u$2(outputFile$1),
	  outputFileSync: outputFileSync$1
	};

	const {
	  stringify: stringify$1
	} = utils;
	const {
	  outputFile
	} = outputFile_1;
	async function outputJson(file, data, options = {}) {
	  const str = stringify$1(data, options);
	  await outputFile(file, str, options);
	}
	var outputJson_1 = outputJson;

	const {
	  stringify
	} = utils;
	const {
	  outputFileSync
	} = outputFile_1;
	function outputJsonSync(file, data, options) {
	  const str = stringify(data, options);
	  outputFileSync(file, str, options);
	}
	var outputJsonSync_1 = outputJsonSync;

	const u$1 = universalify$1.fromPromise;
	const jsonFile = jsonfile;
	jsonFile.outputJson = u$1(outputJson_1);
	jsonFile.outputJsonSync = outputJsonSync_1;
	// aliases
	jsonFile.outputJSON = jsonFile.outputJson;
	jsonFile.outputJSONSync = jsonFile.outputJsonSync;
	jsonFile.writeJSON = jsonFile.writeJson;
	jsonFile.writeJSONSync = jsonFile.writeJsonSync;
	jsonFile.readJSON = jsonFile.readJson;
	jsonFile.readJSONSync = jsonFile.readJsonSync;
	var json = jsonFile;

	const fs$4 = fs$k;
	const path$2 = require$$1$4;
	const {
	  copy
	} = copy$1;
	const {
	  remove
	} = remove_1;
	const {
	  mkdirp
	} = mkdirs$2;
	const {
	  pathExists
	} = pathExists_1;
	const stat$1 = stat$4;
	async function move$1(src, dest, opts = {}) {
	  const overwrite = opts.overwrite || opts.clobber || false;
	  const {
	    srcStat,
	    isChangingCase = false
	  } = await stat$1.checkPaths(src, dest, 'move', opts);
	  await stat$1.checkParentPaths(src, srcStat, dest, 'move');

	  // If the parent of dest is not root, make sure it exists before proceeding
	  const destParent = path$2.dirname(dest);
	  const parsedParentPath = path$2.parse(destParent);
	  if (parsedParentPath.root !== destParent) {
	    await mkdirp(destParent);
	  }
	  return doRename$1(src, dest, overwrite, isChangingCase);
	}
	async function doRename$1(src, dest, overwrite, isChangingCase) {
	  if (!isChangingCase) {
	    if (overwrite) {
	      await remove(dest);
	    } else if (await pathExists(dest)) {
	      throw new Error('dest already exists.');
	    }
	  }
	  try {
	    // Try w/ rename first, and try copy + remove if EXDEV
	    await fs$4.rename(src, dest);
	  } catch (err) {
	    if (err.code !== 'EXDEV') {
	      throw err;
	    }
	    await moveAcrossDevice$1(src, dest, overwrite);
	  }
	}
	async function moveAcrossDevice$1(src, dest, overwrite) {
	  const opts = {
	    overwrite,
	    errorOnExist: true,
	    preserveTimestamps: true
	  };
	  await copy(src, dest, opts);
	  return remove(src);
	}
	var move_1 = move$1;

	const fs$3 = gracefulFs;
	const path$1 = require$$1$4;
	const copySync = copy$1.copySync;
	const removeSync = remove_1.removeSync;
	const mkdirpSync = mkdirs$2.mkdirpSync;
	const stat = stat$4;
	function moveSync(src, dest, opts) {
	  opts = opts || {};
	  const overwrite = opts.overwrite || opts.clobber || false;
	  const {
	    srcStat,
	    isChangingCase = false
	  } = stat.checkPathsSync(src, dest, 'move', opts);
	  stat.checkParentPathsSync(src, srcStat, dest, 'move');
	  if (!isParentRoot(dest)) mkdirpSync(path$1.dirname(dest));
	  return doRename(src, dest, overwrite, isChangingCase);
	}
	function isParentRoot(dest) {
	  const parent = path$1.dirname(dest);
	  const parsedPath = path$1.parse(parent);
	  return parsedPath.root === parent;
	}
	function doRename(src, dest, overwrite, isChangingCase) {
	  if (isChangingCase) return rename(src, dest, overwrite);
	  if (overwrite) {
	    removeSync(dest);
	    return rename(src, dest, overwrite);
	  }
	  if (fs$3.existsSync(dest)) throw new Error('dest already exists.');
	  return rename(src, dest, overwrite);
	}
	function rename(src, dest, overwrite) {
	  try {
	    fs$3.renameSync(src, dest);
	  } catch (err) {
	    if (err.code !== 'EXDEV') throw err;
	    return moveAcrossDevice(src, dest, overwrite);
	  }
	}
	function moveAcrossDevice(src, dest, overwrite) {
	  const opts = {
	    overwrite,
	    errorOnExist: true,
	    preserveTimestamps: true
	  };
	  copySync(src, dest, opts);
	  return removeSync(src);
	}
	var moveSync_1 = moveSync;

	const u = universalify$1.fromPromise;
	var move = {
	  move: u(move_1),
	  moveSync: moveSync_1
	};

	var lib$2 = {
	  // Export promiseified graceful-fs:
	  ...fs$k,
	  // Export extra methods:
	  ...copy$1,
	  ...empty$1,
	  ...ensure,
	  ...json,
	  ...mkdirs$2,
	  ...move,
	  ...outputFile_1,
	  ...pathExists_1,
	  ...remove_1
	};
	var fs$2 = /*@__PURE__*/getDefaultExportFromCjs(lib$2);

	// import { readFileSync } from "fs";
	require("node:fs");
	const existsDir = async path => {
	  try {
	    const exists = await fs$2.pathExists(path);
	    return exists;
	  } catch (err) {
	    cError(`Check directory existence failed: ${err}`);
	    throw err;
	  }
	};
	const removeDir = async (path, showResult = false) => {
	  try {
	    await fs$2.remove(path);
	    showResult && cSuccess(`Successfully remove directory: ${path}`);
	  } catch (err) {
	    cError(`Remove directory failed: ${err}`);
	    throw err;
	  }
	};
	const writeFile = async (dir, flieName, fileContent) => {
	  try {
	    const filePath = path$e.join(dir, flieName);
	    const isExistsDir = await existsDir(filePath);
	    if (isExistsDir) await removeDir(filePath);
	    fs$2.ensureDirSync(path$e.dirname(filePath));
	    fs$2.writeFileSync(filePath, fileContent);
	  } catch (err) {
	    cError(`Write File failed: ${err}`);
	    throw err;
	  }
	};

	function helpOptions(_x) {
	  return _helpOptions.apply(this, arguments);
	}
	function _helpOptions() {
	  _helpOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(program) {
	    var pkg;
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return resolvePkg(process.cwd());
	        case 2:
	          pkg = _context.sent;
	          program.name(pkg.name);
	          program.version(pkg.version);
	          program.usage("<command> [option]");
	        case 6:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee);
	  }));
	  return _helpOptions.apply(this, arguments);
	}

	// process.env dot-notation access prints:
	// Property 'TERM' comes from an index signature, so it must be accessed with ['TERM'].ts(4111)
	/* eslint dot-notation: ["off"] */
	// Ported from is-unicode-supported
	function isUnicodeSupported$3() {
	  if (process$4.platform !== 'win32') {
	    return process$4.env['TERM'] !== 'linux'; // Linux console (kernel)
	  }
	  return Boolean(process$4.env['WT_SESSION']) ||
	  // Windows Terminal
	  Boolean(process$4.env['TERMINUS_SUBLIME']) ||
	  // Terminus (<0.2.27)
	  process$4.env['ConEmuTask'] === '{cmd::Cmder}' ||
	  // ConEmu and cmder
	  process$4.env['TERM_PROGRAM'] === 'Terminus-Sublime' || process$4.env['TERM_PROGRAM'] === 'vscode' || process$4.env['TERM'] === 'xterm-256color' || process$4.env['TERM'] === 'alacritty' || process$4.env['TERMINAL_EMULATOR'] === 'JetBrains-JediTerm';
	}
	// Ported from figures
	const common = {
	  circleQuestionMark: '(?)',
	  questionMarkPrefix: '(?)',
	  square: '',
	  squareDarkShade: '',
	  squareMediumShade: '',
	  squareLightShade: '',
	  squareTop: '',
	  squareBottom: '',
	  squareLeft: '',
	  squareRight: '',
	  squareCenter: '',
	  bullet: '',
	  dot: '',
	  ellipsis: '',
	  pointerSmall: '',
	  triangleUp: '',
	  triangleUpSmall: '',
	  triangleDown: '',
	  triangleDownSmall: '',
	  triangleLeftSmall: '',
	  triangleRightSmall: '',
	  home: '',
	  heart: '',
	  musicNote: '',
	  musicNoteBeamed: '',
	  arrowUp: '',
	  arrowDown: '',
	  arrowLeft: '',
	  arrowRight: '',
	  arrowLeftRight: '',
	  arrowUpDown: '',
	  almostEqual: '',
	  notEqual: '',
	  lessOrEqual: '',
	  greaterOrEqual: '',
	  identical: '',
	  infinity: '',
	  subscriptZero: '',
	  subscriptOne: '',
	  subscriptTwo: '',
	  subscriptThree: '',
	  subscriptFour: '',
	  subscriptFive: '',
	  subscriptSix: '',
	  subscriptSeven: '',
	  subscriptEight: '',
	  subscriptNine: '',
	  oneHalf: '',
	  oneThird: '',
	  oneQuarter: '',
	  oneFifth: '',
	  oneSixth: '',
	  oneEighth: '',
	  twoThirds: '',
	  twoFifths: '',
	  threeQuarters: '',
	  threeFifths: '',
	  threeEighths: '',
	  fourFifths: '',
	  fiveSixths: '',
	  fiveEighths: '',
	  sevenEighths: '',
	  line: '',
	  lineBold: '',
	  lineDouble: '',
	  lineDashed0: '',
	  lineDashed1: '',
	  lineDashed2: '',
	  lineDashed3: '',
	  lineDashed4: '',
	  lineDashed5: '',
	  lineDashed6: '',
	  lineDashed7: '',
	  lineDashed8: '',
	  lineDashed9: '',
	  lineDashed10: '',
	  lineDashed11: '',
	  lineDashed12: '',
	  lineDashed13: '',
	  lineDashed14: '',
	  lineDashed15: '',
	  lineVertical: '',
	  lineVerticalBold: '',
	  lineVerticalDouble: '',
	  lineVerticalDashed0: '',
	  lineVerticalDashed1: '',
	  lineVerticalDashed2: '',
	  lineVerticalDashed3: '',
	  lineVerticalDashed4: '',
	  lineVerticalDashed5: '',
	  lineVerticalDashed6: '',
	  lineVerticalDashed7: '',
	  lineVerticalDashed8: '',
	  lineVerticalDashed9: '',
	  lineVerticalDashed10: '',
	  lineVerticalDashed11: '',
	  lineDownLeft: '',
	  lineDownLeftArc: '',
	  lineDownBoldLeftBold: '',
	  lineDownBoldLeft: '',
	  lineDownLeftBold: '',
	  lineDownDoubleLeftDouble: '',
	  lineDownDoubleLeft: '',
	  lineDownLeftDouble: '',
	  lineDownRight: '',
	  lineDownRightArc: '',
	  lineDownBoldRightBold: '',
	  lineDownBoldRight: '',
	  lineDownRightBold: '',
	  lineDownDoubleRightDouble: '',
	  lineDownDoubleRight: '',
	  lineDownRightDouble: '',
	  lineUpLeft: '',
	  lineUpLeftArc: '',
	  lineUpBoldLeftBold: '',
	  lineUpBoldLeft: '',
	  lineUpLeftBold: '',
	  lineUpDoubleLeftDouble: '',
	  lineUpDoubleLeft: '',
	  lineUpLeftDouble: '',
	  lineUpRight: '',
	  lineUpRightArc: '',
	  lineUpBoldRightBold: '',
	  lineUpBoldRight: '',
	  lineUpRightBold: '',
	  lineUpDoubleRightDouble: '',
	  lineUpDoubleRight: '',
	  lineUpRightDouble: '',
	  lineUpDownLeft: '',
	  lineUpBoldDownBoldLeftBold: '',
	  lineUpBoldDownBoldLeft: '',
	  lineUpDownLeftBold: '',
	  lineUpBoldDownLeftBold: '',
	  lineUpDownBoldLeftBold: '',
	  lineUpDownBoldLeft: '',
	  lineUpBoldDownLeft: '',
	  lineUpDoubleDownDoubleLeftDouble: '',
	  lineUpDoubleDownDoubleLeft: '',
	  lineUpDownLeftDouble: '',
	  lineUpDownRight: '',
	  lineUpBoldDownBoldRightBold: '',
	  lineUpBoldDownBoldRight: '',
	  lineUpDownRightBold: '',
	  lineUpBoldDownRightBold: '',
	  lineUpDownBoldRightBold: '',
	  lineUpDownBoldRight: '',
	  lineUpBoldDownRight: '',
	  lineUpDoubleDownDoubleRightDouble: '',
	  lineUpDoubleDownDoubleRight: '',
	  lineUpDownRightDouble: '',
	  lineDownLeftRight: '',
	  lineDownBoldLeftBoldRightBold: '',
	  lineDownLeftBoldRightBold: '',
	  lineDownBoldLeftRight: '',
	  lineDownBoldLeftBoldRight: '',
	  lineDownBoldLeftRightBold: '',
	  lineDownLeftRightBold: '',
	  lineDownLeftBoldRight: '',
	  lineDownDoubleLeftDoubleRightDouble: '',
	  lineDownDoubleLeftRight: '',
	  lineDownLeftDoubleRightDouble: '',
	  lineUpLeftRight: '',
	  lineUpBoldLeftBoldRightBold: '',
	  lineUpLeftBoldRightBold: '',
	  lineUpBoldLeftRight: '',
	  lineUpBoldLeftBoldRight: '',
	  lineUpBoldLeftRightBold: '',
	  lineUpLeftRightBold: '',
	  lineUpLeftBoldRight: '',
	  lineUpDoubleLeftDoubleRightDouble: '',
	  lineUpDoubleLeftRight: '',
	  lineUpLeftDoubleRightDouble: '',
	  lineUpDownLeftRight: '',
	  lineUpBoldDownBoldLeftBoldRightBold: '',
	  lineUpDownBoldLeftBoldRightBold: '',
	  lineUpBoldDownLeftBoldRightBold: '',
	  lineUpBoldDownBoldLeftRightBold: '',
	  lineUpBoldDownBoldLeftBoldRight: '',
	  lineUpBoldDownLeftRight: '',
	  lineUpDownBoldLeftRight: '',
	  lineUpDownLeftBoldRight: '',
	  lineUpDownLeftRightBold: '',
	  lineUpBoldDownBoldLeftRight: '',
	  lineUpDownLeftBoldRightBold: '',
	  lineUpBoldDownLeftBoldRight: '',
	  lineUpBoldDownLeftRightBold: '',
	  lineUpDownBoldLeftBoldRight: '',
	  lineUpDownBoldLeftRightBold: '',
	  lineUpDoubleDownDoubleLeftDoubleRightDouble: '',
	  lineUpDoubleDownDoubleLeftRight: '',
	  lineUpDownLeftDoubleRightDouble: '',
	  lineCross: '',
	  lineBackslash: '',
	  lineSlash: ''
	};
	const specialMainSymbols = {
	  tick: '',
	  info: '',
	  warning: '',
	  cross: '',
	  squareSmall: '',
	  squareSmallFilled: '',
	  circle: '',
	  circleFilled: '',
	  circleDotted: '',
	  circleDouble: '',
	  circleCircle: '',
	  circleCross: '',
	  circlePipe: '',
	  radioOn: '',
	  radioOff: '',
	  checkboxOn: '',
	  checkboxOff: '',
	  checkboxCircleOn: '',
	  checkboxCircleOff: '',
	  pointer: '',
	  triangleUpOutline: '',
	  triangleLeft: '',
	  triangleRight: '',
	  lozenge: '',
	  lozengeOutline: '',
	  hamburger: '',
	  smiley: '',
	  mustache: '',
	  star: '',
	  play: '',
	  nodejs: '',
	  oneSeventh: '',
	  oneNinth: '',
	  oneTenth: ''
	};
	const specialFallbackSymbols = {
	  tick: '',
	  info: 'i',
	  warning: '',
	  cross: '',
	  squareSmall: '',
	  squareSmallFilled: '',
	  circle: '( )',
	  circleFilled: '(*)',
	  circleDotted: '( )',
	  circleDouble: '( )',
	  circleCircle: '()',
	  circleCross: '()',
	  circlePipe: '()',
	  radioOn: '(*)',
	  radioOff: '( )',
	  checkboxOn: '[]',
	  checkboxOff: '[ ]',
	  checkboxCircleOn: '()',
	  checkboxCircleOff: '( )',
	  pointer: '>',
	  triangleUpOutline: '',
	  triangleLeft: '',
	  triangleRight: '',
	  lozenge: '',
	  lozengeOutline: '',
	  hamburger: '',
	  smiley: '',
	  mustache: '',
	  star: '',
	  play: '',
	  nodejs: '',
	  oneSeventh: '1/7',
	  oneNinth: '1/9',
	  oneTenth: '1/10'
	};
	const mainSymbols = {
	  ...common,
	  ...specialMainSymbols
	};
	const fallbackSymbols = {
	  ...common,
	  ...specialFallbackSymbols
	};
	const shouldUseMain = isUnicodeSupported$3();
	const figures = shouldUseMain ? mainSymbols : fallbackSymbols;

	var cliCursor$2 = {};

	const onetime = onetimeExports;
	const signalExit = signalExitExports;
	var restoreCursor = onetime(() => {
	  signalExit(() => {
	    process.stderr.write('\u001B[?25h');
	  }, {
	    alwaysLast: true
	  });
	});

	(function (exports) {

	  const restoreCursor$1 = restoreCursor;
	  let isHidden = false;
	  exports.show = (writableStream = process.stderr) => {
	    if (!writableStream.isTTY) {
	      return;
	    }
	    isHidden = false;
	    writableStream.write('\u001B[?25h');
	  };
	  exports.hide = (writableStream = process.stderr) => {
	    if (!writableStream.isTTY) {
	      return;
	    }
	    restoreCursor$1();
	    isHidden = true;
	    writableStream.write('\u001B[?25l');
	  };
	  exports.toggle = (force, writableStream) => {
	    if (force !== undefined) {
	      isHidden = force;
	    }
	    if (isHidden) {
	      exports.show(writableStream);
	    } else {
	      exports.hide(writableStream);
	    }
	  };
	})(cliCursor$2);
	var cliCursor$1 = /*@__PURE__*/getDefaultExportFromCjs(cliCursor$2);

	var runAsync$2 = {exports: {}};

	function isPromise$1(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}

	/**
	 * Return a function that will run a function asynchronously or synchronously
	 *
	 * example:
	 * runAsync(wrappedFunction, callback)(...args);
	 *
	 * @param   {Function} func  Function to run
	 * @param   {Function} [cb]    Callback function passed the `func` returned value
	 * @param   {string} [proxyProperty] `this` property to be used for the callback factory
	 * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn
	 *                                return a Promise (Node >= 0.12) or call the callbacks.
	 */

	var runAsync = runAsync$2.exports = function (func, cb, proxyProperty = 'async') {
	  if (typeof cb === 'string') {
	    proxyProperty = cb;
	    cb = undefined;
	  }
	  cb = cb || function () {};
	  return function () {
	    var args = arguments;
	    var originalThis = this;
	    var promise = new Promise(function (resolve, reject) {
	      var resolved = false;
	      const wrappedResolve = function (value) {
	        if (resolved) {
	          console.warn('Run-async promise already resolved.');
	        }
	        resolved = true;
	        resolve(value);
	      };
	      var rejected = false;
	      const wrappedReject = function (value) {
	        if (rejected) {
	          console.warn('Run-async promise already rejected.');
	        }
	        rejected = true;
	        reject(value);
	      };
	      var usingCallback = false;
	      var callbackConflict = false;
	      var contextEnded = false;
	      var doneFactory = function () {
	        if (contextEnded) {
	          console.warn('Run-async async() called outside a valid run-async context, callback will be ignored.');
	          return function () {};
	        }
	        if (callbackConflict) {
	          console.warn('Run-async wrapped function (async) returned a promise.\nCalls to async() callback can have unexpected results.');
	        }
	        usingCallback = true;
	        return function (err, value) {
	          if (err) {
	            wrappedReject(err);
	          } else {
	            wrappedResolve(value);
	          }
	        };
	      };
	      var _this;
	      if (originalThis && proxyProperty && Proxy) {
	        _this = new Proxy(originalThis, {
	          get(_target, prop) {
	            if (prop === proxyProperty) {
	              if (prop in _target) {
	                console.warn(`${proxyProperty} property is been shadowed by run-sync`);
	              }
	              return doneFactory;
	            }
	            return Reflect.get(...arguments);
	          }
	        });
	      } else {
	        _this = {
	          [proxyProperty]: doneFactory
	        };
	      }
	      var answer = func.apply(_this, Array.prototype.slice.call(args));
	      if (usingCallback) {
	        if (isPromise$1(answer)) {
	          console.warn('Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.');
	        }
	      } else {
	        if (isPromise$1(answer)) {
	          callbackConflict = true;
	          answer.then(wrappedResolve, wrappedReject);
	        } else {
	          wrappedResolve(answer);
	        }
	      }
	      contextEnded = true;
	    });
	    promise.then(cb.bind(null, null), cb);
	    return promise;
	  };
	};
	runAsync.cb = function (func, cb) {
	  return runAsync(function () {
	    var args = Array.prototype.slice.call(arguments);
	    if (args.length === func.length - 1) {
	      args.push(this.async());
	    }
	    return func.apply(this, args);
	  }, cb);
	};
	var runAsyncExports = runAsync$2.exports;
	var runAsync$1 = /*@__PURE__*/getDefaultExportFromCjs(runAsyncExports);

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */

	var extendStatics = function (d, b) {
	  extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	  };
	  return extendStatics(d, b);
	};
	function __extends$4(d, b) {
	  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	  extendStatics(d, b);
	  function __() {
	    this.constructor = d;
	  }
	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	function __awaiter(thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }
	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	}
	function __generator(thisArg, body) {
	  var _ = {
	      label: 0,
	      sent: function () {
	        if (t[0] & 1) throw t[1];
	        return t[1];
	      },
	      trys: [],
	      ops: []
	    },
	    f,
	    y,
	    t,
	    g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
	    return this;
	  }), g;
	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }
	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");
	    while (g && (g = 0, op[0] && (_ = 0)), _) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];
	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;
	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };
	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;
	        case 7:
	          op = _.ops.pop();
	          _.trys.pop();
	          continue;
	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }
	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }
	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }
	          if (t && _.label < t[2]) {
	            _.label = t[2];
	            _.ops.push(op);
	            break;
	          }
	          if (t[2]) _.ops.pop();
	          _.trys.pop();
	          continue;
	      }
	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }
	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	}
	function __values(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function () {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __read(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	}
	function __spreadArray(to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	}
	function __await(v) {
	  return this instanceof __await ? (this.v = v, this) : new __await(v);
	}
	function __asyncGenerator(thisArg, _arguments, generator) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var g = generator.apply(thisArg, _arguments || []),
	    i,
	    q = [];
	  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i;
	  function verb(n) {
	    if (g[n]) i[n] = function (v) {
	      return new Promise(function (a, b) {
	        q.push([n, v, a, b]) > 1 || resume(n, v);
	      });
	    };
	  }
	  function resume(n, v) {
	    try {
	      step(g[n](v));
	    } catch (e) {
	      settle(q[0][3], e);
	    }
	  }
	  function step(r) {
	    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
	  }
	  function fulfill(value) {
	    resume("next", value);
	  }
	  function reject(value) {
	    resume("throw", value);
	  }
	  function settle(f, v) {
	    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	  }
	}
	function __asyncValues(o) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var m = o[Symbol.asyncIterator],
	    i;
	  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i);
	  function verb(n) {
	    i[n] = o[n] && function (v) {
	      return new Promise(function (resolve, reject) {
	        v = o[n](v), settle(resolve, reject, v.done, v.value);
	      });
	    };
	  }
	  function settle(resolve, reject, d, v) {
	    Promise.resolve(v).then(function (v) {
	      resolve({
	        value: v,
	        done: d
	      });
	    }, reject);
	  }
	}
	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	  var e = new Error(message);
	  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	function isFunction$3(value) {
	  return typeof value === 'function';
	}

	function createErrorClass(createImpl) {
	  var _super = function (instance) {
	    Error.call(instance);
	    instance.stack = new Error().stack;
	  };
	  var ctorFunc = createImpl(_super);
	  ctorFunc.prototype = Object.create(Error.prototype);
	  ctorFunc.prototype.constructor = ctorFunc;
	  return ctorFunc;
	}

	var UnsubscriptionError = createErrorClass(function (_super) {
	  return function UnsubscriptionErrorImpl(errors) {
	    _super(this);
	    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
	      return i + 1 + ") " + err.toString();
	    }).join('\n  ') : '';
	    this.name = 'UnsubscriptionError';
	    this.errors = errors;
	  };
	});

	function arrRemove(arr, item) {
	  if (arr) {
	    var index = arr.indexOf(item);
	    0 <= index && arr.splice(index, 1);
	  }
	}

	var Subscription = function () {
	  function Subscription(initialTeardown) {
	    this.initialTeardown = initialTeardown;
	    this.closed = false;
	    this._parentage = null;
	    this._finalizers = null;
	  }
	  Subscription.prototype.unsubscribe = function () {
	    var e_1, _a, e_2, _b;
	    var errors;
	    if (!this.closed) {
	      this.closed = true;
	      var _parentage = this._parentage;
	      if (_parentage) {
	        this._parentage = null;
	        if (Array.isArray(_parentage)) {
	          try {
	            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
	              var parent_1 = _parentage_1_1.value;
	              parent_1.remove(this);
	            }
	          } catch (e_1_1) {
	            e_1 = {
	              error: e_1_1
	            };
	          } finally {
	            try {
	              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
	            } finally {
	              if (e_1) throw e_1.error;
	            }
	          }
	        } else {
	          _parentage.remove(this);
	        }
	      }
	      var initialFinalizer = this.initialTeardown;
	      if (isFunction$3(initialFinalizer)) {
	        try {
	          initialFinalizer();
	        } catch (e) {
	          errors = e instanceof UnsubscriptionError ? e.errors : [e];
	        }
	      }
	      var _finalizers = this._finalizers;
	      if (_finalizers) {
	        this._finalizers = null;
	        try {
	          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
	            var finalizer = _finalizers_1_1.value;
	            try {
	              execFinalizer(finalizer);
	            } catch (err) {
	              errors = errors !== null && errors !== void 0 ? errors : [];
	              if (err instanceof UnsubscriptionError) {
	                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
	              } else {
	                errors.push(err);
	              }
	            }
	          }
	        } catch (e_2_1) {
	          e_2 = {
	            error: e_2_1
	          };
	        } finally {
	          try {
	            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
	          } finally {
	            if (e_2) throw e_2.error;
	          }
	        }
	      }
	      if (errors) {
	        throw new UnsubscriptionError(errors);
	      }
	    }
	  };
	  Subscription.prototype.add = function (teardown) {
	    var _a;
	    if (teardown && teardown !== this) {
	      if (this.closed) {
	        execFinalizer(teardown);
	      } else {
	        if (teardown instanceof Subscription) {
	          if (teardown.closed || teardown._hasParent(this)) {
	            return;
	          }
	          teardown._addParent(this);
	        }
	        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
	      }
	    }
	  };
	  Subscription.prototype._hasParent = function (parent) {
	    var _parentage = this._parentage;
	    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
	  };
	  Subscription.prototype._addParent = function (parent) {
	    var _parentage = this._parentage;
	    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
	  };
	  Subscription.prototype._removeParent = function (parent) {
	    var _parentage = this._parentage;
	    if (_parentage === parent) {
	      this._parentage = null;
	    } else if (Array.isArray(_parentage)) {
	      arrRemove(_parentage, parent);
	    }
	  };
	  Subscription.prototype.remove = function (teardown) {
	    var _finalizers = this._finalizers;
	    _finalizers && arrRemove(_finalizers, teardown);
	    if (teardown instanceof Subscription) {
	      teardown._removeParent(this);
	    }
	  };
	  Subscription.EMPTY = function () {
	    var empty = new Subscription();
	    empty.closed = true;
	    return empty;
	  }();
	  return Subscription;
	}();
	var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
	function isSubscription(value) {
	  return value instanceof Subscription || value && 'closed' in value && isFunction$3(value.remove) && isFunction$3(value.add) && isFunction$3(value.unsubscribe);
	}
	function execFinalizer(finalizer) {
	  if (isFunction$3(finalizer)) {
	    finalizer();
	  } else {
	    finalizer.unsubscribe();
	  }
	}

	var config = {
	  onUnhandledError: null,
	  onStoppedNotification: null,
	  Promise: undefined,
	  useDeprecatedSynchronousErrorHandling: false,
	  useDeprecatedNextContext: false
	};

	var timeoutProvider = {
	  setTimeout: function (handler, timeout) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	      args[_i - 2] = arguments[_i];
	    }
	    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
	  },
	  clearTimeout: function (handle) {
	    var delegate = timeoutProvider.delegate;
	    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
	  },
	  delegate: undefined
	};

	function reportUnhandledError(err) {
	  timeoutProvider.setTimeout(function () {
	    {
	      throw err;
	    }
	  });
	}

	function noop() {}

	function errorContext(cb) {
	  {
	    cb();
	  }
	}

	var Subscriber = function (_super) {
	  __extends$4(Subscriber, _super);
	  function Subscriber(destination) {
	    var _this = _super.call(this) || this;
	    _this.isStopped = false;
	    if (destination) {
	      _this.destination = destination;
	      if (isSubscription(destination)) {
	        destination.add(_this);
	      }
	    } else {
	      _this.destination = EMPTY_OBSERVER;
	    }
	    return _this;
	  }
	  Subscriber.create = function (next, error, complete) {
	    return new SafeSubscriber(next, error, complete);
	  };
	  Subscriber.prototype.next = function (value) {
	    if (this.isStopped) ; else {
	      this._next(value);
	    }
	  };
	  Subscriber.prototype.error = function (err) {
	    if (this.isStopped) ; else {
	      this.isStopped = true;
	      this._error(err);
	    }
	  };
	  Subscriber.prototype.complete = function () {
	    if (this.isStopped) ; else {
	      this.isStopped = true;
	      this._complete();
	    }
	  };
	  Subscriber.prototype.unsubscribe = function () {
	    if (!this.closed) {
	      this.isStopped = true;
	      _super.prototype.unsubscribe.call(this);
	      this.destination = null;
	    }
	  };
	  Subscriber.prototype._next = function (value) {
	    this.destination.next(value);
	  };
	  Subscriber.prototype._error = function (err) {
	    try {
	      this.destination.error(err);
	    } finally {
	      this.unsubscribe();
	    }
	  };
	  Subscriber.prototype._complete = function () {
	    try {
	      this.destination.complete();
	    } finally {
	      this.unsubscribe();
	    }
	  };
	  return Subscriber;
	}(Subscription);
	var _bind = Function.prototype.bind;
	function bind$2(fn, thisArg) {
	  return _bind.call(fn, thisArg);
	}
	var ConsumerObserver = function () {
	  function ConsumerObserver(partialObserver) {
	    this.partialObserver = partialObserver;
	  }
	  ConsumerObserver.prototype.next = function (value) {
	    var partialObserver = this.partialObserver;
	    if (partialObserver.next) {
	      try {
	        partialObserver.next(value);
	      } catch (error) {
	        handleUnhandledError(error);
	      }
	    }
	  };
	  ConsumerObserver.prototype.error = function (err) {
	    var partialObserver = this.partialObserver;
	    if (partialObserver.error) {
	      try {
	        partialObserver.error(err);
	      } catch (error) {
	        handleUnhandledError(error);
	      }
	    } else {
	      handleUnhandledError(err);
	    }
	  };
	  ConsumerObserver.prototype.complete = function () {
	    var partialObserver = this.partialObserver;
	    if (partialObserver.complete) {
	      try {
	        partialObserver.complete();
	      } catch (error) {
	        handleUnhandledError(error);
	      }
	    }
	  };
	  return ConsumerObserver;
	}();
	var SafeSubscriber = function (_super) {
	  __extends$4(SafeSubscriber, _super);
	  function SafeSubscriber(observerOrNext, error, complete) {
	    var _this = _super.call(this) || this;
	    var partialObserver;
	    if (isFunction$3(observerOrNext) || !observerOrNext) {
	      partialObserver = {
	        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
	        error: error !== null && error !== void 0 ? error : undefined,
	        complete: complete !== null && complete !== void 0 ? complete : undefined
	      };
	    } else {
	      var context_1;
	      if (_this && config.useDeprecatedNextContext) {
	        context_1 = Object.create(observerOrNext);
	        context_1.unsubscribe = function () {
	          return _this.unsubscribe();
	        };
	        partialObserver = {
	          next: observerOrNext.next && bind$2(observerOrNext.next, context_1),
	          error: observerOrNext.error && bind$2(observerOrNext.error, context_1),
	          complete: observerOrNext.complete && bind$2(observerOrNext.complete, context_1)
	        };
	      } else {
	        partialObserver = observerOrNext;
	      }
	    }
	    _this.destination = new ConsumerObserver(partialObserver);
	    return _this;
	  }
	  return SafeSubscriber;
	}(Subscriber);
	function handleUnhandledError(error) {
	  {
	    reportUnhandledError(error);
	  }
	}
	function defaultErrorHandler(err) {
	  throw err;
	}
	var EMPTY_OBSERVER = {
	  closed: true,
	  next: noop,
	  error: defaultErrorHandler,
	  complete: noop
	};

	var observable = function () {
	  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
	}();

	function identity$4(x) {
	  return x;
	}

	function pipeFromArray(fns) {
	  if (fns.length === 0) {
	    return identity$4;
	  }
	  if (fns.length === 1) {
	    return fns[0];
	  }
	  return function piped(input) {
	    return fns.reduce(function (prev, fn) {
	      return fn(prev);
	    }, input);
	  };
	}

	var Observable = function () {
	  function Observable(subscribe) {
	    if (subscribe) {
	      this._subscribe = subscribe;
	    }
	  }
	  Observable.prototype.lift = function (operator) {
	    var observable = new Observable();
	    observable.source = this;
	    observable.operator = operator;
	    return observable;
	  };
	  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	    var _this = this;
	    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
	    errorContext(function () {
	      var _a = _this,
	        operator = _a.operator,
	        source = _a.source;
	      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
	    });
	    return subscriber;
	  };
	  Observable.prototype._trySubscribe = function (sink) {
	    try {
	      return this._subscribe(sink);
	    } catch (err) {
	      sink.error(err);
	    }
	  };
	  Observable.prototype.forEach = function (next, promiseCtor) {
	    var _this = this;
	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var subscriber = new SafeSubscriber({
	        next: function (value) {
	          try {
	            next(value);
	          } catch (err) {
	            reject(err);
	            subscriber.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	      _this.subscribe(subscriber);
	    });
	  };
	  Observable.prototype._subscribe = function (subscriber) {
	    var _a;
	    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
	  };
	  Observable.prototype[observable] = function () {
	    return this;
	  };
	  Observable.prototype.pipe = function () {
	    var operations = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	      operations[_i] = arguments[_i];
	    }
	    return pipeFromArray(operations)(this);
	  };
	  Observable.prototype.toPromise = function (promiseCtor) {
	    var _this = this;
	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var value;
	      _this.subscribe(function (x) {
	        return value = x;
	      }, function (err) {
	        return reject(err);
	      }, function () {
	        return resolve(value);
	      });
	    });
	  };
	  Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	  };
	  return Observable;
	}();
	function getPromiseCtor(promiseCtor) {
	  var _a;
	  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
	  return value && isFunction$3(value.next) && isFunction$3(value.error) && isFunction$3(value.complete);
	}
	function isSubscriber(value) {
	  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
	}

	function hasLift(source) {
	  return isFunction$3(source === null || source === void 0 ? void 0 : source.lift);
	}
	function operate(init) {
	  return function (source) {
	    if (hasLift(source)) {
	      return source.lift(function (liftedSource) {
	        try {
	          return init(liftedSource, this);
	        } catch (err) {
	          this.error(err);
	        }
	      });
	    }
	    throw new TypeError('Unable to lift unknown Observable type');
	  };
	}

	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
	  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
	}
	var OperatorSubscriber = function (_super) {
	  __extends$4(OperatorSubscriber, _super);
	  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
	    var _this = _super.call(this, destination) || this;
	    _this.onFinalize = onFinalize;
	    _this.shouldUnsubscribe = shouldUnsubscribe;
	    _this._next = onNext ? function (value) {
	      try {
	        onNext(value);
	      } catch (err) {
	        destination.error(err);
	      }
	    } : _super.prototype._next;
	    _this._error = onError ? function (err) {
	      try {
	        onError(err);
	      } catch (err) {
	        destination.error(err);
	      } finally {
	        this.unsubscribe();
	      }
	    } : _super.prototype._error;
	    _this._complete = onComplete ? function () {
	      try {
	        onComplete();
	      } catch (err) {
	        destination.error(err);
	      } finally {
	        this.unsubscribe();
	      }
	    } : _super.prototype._complete;
	    return _this;
	  }
	  OperatorSubscriber.prototype.unsubscribe = function () {
	    var _a;
	    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
	      var closed_1 = this.closed;
	      _super.prototype.unsubscribe.call(this);
	      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
	    }
	  };
	  return OperatorSubscriber;
	}(Subscriber);

	function refCount() {
	  return operate(function (source, subscriber) {
	    var connection = null;
	    source._refCount++;
	    var refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
	      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
	        connection = null;
	        return;
	      }
	      var sharedConnection = source._connection;
	      var conn = connection;
	      connection = null;
	      if (sharedConnection && (!conn || sharedConnection === conn)) {
	        sharedConnection.unsubscribe();
	      }
	      subscriber.unsubscribe();
	    });
	    source.subscribe(refCounter);
	    if (!refCounter.closed) {
	      connection = source.connect();
	    }
	  });
	}

	var ConnectableObservable = function (_super) {
	  __extends$4(ConnectableObservable, _super);
	  function ConnectableObservable(source, subjectFactory) {
	    var _this = _super.call(this) || this;
	    _this.source = source;
	    _this.subjectFactory = subjectFactory;
	    _this._subject = null;
	    _this._refCount = 0;
	    _this._connection = null;
	    if (hasLift(source)) {
	      _this.lift = source.lift;
	    }
	    return _this;
	  }
	  ConnectableObservable.prototype._subscribe = function (subscriber) {
	    return this.getSubject().subscribe(subscriber);
	  };
	  ConnectableObservable.prototype.getSubject = function () {
	    var subject = this._subject;
	    if (!subject || subject.isStopped) {
	      this._subject = this.subjectFactory();
	    }
	    return this._subject;
	  };
	  ConnectableObservable.prototype._teardown = function () {
	    this._refCount = 0;
	    var _connection = this._connection;
	    this._subject = this._connection = null;
	    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
	  };
	  ConnectableObservable.prototype.connect = function () {
	    var _this = this;
	    var connection = this._connection;
	    if (!connection) {
	      connection = this._connection = new Subscription();
	      var subject_1 = this.getSubject();
	      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, undefined, function () {
	        _this._teardown();
	        subject_1.complete();
	      }, function (err) {
	        _this._teardown();
	        subject_1.error(err);
	      }, function () {
	        return _this._teardown();
	      })));
	      if (connection.closed) {
	        this._connection = null;
	        connection = Subscription.EMPTY;
	      }
	    }
	    return connection;
	  };
	  ConnectableObservable.prototype.refCount = function () {
	    return refCount()(this);
	  };
	  return ConnectableObservable;
	}(Observable);

	var ObjectUnsubscribedError = createErrorClass(function (_super) {
	  return function ObjectUnsubscribedErrorImpl() {
	    _super(this);
	    this.name = 'ObjectUnsubscribedError';
	    this.message = 'object unsubscribed';
	  };
	});

	var Subject = function (_super) {
	  __extends$4(Subject, _super);
	  function Subject() {
	    var _this = _super.call(this) || this;
	    _this.closed = false;
	    _this.currentObservers = null;
	    _this.observers = [];
	    _this.isStopped = false;
	    _this.hasError = false;
	    _this.thrownError = null;
	    return _this;
	  }
	  Subject.prototype.lift = function (operator) {
	    var subject = new AnonymousSubject(this, this);
	    subject.operator = operator;
	    return subject;
	  };
	  Subject.prototype._throwIfClosed = function () {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }
	  };
	  Subject.prototype.next = function (value) {
	    var _this = this;
	    errorContext(function () {
	      var e_1, _a;
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        if (!_this.currentObservers) {
	          _this.currentObservers = Array.from(_this.observers);
	        }
	        try {
	          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var observer = _c.value;
	            observer.next(value);
	          }
	        } catch (e_1_1) {
	          e_1 = {
	            error: e_1_1
	          };
	        } finally {
	          try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	          } finally {
	            if (e_1) throw e_1.error;
	          }
	        }
	      }
	    });
	  };
	  Subject.prototype.error = function (err) {
	    var _this = this;
	    errorContext(function () {
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        _this.hasError = _this.isStopped = true;
	        _this.thrownError = err;
	        var observers = _this.observers;
	        while (observers.length) {
	          observers.shift().error(err);
	        }
	      }
	    });
	  };
	  Subject.prototype.complete = function () {
	    var _this = this;
	    errorContext(function () {
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        _this.isStopped = true;
	        var observers = _this.observers;
	        while (observers.length) {
	          observers.shift().complete();
	        }
	      }
	    });
	  };
	  Subject.prototype.unsubscribe = function () {
	    this.isStopped = this.closed = true;
	    this.observers = this.currentObservers = null;
	  };
	  Object.defineProperty(Subject.prototype, "observed", {
	    get: function () {
	      var _a;
	      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Subject.prototype._trySubscribe = function (subscriber) {
	    this._throwIfClosed();
	    return _super.prototype._trySubscribe.call(this, subscriber);
	  };
	  Subject.prototype._subscribe = function (subscriber) {
	    this._throwIfClosed();
	    this._checkFinalizedStatuses(subscriber);
	    return this._innerSubscribe(subscriber);
	  };
	  Subject.prototype._innerSubscribe = function (subscriber) {
	    var _this = this;
	    var _a = this,
	      hasError = _a.hasError,
	      isStopped = _a.isStopped,
	      observers = _a.observers;
	    if (hasError || isStopped) {
	      return EMPTY_SUBSCRIPTION;
	    }
	    this.currentObservers = null;
	    observers.push(subscriber);
	    return new Subscription(function () {
	      _this.currentObservers = null;
	      arrRemove(observers, subscriber);
	    });
	  };
	  Subject.prototype._checkFinalizedStatuses = function (subscriber) {
	    var _a = this,
	      hasError = _a.hasError,
	      thrownError = _a.thrownError,
	      isStopped = _a.isStopped;
	    if (hasError) {
	      subscriber.error(thrownError);
	    } else if (isStopped) {
	      subscriber.complete();
	    }
	  };
	  Subject.prototype.asObservable = function () {
	    var observable = new Observable();
	    observable.source = this;
	    return observable;
	  };
	  Subject.create = function (destination, source) {
	    return new AnonymousSubject(destination, source);
	  };
	  return Subject;
	}(Observable);
	var AnonymousSubject = function (_super) {
	  __extends$4(AnonymousSubject, _super);
	  function AnonymousSubject(destination, source) {
	    var _this = _super.call(this) || this;
	    _this.destination = destination;
	    _this.source = source;
	    return _this;
	  }
	  AnonymousSubject.prototype.next = function (value) {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	  };
	  AnonymousSubject.prototype.error = function (err) {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	  };
	  AnonymousSubject.prototype.complete = function () {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
	  };
	  AnonymousSubject.prototype._subscribe = function (subscriber) {
	    var _a, _b;
	    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
	  };
	  return AnonymousSubject;
	}(Subject);

	var EMPTY = new Observable(function (subscriber) {
	  return subscriber.complete();
	});
	function empty(scheduler) {
	  return scheduler ? emptyScheduled(scheduler) : EMPTY;
	}
	function emptyScheduled(scheduler) {
	  return new Observable(function (subscriber) {
	    return scheduler.schedule(function () {
	      return subscriber.complete();
	    });
	  });
	}

	function isScheduler(value) {
	  return value && isFunction$3(value.schedule);
	}

	function last(arr) {
	  return arr[arr.length - 1];
	}
	function popScheduler(args) {
	  return isScheduler(last(args)) ? args.pop() : undefined;
	}

	var isArrayLike$6 = function (x) {
	  return x && typeof x.length === 'number' && typeof x !== 'function';
	};

	function isPromise(value) {
	  return isFunction$3(value === null || value === void 0 ? void 0 : value.then);
	}

	function isInteropObservable(input) {
	  return isFunction$3(input[observable]);
	}

	function isAsyncIterable(obj) {
	  return Symbol.asyncIterator && isFunction$3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}

	function createInvalidObservableTypeError(input) {
	  return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}

	function getSymbolIterator() {
	  if (typeof Symbol !== 'function' || !Symbol.iterator) {
	    return '@@iterator';
	  }
	  return Symbol.iterator;
	}
	var iterator = getSymbolIterator();

	function isIterable(input) {
	  return isFunction$3(input === null || input === void 0 ? void 0 : input[iterator]);
	}

	function readableStreamLikeToAsyncGenerator(readableStream) {
	  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
	    var reader, _a, value, done;
	    return __generator(this, function (_b) {
	      switch (_b.label) {
	        case 0:
	          reader = readableStream.getReader();
	          _b.label = 1;
	        case 1:
	          _b.trys.push([1,, 9, 10]);
	          _b.label = 2;
	        case 2:
	          return [4, __await(reader.read())];
	        case 3:
	          _a = _b.sent(), value = _a.value, done = _a.done;
	          if (!done) return [3, 5];
	          return [4, __await(void 0)];
	        case 4:
	          return [2, _b.sent()];
	        case 5:
	          return [4, __await(value)];
	        case 6:
	          return [4, _b.sent()];
	        case 7:
	          _b.sent();
	          return [3, 2];
	        case 8:
	          return [3, 10];
	        case 9:
	          reader.releaseLock();
	          return [7];
	        case 10:
	          return [2];
	      }
	    });
	  });
	}
	function isReadableStreamLike(obj) {
	  return isFunction$3(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}

	function innerFrom(input) {
	  if (input instanceof Observable) {
	    return input;
	  }
	  if (input != null) {
	    if (isInteropObservable(input)) {
	      return fromInteropObservable(input);
	    }
	    if (isArrayLike$6(input)) {
	      return fromArrayLike(input);
	    }
	    if (isPromise(input)) {
	      return fromPromise(input);
	    }
	    if (isAsyncIterable(input)) {
	      return fromAsyncIterable(input);
	    }
	    if (isIterable(input)) {
	      return fromIterable(input);
	    }
	    if (isReadableStreamLike(input)) {
	      return fromReadableStreamLike(input);
	    }
	  }
	  throw createInvalidObservableTypeError(input);
	}
	function fromInteropObservable(obj) {
	  return new Observable(function (subscriber) {
	    var obs = obj[observable]();
	    if (isFunction$3(obs.subscribe)) {
	      return obs.subscribe(subscriber);
	    }
	    throw new TypeError('Provided object does not correctly implement Symbol.observable');
	  });
	}
	function fromArrayLike(array) {
	  return new Observable(function (subscriber) {
	    for (var i = 0; i < array.length && !subscriber.closed; i++) {
	      subscriber.next(array[i]);
	    }
	    subscriber.complete();
	  });
	}
	function fromPromise(promise) {
	  return new Observable(function (subscriber) {
	    promise.then(function (value) {
	      if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	      }
	    }, function (err) {
	      return subscriber.error(err);
	    }).then(null, reportUnhandledError);
	  });
	}
	function fromIterable(iterable) {
	  return new Observable(function (subscriber) {
	    var e_1, _a;
	    try {
	      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	        var value = iterable_1_1.value;
	        subscriber.next(value);
	        if (subscriber.closed) {
	          return;
	        }
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }
	    subscriber.complete();
	  });
	}
	function fromAsyncIterable(asyncIterable) {
	  return new Observable(function (subscriber) {
	    process$1(asyncIterable, subscriber).catch(function (err) {
	      return subscriber.error(err);
	    });
	  });
	}
	function fromReadableStreamLike(readableStream) {
	  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
	}
	function process$1(asyncIterable, subscriber) {
	  var asyncIterable_1, asyncIterable_1_1;
	  var e_2, _a;
	  return __awaiter(this, void 0, void 0, function () {
	    var value, e_2_1;
	    return __generator(this, function (_b) {
	      switch (_b.label) {
	        case 0:
	          _b.trys.push([0, 5, 6, 11]);
	          asyncIterable_1 = __asyncValues(asyncIterable);
	          _b.label = 1;
	        case 1:
	          return [4, asyncIterable_1.next()];
	        case 2:
	          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
	          value = asyncIterable_1_1.value;
	          subscriber.next(value);
	          if (subscriber.closed) {
	            return [2];
	          }
	          _b.label = 3;
	        case 3:
	          return [3, 1];
	        case 4:
	          return [3, 11];
	        case 5:
	          e_2_1 = _b.sent();
	          e_2 = {
	            error: e_2_1
	          };
	          return [3, 11];
	        case 6:
	          _b.trys.push([6,, 9, 10]);
	          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
	          return [4, _a.call(asyncIterable_1)];
	        case 7:
	          _b.sent();
	          _b.label = 8;
	        case 8:
	          return [3, 10];
	        case 9:
	          if (e_2) throw e_2.error;
	          return [7];
	        case 10:
	          return [7];
	        case 11:
	          subscriber.complete();
	          return [2];
	      }
	    });
	  });
	}

	function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  if (repeat === void 0) {
	    repeat = false;
	  }
	  var scheduleSubscription = scheduler.schedule(function () {
	    work();
	    if (repeat) {
	      parentSubscription.add(this.schedule(null, delay));
	    } else {
	      this.unsubscribe();
	    }
	  }, delay);
	  parentSubscription.add(scheduleSubscription);
	  if (!repeat) {
	    return scheduleSubscription;
	  }
	}

	function observeOn(scheduler, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  return operate(function (source, subscriber) {
	    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	      return executeSchedule(subscriber, scheduler, function () {
	        return subscriber.next(value);
	      }, delay);
	    }, function () {
	      return executeSchedule(subscriber, scheduler, function () {
	        return subscriber.complete();
	      }, delay);
	    }, function (err) {
	      return executeSchedule(subscriber, scheduler, function () {
	        return subscriber.error(err);
	      }, delay);
	    }));
	  });
	}

	function subscribeOn(scheduler, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  return operate(function (source, subscriber) {
	    subscriber.add(scheduler.schedule(function () {
	      return source.subscribe(subscriber);
	    }, delay));
	  });
	}

	function scheduleObservable(input, scheduler) {
	  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
	}

	function schedulePromise(input, scheduler) {
	  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
	}

	function scheduleArray(input, scheduler) {
	  return new Observable(function (subscriber) {
	    var i = 0;
	    return scheduler.schedule(function () {
	      if (i === input.length) {
	        subscriber.complete();
	      } else {
	        subscriber.next(input[i++]);
	        if (!subscriber.closed) {
	          this.schedule();
	        }
	      }
	    });
	  });
	}

	function scheduleIterable(input, scheduler) {
	  return new Observable(function (subscriber) {
	    var iterator$1;
	    executeSchedule(subscriber, scheduler, function () {
	      iterator$1 = input[iterator]();
	      executeSchedule(subscriber, scheduler, function () {
	        var _a;
	        var value;
	        var done;
	        try {
	          _a = iterator$1.next(), value = _a.value, done = _a.done;
	        } catch (err) {
	          subscriber.error(err);
	          return;
	        }
	        if (done) {
	          subscriber.complete();
	        } else {
	          subscriber.next(value);
	        }
	      }, 0, true);
	    });
	    return function () {
	      return isFunction$3(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
	    };
	  });
	}

	function scheduleAsyncIterable(input, scheduler) {
	  if (!input) {
	    throw new Error('Iterable cannot be null');
	  }
	  return new Observable(function (subscriber) {
	    executeSchedule(subscriber, scheduler, function () {
	      var iterator = input[Symbol.asyncIterator]();
	      executeSchedule(subscriber, scheduler, function () {
	        iterator.next().then(function (result) {
	          if (result.done) {
	            subscriber.complete();
	          } else {
	            subscriber.next(result.value);
	          }
	        });
	      }, 0, true);
	    });
	  });
	}

	function scheduleReadableStreamLike(input, scheduler) {
	  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
	}

	function scheduled(input, scheduler) {
	  if (input != null) {
	    if (isInteropObservable(input)) {
	      return scheduleObservable(input, scheduler);
	    }
	    if (isArrayLike$6(input)) {
	      return scheduleArray(input, scheduler);
	    }
	    if (isPromise(input)) {
	      return schedulePromise(input, scheduler);
	    }
	    if (isAsyncIterable(input)) {
	      return scheduleAsyncIterable(input, scheduler);
	    }
	    if (isIterable(input)) {
	      return scheduleIterable(input, scheduler);
	    }
	    if (isReadableStreamLike(input)) {
	      return scheduleReadableStreamLike(input, scheduler);
	    }
	  }
	  throw createInvalidObservableTypeError(input);
	}

	function from(input, scheduler) {
	  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
	}

	function of() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = popScheduler(args);
	  return from(args, scheduler);
	}

	function map$2(project, thisArg) {
	  return operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	      subscriber.next(project.call(thisArg, value, index++));
	    }));
	  });
	}

	var isArray$d = Array.isArray;
	function callOrApply(fn, args) {
	  return isArray$d(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
	}
	function mapOneOrManyArgs(fn) {
	  return map$2(function (args) {
	    return callOrApply(fn, args);
	  });
	}

	function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
	  var buffer = [];
	  var active = 0;
	  var index = 0;
	  var isComplete = false;
	  var checkComplete = function () {
	    if (isComplete && !buffer.length && !active) {
	      subscriber.complete();
	    }
	  };
	  var outerNext = function (value) {
	    return active < concurrent ? doInnerSub(value) : buffer.push(value);
	  };
	  var doInnerSub = function (value) {
	    active++;
	    var innerComplete = false;
	    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
	      {
	        subscriber.next(innerValue);
	      }
	    }, function () {
	      innerComplete = true;
	    }, undefined, function () {
	      if (innerComplete) {
	        try {
	          active--;
	          var _loop_1 = function () {
	            var bufferedValue = buffer.shift();
	            if (innerSubScheduler) ; else {
	              doInnerSub(bufferedValue);
	            }
	          };
	          while (buffer.length && active < concurrent) {
	            _loop_1();
	          }
	          checkComplete();
	        } catch (err) {
	          subscriber.error(err);
	        }
	      }
	    }));
	  };
	  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
	    isComplete = true;
	    checkComplete();
	  }));
	  return function () {
	  };
	}

	function mergeMap(project, resultSelector, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  if (isFunction$3(resultSelector)) {
	    return mergeMap(function (a, i) {
	      return map$2(function (b, ii) {
	        return resultSelector(a, b, i, ii);
	      })(innerFrom(project(a, i)));
	    }, concurrent);
	  } else if (typeof resultSelector === 'number') {
	    concurrent = resultSelector;
	  }
	  return operate(function (source, subscriber) {
	    return mergeInternals(source, subscriber, project, concurrent);
	  });
	}

	function defer(observableFactory) {
	  return new Observable(function (subscriber) {
	    innerFrom(observableFactory()).subscribe(subscriber);
	  });
	}

	var nodeEventEmitterMethods = ['addListener', 'removeListener'];
	var eventTargetMethods = ['addEventListener', 'removeEventListener'];
	var jqueryMethods = ['on', 'off'];
	function fromEvent(target, eventName, options, resultSelector) {
	  if (isFunction$3(options)) {
	    resultSelector = options;
	    options = undefined;
	  }
	  if (resultSelector) {
	    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
	  }
	  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function (methodName) {
	      return function (handler) {
	        return target[methodName](eventName, handler, options);
	      };
	    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2),
	    add = _a[0],
	    remove = _a[1];
	  if (!add) {
	    if (isArrayLike$6(target)) {
	      return mergeMap(function (subTarget) {
	        return fromEvent(subTarget, eventName, options);
	      })(innerFrom(target));
	    }
	  }
	  if (!add) {
	    throw new TypeError('Invalid event target');
	  }
	  return new Observable(function (subscriber) {
	    var handler = function () {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      return subscriber.next(1 < args.length ? args : args[0]);
	    };
	    add(handler);
	    return function () {
	      return remove(handler);
	    };
	  });
	}
	function toCommonHandlerRegistry(target, eventName) {
	  return function (methodName) {
	    return function (handler) {
	      return target[methodName](eventName, handler);
	    };
	  };
	}
	function isNodeStyleEventEmitter(target) {
	  return isFunction$3(target.addListener) && isFunction$3(target.removeListener);
	}
	function isJQueryStyleEventEmitter(target) {
	  return isFunction$3(target.on) && isFunction$3(target.off);
	}
	function isEventTarget(target) {
	  return isFunction$3(target.addEventListener) && isFunction$3(target.removeEventListener);
	}

	function filter$2(predicate, thisArg) {
	  return operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	      return predicate.call(thisArg, value, index++) && subscriber.next(value);
	    }));
	  });
	}

	function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
	  return function (source, subscriber) {
	    var hasState = hasSeed;
	    var state = seed;
	    var index = 0;
	    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	      var i = index++;
	      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
	    }, function () {
	      hasState && subscriber.next(state);
	      subscriber.complete();
	    }));
	  };
	}

	function reduce(accumulator, seed) {
	  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}

	function concatMap(project, resultSelector) {
	  return isFunction$3(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
	}

	function fromSubscribable(subscribable) {
	  return new Observable(function (subscriber) {
	    return subscribable.subscribe(subscriber);
	  });
	}

	var DEFAULT_CONFIG = {
	  connector: function () {
	    return new Subject();
	  }
	};
	function connect(selector, config) {
	  if (config === void 0) {
	    config = DEFAULT_CONFIG;
	  }
	  var connector = config.connector;
	  return operate(function (source, subscriber) {
	    var subject = connector();
	    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
	    subscriber.add(source.subscribe(subject));
	  });
	}

	function take(count) {
	  return count <= 0 ? function () {
	    return EMPTY;
	  } : operate(function (source, subscriber) {
	    var seen = 0;
	    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	      if (++seen <= count) {
	        subscriber.next(value);
	        if (count <= seen) {
	          subscriber.complete();
	        }
	      }
	    }));
	  });
	}

	var flatMap = mergeMap;

	function multicast(subjectOrSubjectFactory, selector) {
	  var subjectFactory = isFunction$3(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () {
	    return subjectOrSubjectFactory;
	  };
	  if (isFunction$3(selector)) {
	    return connect(selector, {
	      connector: subjectFactory
	    });
	  }
	  return function (source) {
	    return new ConnectableObservable(source, subjectFactory);
	  };
	}

	function publish(selector) {
	  return selector ? function (source) {
	    return connect(selector)(source);
	  } : function (source) {
	    return multicast(new Subject())(source);
	  };
	}

	function share(options) {
	  if (options === void 0) {
	    options = {};
	  }
	  var _a = options.connector,
	    connector = _a === void 0 ? function () {
	      return new Subject();
	    } : _a,
	    _b = options.resetOnError,
	    resetOnError = _b === void 0 ? true : _b,
	    _c = options.resetOnComplete,
	    resetOnComplete = _c === void 0 ? true : _c,
	    _d = options.resetOnRefCountZero,
	    resetOnRefCountZero = _d === void 0 ? true : _d;
	  return function (wrapperSource) {
	    var connection;
	    var resetConnection;
	    var subject;
	    var refCount = 0;
	    var hasCompleted = false;
	    var hasErrored = false;
	    var cancelReset = function () {
	      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
	      resetConnection = undefined;
	    };
	    var reset = function () {
	      cancelReset();
	      connection = subject = undefined;
	      hasCompleted = hasErrored = false;
	    };
	    var resetAndUnsubscribe = function () {
	      var conn = connection;
	      reset();
	      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
	    };
	    return operate(function (source, subscriber) {
	      refCount++;
	      if (!hasErrored && !hasCompleted) {
	        cancelReset();
	      }
	      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
	      subscriber.add(function () {
	        refCount--;
	        if (refCount === 0 && !hasErrored && !hasCompleted) {
	          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
	        }
	      });
	      dest.subscribe(subscriber);
	      if (!connection && refCount > 0) {
	        connection = new SafeSubscriber({
	          next: function (value) {
	            return dest.next(value);
	          },
	          error: function (err) {
	            hasErrored = true;
	            cancelReset();
	            resetConnection = handleReset(reset, resetOnError, err);
	            dest.error(err);
	          },
	          complete: function () {
	            hasCompleted = true;
	            cancelReset();
	            resetConnection = handleReset(reset, resetOnComplete);
	            dest.complete();
	          }
	        });
	        innerFrom(source).subscribe(connection);
	      }
	    })(wrapperSource);
	  };
	}
	function handleReset(reset, on) {
	  var args = [];
	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }
	  if (on === true) {
	    reset();
	    return;
	  }
	  if (on === false) {
	    return;
	  }
	  var onSubscriber = new SafeSubscriber({
	    next: function () {
	      onSubscriber.unsubscribe();
	      reset();
	    }
	  });
	  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
	}

	function takeUntil(notifier) {
	  return operate(function (source, subscriber) {
	    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () {
	      return subscriber.complete();
	    }, noop));
	    !subscriber.closed && source.subscribe(subscriber);
	  });
	}

	function normalizeKeypressEvents(value, key) {
	  return {
	    value,
	    key: key || {}
	  };
	}
	function observe(rl) {
	  const keypress = fromEvent(rl.input, 'keypress', normalizeKeypressEvents).pipe(takeUntil(fromEvent(rl, 'close')))
	  // Ignore `enter` key. On the readline, we only care about the `line` event.
	  .pipe(filter$2(({
	    key
	  }) => key.name !== 'enter' && key.name !== 'return'));
	  return {
	    line: fromEvent(rl, 'line'),
	    keypress,
	    normalizedUpKey: keypress.pipe(filter$2(({
	      key
	    }) => key.name === 'up' || key.name === 'k' || key.name === 'p' && key.ctrl), share()),
	    normalizedDownKey: keypress.pipe(filter$2(({
	      key
	    }) => key.name === 'down' || key.name === 'j' || key.name === 'n' && key.ctrl), share()),
	    numberKey: keypress.pipe(filter$2(e => e.value && '123456789'.includes(e.value)), map$2(e => Number(e.value)), share()),
	    spaceKey: keypress.pipe(filter$2(({
	      key
	    }) => key && key.name === 'space'), share()),
	    aKey: keypress.pipe(filter$2(({
	      key
	    }) => key && key.name === 'a'), share()),
	    iKey: keypress.pipe(filter$2(({
	      key
	    }) => key && key.name === 'i'), share())
	  };
	}

	/**
	 * The paginator returns a subset of the choices if the list is too long.
	 */

	class Paginator {
	  /**
	   * @param {import("./screen-manager")} [screen]
	   * @param {{isInfinite?: boolean}} [options]
	   */
	  constructor(screen, options = {}) {
	    const {
	      isInfinite = true
	    } = options;
	    this.lastIndex = 0;
	    this.screen = screen;
	    this.isInfinite = isInfinite;
	  }
	  paginate(output, active, pageSize) {
	    pageSize ||= 7;
	    let lines = output.split('\n');
	    if (this.screen) {
	      lines = this.screen.breakLines(lines);
	      active = lines.map(lineParts => lineParts.length).splice(0, active).reduce((a, b) => a + b, 0);
	      lines = lines.flat();
	    }

	    // Make sure there's enough lines to paginate
	    if (lines.length <= pageSize) {
	      return output;
	    }
	    const visibleLines = this.isInfinite ? this.getInfiniteLines(lines, active, pageSize) : this.getFiniteLines(lines, active, pageSize);
	    this.lastIndex = active;
	    return visibleLines.join('\n') + '\n' + chalk$3.dim('(Move up and down to reveal more choices)');
	  }
	  getInfiniteLines(lines, active, pageSize) {
	    if (this.pointer === undefined) {
	      this.pointer = 0;
	    }
	    const middleOfList = Math.floor(pageSize / 2);
	    // Move the pointer only when the user go down and limit it to the middle of the list
	    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {
	      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);
	    }

	    // Duplicate the lines so it give an infinite list look
	    const infinite = [lines, lines, lines].flat();
	    const topIndex = Math.max(0, active + lines.length - this.pointer);
	    return infinite.splice(topIndex, pageSize);
	  }
	  getFiniteLines(lines, active, pageSize) {
	    let topIndex = active - pageSize / 2;
	    if (topIndex < 0) {
	      topIndex = 0;
	    } else if (topIndex + pageSize > lines.length) {
	      topIndex = lines.length - pageSize;
	    }
	    return lines.splice(topIndex, pageSize);
	  }
	}

	function incrementListIndex(current, dir, opt) {
	  const len = opt.choices.realLength;
	  const shouldLoop = 'loop' in opt ? Boolean(opt.loop) : true;
	  if (dir === 'up') {
	    if (current > 0) {
	      return current - 1;
	    }
	    return shouldLoop ? len - 1 : current;
	  }
	  if (dir === 'down') {
	    if (current < len - 1) {
	      return current + 1;
	    }
	    return shouldLoop ? 0 : current;
	  }
	  throw new Error('dir must be up or down');
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity$3(value) {
	  return value;
	}
	var identity_1 = identity$3;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply$1(func, thisArg, args) {
	  switch (args.length) {
	    case 0:
	      return func.call(thisArg);
	    case 1:
	      return func.call(thisArg, args[0]);
	    case 2:
	      return func.call(thisArg, args[0], args[1]);
	    case 3:
	      return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	var _apply = apply$1;

	var apply = _apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
	  return function () {
	    var args = arguments,
	      index = -1,
	      length = nativeMax(args.length - start, 0),
	      array = Array(length);
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	var _overRest = overRest$1;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant$1(value) {
	  return function () {
	    return value;
	  };
	}
	var constant_1 = constant$1;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$8 = freeGlobal || freeSelf || Function('return this')();
	var _root = root$8;

	var root$7 = _root;

	/** Built-in value references. */
	var Symbol$6 = root$7.Symbol;
	var _Symbol = Symbol$6;

	var Symbol$5 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$g = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$d = objectProto$g.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$g.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1),
	    tag = value[symToStringTag$1];
	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}
	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$f.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}
	var _objectToString = objectToString$1;

	var Symbol$4 = _Symbol,
	  getRawTag = _getRawTag,
	  objectToString = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	  undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$6(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	var _baseGetTag = baseGetTag$6;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$8(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	var isObject_1 = isObject$8;

	var baseGetTag$5 = _baseGetTag,
	  isObject$7 = isObject_1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	  funcTag$2 = '[object Function]',
	  genTag$1 = '[object GeneratorFunction]',
	  proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$2(value) {
	  if (!isObject$7(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$5(value);
	  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
	}
	var isFunction_1 = isFunction$2;

	var root$6 = _root;

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$6['__core-js_shared__'];
	var _coreJsData = coreJsData$1;

	var coreJsData = _coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function () {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? 'Symbol(src)_1.' + uid : '';
	}();

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey && maskSrcKey in func;
	}
	var _isMasked = isMasked$1;

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$2(func) {
	  if (func != null) {
	    try {
	      return funcToString$2.call(func);
	    } catch (e) {}
	    try {
	      return func + '';
	    } catch (e) {}
	  }
	  return '';
	}
	var _toSource = toSource$2;

	var isFunction$1 = isFunction_1,
	  isMasked = _isMasked,
	  isObject$6 = isObject_1,
	  toSource$1 = _toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	  objectProto$e = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$e.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$6(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource$1(value));
	}
	var _baseIsNative = baseIsNative$1;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}
	var _getValue = getValue$1;

	var baseIsNative = _baseIsNative,
	  getValue = _getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$7(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	var _getNative = getNative$7;

	var getNative$6 = _getNative;
	var defineProperty$2 = function () {
	  try {
	    var func = getNative$6(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}();
	var _defineProperty = defineProperty$2;

	var constant = constant_1,
	  defineProperty$1 = _defineProperty,
	  identity$2 = identity_1;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString$1 = !defineProperty$1 ? identity$2 : function (func, string) {
	  return defineProperty$1(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};
	var _baseSetToString = baseSetToString$1;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	  HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut$1(func) {
	  var count = 0,
	    lastCalled = 0;
	  return function () {
	    var stamp = nativeNow(),
	      remaining = HOT_SPAN - (stamp - lastCalled);
	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}
	var _shortOut = shortOut$1;

	var baseSetToString = _baseSetToString,
	  shortOut = _shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString$1 = shortOut(baseSetToString);
	var _setToString = setToString$1;

	var identity$1 = identity_1,
	  overRest = _overRest,
	  setToString = _setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$1(func, start) {
	  return setToString(overRest(func, start, identity$1), func + '');
	}
	var _baseRest = baseRest$1;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq$5(value, other) {
	  return value === other || value !== value && other !== other;
	}
	var eq_1 = eq$5;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$3(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}
	var isLength_1 = isLength$3;

	var isFunction = isFunction_1,
	  isLength$2 = isLength_1;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$5(value) {
	  return value != null && isLength$2(value.length) && !isFunction(value);
	}
	var isArrayLike_1 = isArrayLike$5;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$4(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	var _isIndex = isIndex$4;

	var eq$4 = eq_1,
	  isArrayLike$4 = isArrayLike_1,
	  isIndex$3 = _isIndex,
	  isObject$5 = isObject_1;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall$1(value, index, object) {
	  if (!isObject$5(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number' ? isArrayLike$4(object) && isIndex$3(index, object.length) : type == 'string' && index in object) {
	    return eq$4(object[index], value);
	  }
	  return false;
	}
	var _isIterateeCall = isIterateeCall$1;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes$1(n, iteratee) {
	  var index = -1,
	    result = Array(n);
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	var _baseTimes = baseTimes$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike$8(value) {
	  return value != null && typeof value == 'object';
	}
	var isObjectLike_1 = isObjectLike$8;

	var baseGetTag$4 = _baseGetTag,
	  isObjectLike$7 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$1(value) {
	  return isObjectLike$7(value) && baseGetTag$4(value) == argsTag$3;
	}
	var _baseIsArguments = baseIsArguments$1;

	var baseIsArguments = _baseIsArguments,
	  isObjectLike$6 = isObjectLike_1;

	/** Used for built-in method references. */
	var objectProto$d = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$2 = baseIsArguments(function () {
	  return arguments;
	}()) ? baseIsArguments : function (value) {
	  return isObjectLike$6(value) && hasOwnProperty$b.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
	};
	var isArguments_1 = isArguments$2;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray$c = Array.isArray;
	var isArray_1 = isArray$c;

	var isBuffer$3 = {exports: {}};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	var stubFalse_1 = stubFalse;

	isBuffer$3.exports;
	(function (module, exports) {
	  var root = _root,
	    stubFalse = stubFalse_1;

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Built-in value references. */
	  var Buffer = moduleExports ? root.Buffer : undefined;

	  /* Built-in method references for those with the same name as other `lodash` methods. */
	  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	  /**
	   * Checks if `value` is a buffer.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.3.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	   * @example
	   *
	   * _.isBuffer(new Buffer(2));
	   * // => true
	   *
	   * _.isBuffer(new Uint8Array(2));
	   * // => false
	   */
	  var isBuffer = nativeIsBuffer || stubFalse;
	  module.exports = isBuffer;
	})(isBuffer$3, isBuffer$3.exports);
	var isBufferExports = isBuffer$3.exports;

	var baseGetTag$3 = _baseGetTag,
	  isLength$1 = isLength_1,
	  isObjectLike$5 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	  arrayTag$2 = '[object Array]',
	  boolTag$3 = '[object Boolean]',
	  dateTag$3 = '[object Date]',
	  errorTag$2 = '[object Error]',
	  funcTag$1 = '[object Function]',
	  mapTag$5 = '[object Map]',
	  numberTag$3 = '[object Number]',
	  objectTag$4 = '[object Object]',
	  regexpTag$3 = '[object RegExp]',
	  setTag$5 = '[object Set]',
	  stringTag$3 = '[object String]',
	  weakMapTag$2 = '[object WeakMap]';
	var arrayBufferTag$3 = '[object ArrayBuffer]',
	  dataViewTag$4 = '[object DataView]',
	  float32Tag$2 = '[object Float32Array]',
	  float64Tag$2 = '[object Float64Array]',
	  int8Tag$2 = '[object Int8Array]',
	  int16Tag$2 = '[object Int16Array]',
	  int32Tag$2 = '[object Int32Array]',
	  uint8Tag$2 = '[object Uint8Array]',
	  uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	  uint16Tag$2 = '[object Uint16Array]',
	  uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$1(value) {
	  return isObjectLike$5(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$3(value)];
	}
	var _baseIsTypedArray = baseIsTypedArray$1;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary$3(func) {
	  return function (value) {
	    return func(value);
	  };
	}
	var _baseUnary = baseUnary$3;

	var _nodeUtil = {exports: {}};

	_nodeUtil.exports;
	(function (module, exports) {
	  var freeGlobal = _freeGlobal;

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = function () {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;
	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }();
	  module.exports = nodeUtil;
	})(_nodeUtil, _nodeUtil.exports);
	var _nodeUtilExports = _nodeUtil.exports;

	var baseIsTypedArray = _baseIsTypedArray,
	  baseUnary$2 = _baseUnary,
	  nodeUtil$2 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
	var isTypedArray_1 = isTypedArray$2;

	var baseTimes = _baseTimes,
	  isArguments$1 = isArguments_1,
	  isArray$b = isArray_1,
	  isBuffer$2 = isBufferExports,
	  isIndex$2 = _isIndex,
	  isTypedArray$1 = isTypedArray_1;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$2(value, inherited) {
	  var isArr = isArray$b(value),
	    isArg = !isArr && isArguments$1(value),
	    isBuff = !isArr && !isArg && isBuffer$2(value),
	    isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
	    skipIndexes = isArr || isArg || isBuff || isType,
	    result = skipIndexes ? baseTimes(value.length, String) : [],
	    length = result.length;
	  for (var key in value) {
	    if ((inherited || hasOwnProperty$a.call(value, key)) && !(skipIndexes && (
	    // Safari 9 has enumerable `arguments.length` in strict mode.
	    key == 'length' ||
	    // Node.js 0.10 has enumerable non-index properties on buffers.
	    isBuff && (key == 'offset' || key == 'parent') ||
	    // PhantomJS 2 has enumerable non-index properties on typed arrays.
	    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
	    // Skip index properties.
	    isIndex$2(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	var _arrayLikeKeys = arrayLikeKeys$2;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$3(value) {
	  var Ctor = value && value.constructor,
	    proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$b;
	  return value === proto;
	}
	var _isPrototype = isPrototype$3;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn$1(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	var _nativeKeysIn = nativeKeysIn$1;

	var isObject$4 = isObject_1,
	  isPrototype$2 = _isPrototype,
	  nativeKeysIn = _nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn$1(object) {
	  if (!isObject$4(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype$2(object),
	    result = [];
	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	var _baseKeysIn = baseKeysIn$1;

	var arrayLikeKeys$1 = _arrayLikeKeys,
	  baseKeysIn = _baseKeysIn,
	  isArrayLike$3 = isArrayLike_1;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$4(object) {
	  return isArrayLike$3(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
	}
	var keysIn_1 = keysIn$4;

	var baseRest = _baseRest,
	  eq$3 = eq_1,
	  isIterateeCall = _isIterateeCall,
	  keysIn$3 = keysIn_1;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults$2 = baseRest(function (object, sources) {
	  object = Object(object);
	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;
	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }
	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn$3(source);
	    var propsIndex = -1;
	    var propsLength = props.length;
	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];
	      if (value === undefined || eq$3(value, objectProto$9[key]) && !hasOwnProperty$8.call(object, key)) {
	        object[key] = source[key];
	      }
	    }
	  }
	  return object;
	});
	var defaults_1 = defaults$2;
	var defaults$3 = /*@__PURE__*/getDefaultExportFromCjs(defaults_1);

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}
	var _listCacheClear = listCacheClear$1;

	var eq$2 = eq_1;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$4(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$2(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	var _assocIndexOf = assocIndexOf$4;

	var assocIndexOf$3 = _assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	    index = assocIndexOf$3(data, key);
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	var _listCacheDelete = listCacheDelete$1;

	var assocIndexOf$2 = _assocIndexOf;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	    index = assocIndexOf$2(data, key);
	  return index < 0 ? undefined : data[index][1];
	}
	var _listCacheGet = listCacheGet$1;

	var assocIndexOf$1 = _assocIndexOf;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}
	var _listCacheHas = listCacheHas$1;

	var assocIndexOf = _assocIndexOf;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	    index = assocIndexOf(data, key);
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	var _listCacheSet = listCacheSet$1;

	var listCacheClear = _listCacheClear,
	  listCacheDelete = _listCacheDelete,
	  listCacheGet = _listCacheGet,
	  listCacheHas = _listCacheHas,
	  listCacheSet = _listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$4(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype['delete'] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;
	var _ListCache = ListCache$4;

	var ListCache$3 = _ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$1() {
	  this.__data__ = new ListCache$3();
	  this.size = 0;
	}
	var _stackClear = stackClear$1;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete$1(key) {
	  var data = this.__data__,
	    result = data['delete'](key);
	  this.size = data.size;
	  return result;
	}
	var _stackDelete = stackDelete$1;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet$1(key) {
	  return this.__data__.get(key);
	}
	var _stackGet = stackGet$1;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas$1(key) {
	  return this.__data__.has(key);
	}
	var _stackHas = stackHas$1;

	var getNative$5 = _getNative,
	  root$5 = _root;

	/* Built-in method references that are verified to be native. */
	var Map$4 = getNative$5(root$5, 'Map');
	var _Map = Map$4;

	var getNative$4 = _getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$4 = getNative$4(Object, 'create');
	var _nativeCreate = nativeCreate$4;

	var nativeCreate$3 = _nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
	  this.size = 0;
	}
	var _hashClear = hashClear$1;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	var _hashDelete = hashDelete$1;

	var nativeCreate$2 = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
	}
	var _hashGet = hashGet$1;

	var nativeCreate$1 = _nativeCreate;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$6.call(data, key);
	}
	var _hashHas = hashHas$1;

	var nativeCreate = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
	  return this;
	}
	var _hashSet = hashSet$1;

	var hashClear = _hashClear,
	  hashDelete = _hashDelete,
	  hashGet = _hashGet,
	  hashHas = _hashHas,
	  hashSet = _hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype['delete'] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;
	var _Hash = Hash$1;

	var Hash = _Hash,
	  ListCache$2 = _ListCache,
	  Map$3 = _Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash(),
	    'map': new (Map$3 || ListCache$2)(),
	    'string': new Hash()
	  };
	}
	var _mapCacheClear = mapCacheClear$1;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable$1(value) {
	  var type = typeof value;
	  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}
	var _isKeyable = isKeyable$1;

	var isKeyable = _isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$4(map, key) {
	  var data = map.__data__;
	  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}
	var _getMapData = getMapData$4;

	var getMapData$3 = _getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$3(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	var _mapCacheDelete = mapCacheDelete$1;

	var getMapData$2 = _getMapData;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$2(this, key).get(key);
	}
	var _mapCacheGet = mapCacheGet$1;

	var getMapData$1 = _getMapData;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}
	var _mapCacheHas = mapCacheHas$1;

	var getMapData = _getMapData;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData(this, key),
	    size = data.size;
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	var _mapCacheSet = mapCacheSet$1;

	var mapCacheClear = _mapCacheClear,
	  mapCacheDelete = _mapCacheDelete,
	  mapCacheGet = _mapCacheGet,
	  mapCacheHas = _mapCacheHas,
	  mapCacheSet = _mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$3(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$3.prototype.clear = mapCacheClear;
	MapCache$3.prototype['delete'] = mapCacheDelete;
	MapCache$3.prototype.get = mapCacheGet;
	MapCache$3.prototype.has = mapCacheHas;
	MapCache$3.prototype.set = mapCacheSet;
	var _MapCache = MapCache$3;

	var ListCache$1 = _ListCache,
	  Map$2 = _Map,
	  MapCache$2 = _MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$1(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$2(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}
	var _stackSet = stackSet$1;

	var ListCache = _ListCache,
	  stackClear = _stackClear,
	  stackDelete = _stackDelete,
	  stackGet = _stackGet,
	  stackHas = _stackHas,
	  stackSet = _stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$3(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$3.prototype.clear = stackClear;
	Stack$3.prototype['delete'] = stackDelete;
	Stack$3.prototype.get = stackGet;
	Stack$3.prototype.has = stackHas;
	Stack$3.prototype.set = stackSet;
	var _Stack = Stack$3;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach$1(array, iteratee) {
	  var index = -1,
	    length = array == null ? 0 : array.length;
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	var _arrayEach = arrayEach$1;

	var defineProperty = _defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue$2(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}
	var _baseAssignValue = baseAssignValue$2;

	var baseAssignValue$1 = _baseAssignValue,
	  eq$1 = eq_1;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue$3(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$5.call(object, key) && eq$1(objValue, value)) || value === undefined && !(key in object)) {
	    baseAssignValue$1(object, key, value);
	  }
	}
	var _assignValue = assignValue$3;

	var assignValue$2 = _assignValue,
	  baseAssignValue = _baseAssignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject$4(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});
	  var index = -1,
	    length = props.length;
	  while (++index < length) {
	    var key = props[index];
	    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue$2(object, key, newValue);
	    }
	  }
	  return object;
	}
	var _copyObject = copyObject$4;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg$2(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	var _overArg = overArg$2;

	var overArg$1 = _overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$1 = overArg$1(Object.keys, Object);
	var _nativeKeys = nativeKeys$1;

	var isPrototype$1 = _isPrototype,
	  nativeKeys = _nativeKeys;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$1(object) {
	  if (!isPrototype$1(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$4.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	var _baseKeys = baseKeys$1;

	var arrayLikeKeys = _arrayLikeKeys,
	  baseKeys = _baseKeys,
	  isArrayLike$2 = isArrayLike_1;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$5(object) {
	  return isArrayLike$2(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	var keys_1 = keys$5;

	var copyObject$3 = _copyObject,
	  keys$4 = keys_1;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign$1(object, source) {
	  return object && copyObject$3(source, keys$4(source), object);
	}
	var _baseAssign = baseAssign$1;

	var copyObject$2 = _copyObject,
	  keysIn$2 = keysIn_1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn$1(object, source) {
	  return object && copyObject$2(source, keysIn$2(source), object);
	}
	var _baseAssignIn = baseAssignIn$1;

	var _cloneBuffer = {exports: {}};

	_cloneBuffer.exports;
	(function (module, exports) {
	  var root = _root;

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Built-in value references. */
	  var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	  /**
	   * Creates a clone of  `buffer`.
	   *
	   * @private
	   * @param {Buffer} buffer The buffer to clone.
	   * @param {boolean} [isDeep] Specify a deep clone.
	   * @returns {Buffer} Returns the cloned buffer.
	   */
	  function cloneBuffer(buffer, isDeep) {
	    if (isDeep) {
	      return buffer.slice();
	    }
	    var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	    buffer.copy(result);
	    return result;
	  }
	  module.exports = cloneBuffer;
	})(_cloneBuffer, _cloneBuffer.exports);
	var _cloneBufferExports = _cloneBuffer.exports;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray$1(source, array) {
	  var index = -1,
	    length = source.length;
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	var _copyArray = copyArray$1;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter$2(array, predicate) {
	  var index = -1,
	    length = array == null ? 0 : array.length,
	    resIndex = 0,
	    result = [];
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}
	var _arrayFilter = arrayFilter$2;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray$2() {
	  return [];
	}
	var stubArray_1 = stubArray$2;

	var arrayFilter$1 = _arrayFilter,
	  stubArray$1 = stubArray_1;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function (object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter$1(nativeGetSymbols$1(object), function (symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};
	var _getSymbols = getSymbols$3;

	var copyObject$1 = _copyObject,
	  getSymbols$2 = _getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols$1(source, object) {
	  return copyObject$1(source, getSymbols$2(source), object);
	}
	var _copySymbols = copySymbols$1;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush$2(array, values) {
	  var index = -1,
	    length = values.length,
	    offset = array.length;
	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}
	var _arrayPush = arrayPush$2;

	var overArg = _overArg;

	/** Built-in value references. */
	var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
	var _getPrototype = getPrototype$3;

	var arrayPush$1 = _arrayPush,
	  getPrototype$2 = _getPrototype,
	  getSymbols$1 = _getSymbols,
	  stubArray = stubArray_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function (object) {
	  var result = [];
	  while (object) {
	    arrayPush$1(result, getSymbols$1(object));
	    object = getPrototype$2(object);
	  }
	  return result;
	};
	var _getSymbolsIn = getSymbolsIn$2;

	var copyObject = _copyObject,
	  getSymbolsIn$1 = _getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn$1(source, object) {
	  return copyObject(source, getSymbolsIn$1(source), object);
	}
	var _copySymbolsIn = copySymbolsIn$1;

	var arrayPush = _arrayPush,
	  isArray$a = isArray_1;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$a(object) ? result : arrayPush(result, symbolsFunc(object));
	}
	var _baseGetAllKeys = baseGetAllKeys$2;

	var baseGetAllKeys$1 = _baseGetAllKeys,
	  getSymbols = _getSymbols,
	  keys$3 = keys_1;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$2(object) {
	  return baseGetAllKeys$1(object, keys$3, getSymbols);
	}
	var _getAllKeys = getAllKeys$2;

	var baseGetAllKeys = _baseGetAllKeys,
	  getSymbolsIn = _getSymbolsIn,
	  keysIn$1 = keysIn_1;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn$1(object) {
	  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
	}
	var _getAllKeysIn = getAllKeysIn$1;

	var getNative$3 = _getNative,
	  root$4 = _root;

	/* Built-in method references that are verified to be native. */
	var DataView$2 = getNative$3(root$4, 'DataView');
	var _DataView = DataView$2;

	var getNative$2 = _getNative,
	  root$3 = _root;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative$2(root$3, 'Promise');
	var _Promise = Promise$2;

	var getNative$1 = _getNative,
	  root$2 = _root;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$1(root$2, 'Set');
	var _Set = Set$2;

	var getNative = _getNative,
	  root$1 = _root;

	/* Built-in method references that are verified to be native. */
	var WeakMap$2 = getNative(root$1, 'WeakMap');
	var _WeakMap = WeakMap$2;

	var DataView$1 = _DataView,
	  Map$1 = _Map,
	  Promise$1 = _Promise,
	  Set$1 = _Set,
	  WeakMap$1 = _WeakMap,
	  baseGetTag$2 = _baseGetTag,
	  toSource = _toSource;

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]',
	  objectTag$3 = '[object Object]',
	  promiseTag = '[object Promise]',
	  setTag$4 = '[object Set]',
	  weakMapTag$1 = '[object WeakMap]';
	var dataViewTag$3 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView$1),
	  mapCtorString = toSource(Map$1),
	  promiseCtorString = toSource(Promise$1),
	  setCtorString = toSource(Set$1),
	  weakMapCtorString = toSource(WeakMap$1);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$4 = baseGetTag$2;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if (DataView$1 && getTag$4(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag$4(new Map$1()) != mapTag$4 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$1 && getTag$4(new Set$1()) != setTag$4 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
	  getTag$4 = function (value) {
	    var result = baseGetTag$2(value),
	      Ctor = result == objectTag$3 ? value.constructor : undefined,
	      ctorString = Ctor ? toSource(Ctor) : '';
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString:
	          return dataViewTag$3;
	        case mapCtorString:
	          return mapTag$4;
	        case promiseCtorString:
	          return promiseTag;
	        case setCtorString:
	          return setTag$4;
	        case weakMapCtorString:
	          return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}
	var _getTag = getTag$4;

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray$1(array) {
	  var length = array.length,
	    result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$3.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}
	var _initCloneArray = initCloneArray$1;

	var root = _root;

	/** Built-in value references. */
	var Uint8Array$3 = root.Uint8Array;
	var _Uint8Array = Uint8Array$3;

	var Uint8Array$2 = _Uint8Array;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer$3(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
	  return result;
	}
	var _cloneArrayBuffer = cloneArrayBuffer$3;

	var cloneArrayBuffer$2 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView$1(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}
	var _cloneDataView = cloneDataView$1;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp$1(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}
	var _cloneRegExp = cloneRegExp$1;

	var Symbol$3 = _Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : undefined,
	  symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol$1(symbol) {
	  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
	}
	var _cloneSymbol = cloneSymbol$1;

	var cloneArrayBuffer$1 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray$1(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	var _cloneTypedArray = cloneTypedArray$1;

	var cloneArrayBuffer = _cloneArrayBuffer,
	  cloneDataView = _cloneDataView,
	  cloneRegExp = _cloneRegExp,
	  cloneSymbol = _cloneSymbol,
	  cloneTypedArray = _cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$2 = '[object Boolean]',
	  dateTag$2 = '[object Date]',
	  mapTag$3 = '[object Map]',
	  numberTag$2 = '[object Number]',
	  regexpTag$2 = '[object RegExp]',
	  setTag$3 = '[object Set]',
	  stringTag$2 = '[object String]',
	  symbolTag$3 = '[object Symbol]';
	var arrayBufferTag$2 = '[object ArrayBuffer]',
	  dataViewTag$2 = '[object DataView]',
	  float32Tag$1 = '[object Float32Array]',
	  float64Tag$1 = '[object Float64Array]',
	  int8Tag$1 = '[object Int8Array]',
	  int16Tag$1 = '[object Int16Array]',
	  int32Tag$1 = '[object Int32Array]',
	  uint8Tag$1 = '[object Uint8Array]',
	  uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	  uint16Tag$1 = '[object Uint16Array]',
	  uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag$1(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$2:
	      return cloneArrayBuffer(object);
	    case boolTag$2:
	    case dateTag$2:
	      return new Ctor(+object);
	    case dataViewTag$2:
	      return cloneDataView(object, isDeep);
	    case float32Tag$1:
	    case float64Tag$1:
	    case int8Tag$1:
	    case int16Tag$1:
	    case int32Tag$1:
	    case uint8Tag$1:
	    case uint8ClampedTag$1:
	    case uint16Tag$1:
	    case uint32Tag$1:
	      return cloneTypedArray(object, isDeep);
	    case mapTag$3:
	      return new Ctor();
	    case numberTag$2:
	    case stringTag$2:
	      return new Ctor(object);
	    case regexpTag$2:
	      return cloneRegExp(object);
	    case setTag$3:
	      return new Ctor();
	    case symbolTag$3:
	      return cloneSymbol(object);
	  }
	}
	var _initCloneByTag = initCloneByTag$1;

	var isObject$3 = isObject_1;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate$1 = function () {
	  function object() {}
	  return function (proto) {
	    if (!isObject$3(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object();
	    object.prototype = undefined;
	    return result;
	  };
	}();
	var _baseCreate = baseCreate$1;

	var baseCreate = _baseCreate,
	  getPrototype$1 = _getPrototype,
	  isPrototype = _isPrototype;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject$1(object) {
	  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
	}
	var _initCloneObject = initCloneObject$1;

	var getTag$3 = _getTag,
	  isObjectLike$4 = isObjectLike_1;

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap$1(value) {
	  return isObjectLike$4(value) && getTag$3(value) == mapTag$2;
	}
	var _baseIsMap = baseIsMap$1;

	var baseIsMap = _baseIsMap,
	  baseUnary$1 = _baseUnary,
	  nodeUtil$1 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
	var isMap_1 = isMap$1;

	var getTag$2 = _getTag,
	  isObjectLike$3 = isObjectLike_1;

	/** `Object#toString` result references. */
	var setTag$2 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet$1(value) {
	  return isObjectLike$3(value) && getTag$2(value) == setTag$2;
	}
	var _baseIsSet = baseIsSet$1;

	var baseIsSet = _baseIsSet,
	  baseUnary = _baseUnary,
	  nodeUtil = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	var isSet_1 = isSet$1;

	var Stack$2 = _Stack,
	  arrayEach = _arrayEach,
	  assignValue$1 = _assignValue,
	  baseAssign = _baseAssign,
	  baseAssignIn = _baseAssignIn,
	  cloneBuffer = _cloneBufferExports,
	  copyArray = _copyArray,
	  copySymbols = _copySymbols,
	  copySymbolsIn = _copySymbolsIn,
	  getAllKeys$1 = _getAllKeys,
	  getAllKeysIn = _getAllKeysIn,
	  getTag$1 = _getTag,
	  initCloneArray = _initCloneArray,
	  initCloneByTag = _initCloneByTag,
	  initCloneObject = _initCloneObject,
	  isArray$9 = isArray_1,
	  isBuffer$1 = isBufferExports,
	  isMap = isMap_1,
	  isObject$2 = isObject_1,
	  isSet = isSet_1,
	  keys$2 = keys_1,
	  keysIn = keysIn_1;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	  CLONE_FLAT_FLAG = 2,
	  CLONE_SYMBOLS_FLAG$1 = 4;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	  arrayTag$1 = '[object Array]',
	  boolTag$1 = '[object Boolean]',
	  dateTag$1 = '[object Date]',
	  errorTag$1 = '[object Error]',
	  funcTag = '[object Function]',
	  genTag = '[object GeneratorFunction]',
	  mapTag$1 = '[object Map]',
	  numberTag$1 = '[object Number]',
	  objectTag$2 = '[object Object]',
	  regexpTag$1 = '[object RegExp]',
	  setTag$1 = '[object Set]',
	  stringTag$1 = '[object String]',
	  symbolTag$2 = '[object Symbol]',
	  weakMapTag = '[object WeakMap]';
	var arrayBufferTag$1 = '[object ArrayBuffer]',
	  dataViewTag$1 = '[object DataView]',
	  float32Tag = '[object Float32Array]',
	  float64Tag = '[object Float64Array]',
	  int8Tag = '[object Int8Array]',
	  int16Tag = '[object Int16Array]',
	  int32Tag = '[object Int32Array]',
	  uint8Tag = '[object Uint8Array]',
	  uint8ClampedTag = '[object Uint8ClampedArray]',
	  uint16Tag = '[object Uint16Array]',
	  uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone$1(value, bitmask, customizer, key, object, stack) {
	  var result,
	    isDeep = bitmask & CLONE_DEEP_FLAG,
	    isFlat = bitmask & CLONE_FLAT_FLAG,
	    isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$2(value)) {
	    return value;
	  }
	  var isArr = isArray$9(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	      isFunc = tag == funcTag || tag == genTag;
	    if (isBuffer$1(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$1 || isFunc && !object) {
	      result = isFlat || isFunc ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack$2());
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);
	  if (isSet(value)) {
	    value.forEach(function (subValue) {
	      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function (subValue, key) {
	      result.set(key, baseClone$1(subValue, bitmask, customizer, key, value, stack));
	    });
	  }
	  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn : keys$2;
	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function (subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue$1(result, key, baseClone$1(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}
	var _baseClone = baseClone$1;

	var baseClone = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone$2(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG);
	}
	var clone_1 = clone$2;
	var clone$3 = /*@__PURE__*/getDefaultExportFromCjs(clone_1);

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor$1(fromRight) {
	  return function (object, iteratee, keysFunc) {
	    var index = -1,
	      iterable = Object(object),
	      props = keysFunc(object),
	      length = props.length;
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	var _createBaseFor = createBaseFor$1;

	var createBaseFor = _createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor$1 = createBaseFor();
	var _baseFor = baseFor$1;

	var baseFor = _baseFor,
	  keys$1 = keys_1;

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn$1(object, iteratee) {
	  return object && baseFor(object, iteratee, keys$1);
	}
	var _baseForOwn = baseForOwn$1;

	var isArrayLike$1 = isArrayLike_1;

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach$1(eachFunc, fromRight) {
	  return function (collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike$1(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	      index = fromRight ? length : -1,
	      iterable = Object(collection);
	    while (fromRight ? index-- : ++index < length) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}
	var _createBaseEach = createBaseEach$1;

	var baseForOwn = _baseForOwn,
	  createBaseEach = _createBaseEach;

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach$2 = createBaseEach(baseForOwn);
	var _baseEach = baseEach$2;

	var baseEach$1 = _baseEach;

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter$1(collection, predicate) {
	  var result = [];
	  baseEach$1(collection, function (value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}
	var _baseFilter = baseFilter$1;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd$1(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	var _setCacheAdd = setCacheAdd$1;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas$1(value) {
	  return this.__data__.has(value);
	}
	var _setCacheHas = setCacheHas$1;

	var MapCache$1 = _MapCache,
	  setCacheAdd = _setCacheAdd,
	  setCacheHas = _setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache$1(values) {
	  var index = -1,
	    length = values == null ? 0 : values.length;
	  this.__data__ = new MapCache$1();
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
	SetCache$1.prototype.has = setCacheHas;
	var _SetCache = SetCache$1;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome$1(array, predicate) {
	  var index = -1,
	    length = array == null ? 0 : array.length;
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	var _arraySome = arraySome$1;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas$1(cache, key) {
	  return cache.has(key);
	}
	var _cacheHas = cacheHas$1;

	var SetCache = _SetCache,
	  arraySome = _arraySome,
	  cacheHas = _cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	  COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
	    arrLength = array.length,
	    othLength = other.length;
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	    result = true,
	    seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	      othValue = other[index];
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function (othValue, othIndex) {
	        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	          return seen.push(othIndex);
	        }
	      })) {
	        result = false;
	        break;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	var _equalArrays = equalArrays$2;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray$1(map) {
	  var index = -1,
	    result = Array(map.size);
	  map.forEach(function (value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	var _mapToArray = mapToArray$1;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray$1(set) {
	  var index = -1,
	    result = Array(set.size);
	  set.forEach(function (value) {
	    result[++index] = value;
	  });
	  return result;
	}
	var _setToArray = setToArray$1;

	var Symbol$2 = _Symbol,
	  Uint8Array$1 = _Uint8Array,
	  eq = eq_1,
	  equalArrays$1 = _equalArrays,
	  mapToArray = _mapToArray,
	  setToArray = _setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	  COMPARE_UNORDERED_FLAG$2 = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	  dateTag = '[object Date]',
	  errorTag = '[object Error]',
	  mapTag = '[object Map]',
	  numberTag = '[object Number]',
	  regexpTag = '[object RegExp]',
	  setTag = '[object Set]',
	  stringTag = '[object String]',
	  symbolTag$1 = '[object Symbol]';
	var arrayBufferTag = '[object ArrayBuffer]',
	  dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
	  symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	    case arrayBufferTag:
	      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == other + '';
	    case mapTag:
	      var convert = mapToArray;
	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
	      convert || (convert = setToArray);
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$2;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;
	    case symbolTag$1:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	var _equalByTag = equalByTag$1;

	var getAllKeys = _getAllKeys;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	    objProps = getAllKeys(object),
	    objLength = objProps.length,
	    othProps = getAllKeys(other),
	    othLength = othProps.length;
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	      othValue = other[key];
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	      othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	var _equalObjects = equalObjects$1;

	var Stack$1 = _Stack,
	  equalArrays = _equalArrays,
	  equalByTag = _equalByTag,
	  equalObjects = _equalObjects,
	  getTag = _getTag,
	  isArray$8 = isArray_1,
	  isBuffer = isBufferExports,
	  isTypedArray = isTypedArray_1;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	  arrayTag = '[object Array]',
	  objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray$8(object),
	    othIsArr = isArray$8(other),
	    objTag = objIsArr ? arrayTag : getTag(object),
	    othTag = othIsArr ? arrayTag : getTag(other);
	  objTag = objTag == argsTag ? objectTag$1 : objTag;
	  othTag = othTag == argsTag ? objectTag$1 : othTag;
	  var objIsObj = objTag == objectTag$1,
	    othIsObj = othTag == objectTag$1,
	    isSameTag = objTag == othTag;
	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack$1());
	    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
	      othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	        othUnwrapped = othIsWrapped ? other.value() : other;
	      stack || (stack = new Stack$1());
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack$1());
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	var _baseIsEqualDeep = baseIsEqualDeep$1;

	var baseIsEqualDeep = _baseIsEqualDeep,
	  isObjectLike$2 = isObjectLike_1;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual$2(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || !isObjectLike$2(value) && !isObjectLike$2(other)) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
	}
	var _baseIsEqual = baseIsEqual$2;

	var Stack = _Stack,
	  baseIsEqual$1 = _baseIsEqual;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	  COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch$1(object, source, matchData, customizer) {
	  var index = matchData.length,
	    length = index,
	    noCustomizer = !customizer;
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	      objValue = object[key],
	      srcValue = data[1];
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack();
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	var _baseIsMatch = baseIsMatch$1;

	var isObject$1 = isObject_1;

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable$2(value) {
	  return value === value && !isObject$1(value);
	}
	var _isStrictComparable = isStrictComparable$2;

	var isStrictComparable$1 = _isStrictComparable,
	  keys = keys_1;

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData$1(object) {
	  var result = keys(object),
	    length = result.length;
	  while (length--) {
	    var key = result[length],
	      value = object[key];
	    result[length] = [key, value, isStrictComparable$1(value)];
	  }
	  return result;
	}
	var _getMatchData = getMatchData$1;

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable$2(key, srcValue) {
	  return function (object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
	  };
	}
	var _matchesStrictComparable = matchesStrictComparable$2;

	var baseIsMatch = _baseIsMatch,
	  getMatchData = _getMatchData,
	  matchesStrictComparable$1 = _matchesStrictComparable;

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches$1(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
	  }
	  return function (object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}
	var _baseMatches = baseMatches$1;

	var baseGetTag$1 = _baseGetTag,
	  isObjectLike$1 = isObjectLike_1;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$3(value) {
	  return typeof value == 'symbol' || isObjectLike$1(value) && baseGetTag$1(value) == symbolTag;
	}
	var isSymbol_1 = isSymbol$3;

	var isArray$7 = isArray_1,
	  isSymbol$2 = isSymbol_1;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	  reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey$3(value, object) {
	  if (isArray$7(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}
	var _isKey = isKey$3;

	var MapCache = _MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize$1(func, resolver) {
	  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function () {
	    var args = arguments,
	      key = resolver ? resolver.apply(this, args) : args[0],
	      cache = memoized.cache;
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize$1.Cache || MapCache)();
	  return memoized;
	}

	// Expose `MapCache`.
	memoize$1.Cache = MapCache;
	var memoize_1 = memoize$1;

	var memoize = memoize_1;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped$1(func) {
	  var result = memoize(func, function (key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });
	  var cache = result.cache;
	  return result;
	}
	var _memoizeCapped = memoizeCapped$1;

	var memoizeCapped = _memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar$1 = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath$2 = memoizeCapped(function (string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName$1, function (match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar$1, '$1') : number || match);
	  });
	  return result;
	});
	var _stringToPath = stringToPath$2;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap$2(array, iteratee) {
	  var index = -1,
	    length = array == null ? 0 : array.length,
	    result = Array(length);
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	var _arrayMap = arrayMap$2;

	var Symbol$1 = _Symbol,
	  arrayMap$1 = _arrayMap,
	  isArray$6 = isArray_1,
	  isSymbol$1 = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	  symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString$1(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$6(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap$1(value, baseToString$1) + '';
	  }
	  if (isSymbol$1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = value + '';
	  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
	}
	var _baseToString = baseToString$1;

	var baseToString = _baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$1(value) {
	  return value == null ? '' : baseToString(value);
	}
	var toString_1 = toString$1;

	var isArray$5 = isArray_1,
	  isKey$2 = _isKey,
	  stringToPath$1 = _stringToPath,
	  toString = toString_1;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath$3(value, object) {
	  if (isArray$5(value)) {
	    return value;
	  }
	  return isKey$2(value, object) ? [value] : stringToPath$1(toString(value));
	}
	var _castPath = castPath$3;

	var isSymbol = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey$5(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = value + '';
	  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
	}
	var _toKey = toKey$5;

	var castPath$2 = _castPath,
	  toKey$4 = _toKey;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet$2(object, path) {
	  path = castPath$2(path, object);
	  var index = 0,
	    length = path.length;
	  while (object != null && index < length) {
	    object = object[toKey$4(path[index++])];
	  }
	  return index && index == length ? object : undefined;
	}
	var _baseGet = baseGet$2;

	var baseGet$1 = _baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get$1(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet$1(object, path);
	  return result === undefined ? defaultValue : result;
	}
	var get_1 = get$1;
	var get$2 = /*@__PURE__*/getDefaultExportFromCjs(get_1);

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn$1(object, key) {
	  return object != null && key in Object(object);
	}
	var _baseHasIn = baseHasIn$1;

	var castPath$1 = _castPath,
	  isArguments = isArguments_1,
	  isArray$4 = isArray_1,
	  isIndex$1 = _isIndex,
	  isLength = isLength_1,
	  toKey$3 = _toKey;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath$1(object, path, hasFunc) {
	  path = castPath$1(path, object);
	  var index = -1,
	    length = path.length,
	    result = false;
	  while (++index < length) {
	    var key = toKey$3(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$4(object) || isArguments(object));
	}
	var _hasPath = hasPath$1;

	var baseHasIn = _baseHasIn,
	  hasPath = _hasPath;

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn$1(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	var hasIn_1 = hasIn$1;

	var baseIsEqual = _baseIsEqual,
	  get = get_1,
	  hasIn = hasIn_1,
	  isKey$1 = _isKey,
	  isStrictComparable = _isStrictComparable,
	  matchesStrictComparable = _matchesStrictComparable,
	  toKey$2 = _toKey;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	  COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty$1(path, srcValue) {
	  if (isKey$1(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey$2(path), srcValue);
	  }
	  return function (object) {
	    var objValue = get(object, path);
	    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}
	var _baseMatchesProperty = baseMatchesProperty$1;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty$1(key) {
	  return function (object) {
	    return object == null ? undefined : object[key];
	  };
	}
	var _baseProperty = baseProperty$1;

	var baseGet = _baseGet;

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep$1(path) {
	  return function (object) {
	    return baseGet(object, path);
	  };
	}
	var _basePropertyDeep = basePropertyDeep$1;

	var baseProperty = _baseProperty,
	  basePropertyDeep = _basePropertyDeep,
	  isKey = _isKey,
	  toKey$1 = _toKey;

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property$1(path) {
	  return isKey(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);
	}
	var property_1 = property$1;

	var baseMatches = _baseMatches,
	  baseMatchesProperty = _baseMatchesProperty,
	  identity = identity_1,
	  isArray$3 = isArray_1,
	  property = property_1;

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee$2(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray$3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
	  }
	  return property(value);
	}
	var _baseIteratee = baseIteratee$2;

	var arrayFilter = _arrayFilter,
	  baseFilter = _baseFilter,
	  baseIteratee$1 = _baseIteratee,
	  isArray$2 = isArray_1;

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 *
	 * // Combining several predicates using `_.overEvery` or `_.overSome`.
	 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	 * // => objects for ['fred', 'barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray$2(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee$1(predicate));
	}
	var filter_1 = filter;
	var filter$1 = /*@__PURE__*/getDefaultExportFromCjs(filter_1);

	var baseEach = _baseEach,
	  isArrayLike = isArrayLike_1;

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap$1(collection, iteratee) {
	  var index = -1,
	    result = isArrayLike(collection) ? Array(collection.length) : [];
	  baseEach(collection, function (value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}
	var _baseMap = baseMap$1;

	var arrayMap = _arrayMap,
	  baseIteratee = _baseIteratee,
	  baseMap = _baseMap,
	  isArray$1 = isArray_1;

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray$1(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee));
	}
	var map_1 = map;
	var map$1 = /*@__PURE__*/getDefaultExportFromCjs(map_1);

	/**
	 * Separator object
	 * Used to space/separate choices group
	 * @constructor
	 * @param {String} line   Separation line content (facultative)
	 */

	class Separator {
	  constructor(line) {
	    this.type = 'separator';
	    this.line = chalk$3.dim(line || Array.from({
	      length: 15
	    }).join(figures.line));
	  }

	  /**
	   * Helper function returning false if object is a separator
	   * @param  {Object} obj object to test against
	   * @return {Boolean}    `false` if object is a separator
	   */
	  static exclude(obj) {
	    return obj.type !== 'separator';
	  }

	  /**
	   * Stringify separator
	   * @return {String} the separator display string
	   */
	  toString() {
	    return this.line;
	  }
	}

	/**
	 * Choice object
	 * Normalize input as choice object
	 * @constructor
	 * @param {Number|String|Object} val  Choice value. If an object is passed, it should contains
	 *                                    at least one of `value` or `name` property
	 */

	class Choice {
	  constructor(val, answers) {
	    // Don't process Choice and Separator object
	    if (val instanceof Choice || val.type === 'separator') {
	      return val;
	    }
	    if (typeof val === 'string' || typeof val === 'number') {
	      this.name = String(val);
	      this.value = val;
	      this.short = String(val);
	    } else {
	      Object.assign(this, val, {
	        name: val.name || val.value,
	        value: 'value' in val ? val.value : val.name,
	        short: val.short || val.name || val.value
	      });
	    }
	    this.disabled = typeof val.disabled === 'function' ? val.disabled(answers) : val.disabled;
	  }
	}

	/**
	 * Choices collection
	 * Collection of multiple `choice` object
	 */
	class Choices {
	  /** @param {Array} choices  All `choice` to keep in the collection */
	  constructor(choices, answers) {
	    this.choices = choices.map(val => {
	      if (val.type === 'separator') {
	        if (!(val instanceof Separator)) {
	          val = new Separator(val.line);
	        }
	        return val;
	      }
	      return new Choice(val, answers);
	    });
	    this.realChoices = this.choices.filter(Separator.exclude).filter(item => !item.disabled);
	    Object.defineProperty(this, 'length', {
	      get() {
	        return this.choices.length;
	      },
	      set(val) {
	        this.choices.length = val;
	      }
	    });
	    Object.defineProperty(this, 'realLength', {
	      get() {
	        return this.realChoices.length;
	      },
	      set() {
	        throw new Error('Cannot set `realLength` of a Choices collection');
	      }
	    });
	  }
	  [Symbol.iterator]() {
	    const data = this.choices;
	    let index = -1;
	    return {
	      next: () => ({
	        value: data[++index],
	        done: !(index in data)
	      })
	    };
	  }

	  /**
	   * Get a valid choice from the collection
	   * @param  {Number} selector  The selected choice index
	   * @return {Choice|Undefined} Return the matched choice or undefined
	   */
	  getChoice(selector) {
	    assert$2(typeof selector === 'number');
	    return this.realChoices[selector];
	  }

	  /**
	   * Get a raw element from the collection
	   * @param  {Number} selector  The selected index value
	   * @return {Choice|Undefined} Return the matched choice or undefined
	   */
	  get(selector) {
	    assert$2(typeof selector === 'number');
	    return this.choices[selector];
	  }

	  /**
	   * Match the valid choices against a where clause
	   * @param  {Object} whereClause Lodash `where` clause
	   * @return {Array}              Matching choices or empty array
	   */
	  where(whereClause) {
	    return filter$1(this.realChoices, whereClause);
	  }

	  /**
	   * Pluck a particular key from the choices
	   * @param  {String} propertyName Property name to select
	   * @return {Array}               Selected properties
	   */
	  pluck(propertyName) {
	    return map$1(this.realChoices, propertyName);
	  }

	  // Expose usual Array methods
	  indexOf(...args) {
	    return this.choices.indexOf(...args);
	  }
	  forEach(...args) {
	    return this.choices.forEach(...args);
	  }
	  filter(...args) {
	    return this.choices.filter(...args);
	  }
	  reduce(...args) {
	    return this.choices.reduce(...args);
	  }
	  find(func) {
	    return this.choices.find(func);
	  }
	  some(func) {
	    return this.choices.some(func);
	  }
	  push(...args) {
	    const objs = args.map(val => new Choice(val));
	    this.choices.push(...objs);
	    this.realChoices = this.choices.filter(Separator.exclude).filter(item => !item.disabled);
	    return this.choices;
	  }
	}

	// MIT lisence
	// from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

	function isatty() {
	  return false;
	}

	function ReadStream() {
	  throw new Error('tty.ReadStream is not implemented');
	}

	function WriteStream() {
	  throw new Error('tty.ReadStream is not implemented');
	}

	var _polyfillNode_tty = {
	  isatty: isatty,
	  ReadStream: ReadStream,
	  WriteStream: WriteStream
	};

	var _polyfillNode_tty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ReadStream: ReadStream,
		WriteStream: WriteStream,
		default: _polyfillNode_tty,
		isatty: isatty
	});

	var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_tty$1);

	var cliWidth_1 = cliWidth;
	function normalizeOpts(options) {
	  const defaultOpts = {
	    defaultWidth: 0,
	    output: process.stdout,
	    tty: require$$1$3
	  };
	  if (!options) {
	    return defaultOpts;
	  }
	  Object.keys(defaultOpts).forEach(function (key) {
	    if (!options[key]) {
	      options[key] = defaultOpts[key];
	    }
	  });
	  return options;
	}
	function cliWidth(options) {
	  const opts = normalizeOpts(options);
	  if (opts.output.getWindowSize) {
	    return opts.output.getWindowSize()[0] || opts.defaultWidth;
	  }
	  if (opts.tty.getWindowSize) {
	    return opts.tty.getWindowSize()[1] || opts.defaultWidth;
	  }
	  if (opts.output.columns) {
	    return opts.output.columns;
	  }
	  if (process.env.CLI_WIDTH) {
	    const width = parseInt(process.env.CLI_WIDTH, 10);
	    if (!isNaN(width) && width !== 0) {
	      return width;
	    }
	  }
	  return opts.defaultWidth;
	}
	var cliWidth$1 = /*@__PURE__*/getDefaultExportFromCjs(cliWidth_1);

	var stringWidth$3 = {exports: {}};

	var ansiRegex$1 = ({
	  onlyFirst = false
	} = {}) => {
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
	  return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};

	const ansiRegex = ansiRegex$1;
	var stripAnsi$3 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
	var stripAnsi$4 = /*@__PURE__*/getDefaultExportFromCjs(stripAnsi$3);

	var isFullwidthCodePoint$2 = {exports: {}};

	/* eslint-disable yoda */
	const isFullwidthCodePoint$1 = codePoint => {
	  if (Number.isNaN(codePoint)) {
	    return false;
	  }

	  // Code points are derived from:
	  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	  if (codePoint >= 0x1100 && (codePoint <= 0x115F ||
	  // Hangul Jamo
	  codePoint === 0x2329 ||
	  // LEFT-POINTING ANGLE BRACKET
	  codePoint === 0x232A ||
	  // RIGHT-POINTING ANGLE BRACKET
	  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
	  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F ||
	  // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
	  0x3250 <= codePoint && codePoint <= 0x4DBF ||
	  // CJK Unified Ideographs .. Yi Radicals
	  0x4E00 <= codePoint && codePoint <= 0xA4C6 ||
	  // Hangul Jamo Extended-A
	  0xA960 <= codePoint && codePoint <= 0xA97C ||
	  // Hangul Syllables
	  0xAC00 <= codePoint && codePoint <= 0xD7A3 ||
	  // CJK Compatibility Ideographs
	  0xF900 <= codePoint && codePoint <= 0xFAFF ||
	  // Vertical Forms
	  0xFE10 <= codePoint && codePoint <= 0xFE19 ||
	  // CJK Compatibility Forms .. Small Form Variants
	  0xFE30 <= codePoint && codePoint <= 0xFE6B ||
	  // Halfwidth and Fullwidth Forms
	  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 ||
	  // Kana Supplement
	  0x1B000 <= codePoint && codePoint <= 0x1B001 ||
	  // Enclosed Ideographic Supplement
	  0x1F200 <= codePoint && codePoint <= 0x1F251 ||
	  // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
	  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
	    return true;
	  }
	  return false;
	};
	isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
	isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;
	var isFullwidthCodePointExports = isFullwidthCodePoint$2.exports;

	var emojiRegex$1 = function () {
	  // https://mths.be/emoji
	  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};

	const stripAnsi$2 = stripAnsi$3;
	const isFullwidthCodePoint = isFullwidthCodePointExports;
	const emojiRegex = emojiRegex$1;
	const stringWidth$1 = string => {
	  if (typeof string !== 'string' || string.length === 0) {
	    return 0;
	  }
	  string = stripAnsi$2(string);
	  if (string.length === 0) {
	    return 0;
	  }
	  string = string.replace(emojiRegex(), '  ');
	  let width = 0;
	  for (let i = 0; i < string.length; i++) {
	    const code = string.codePointAt(i);

	    // Ignore control characters
	    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
	      continue;
	    }

	    // Ignore combining characters
	    if (code >= 0x300 && code <= 0x36F) {
	      continue;
	    }

	    // Surrogates
	    if (code > 0xFFFF) {
	      i++;
	    }
	    width += isFullwidthCodePoint(code) ? 2 : 1;
	  }
	  return width;
	};
	stringWidth$3.exports = stringWidth$1;
	// TODO: remove this in the next major version
	stringWidth$3.exports.default = stringWidth$1;
	var stringWidthExports = stringWidth$3.exports;
	var stringWidth$2 = /*@__PURE__*/getDefaultExportFromCjs(stringWidthExports);

	var ansiStyles$2 = {exports: {}};

	var colorName;
	var hasRequiredColorName;
	function requireColorName() {
	  if (hasRequiredColorName) return colorName;
	  hasRequiredColorName = 1;
	  colorName = {
	    "aliceblue": [240, 248, 255],
	    "antiquewhite": [250, 235, 215],
	    "aqua": [0, 255, 255],
	    "aquamarine": [127, 255, 212],
	    "azure": [240, 255, 255],
	    "beige": [245, 245, 220],
	    "bisque": [255, 228, 196],
	    "black": [0, 0, 0],
	    "blanchedalmond": [255, 235, 205],
	    "blue": [0, 0, 255],
	    "blueviolet": [138, 43, 226],
	    "brown": [165, 42, 42],
	    "burlywood": [222, 184, 135],
	    "cadetblue": [95, 158, 160],
	    "chartreuse": [127, 255, 0],
	    "chocolate": [210, 105, 30],
	    "coral": [255, 127, 80],
	    "cornflowerblue": [100, 149, 237],
	    "cornsilk": [255, 248, 220],
	    "crimson": [220, 20, 60],
	    "cyan": [0, 255, 255],
	    "darkblue": [0, 0, 139],
	    "darkcyan": [0, 139, 139],
	    "darkgoldenrod": [184, 134, 11],
	    "darkgray": [169, 169, 169],
	    "darkgreen": [0, 100, 0],
	    "darkgrey": [169, 169, 169],
	    "darkkhaki": [189, 183, 107],
	    "darkmagenta": [139, 0, 139],
	    "darkolivegreen": [85, 107, 47],
	    "darkorange": [255, 140, 0],
	    "darkorchid": [153, 50, 204],
	    "darkred": [139, 0, 0],
	    "darksalmon": [233, 150, 122],
	    "darkseagreen": [143, 188, 143],
	    "darkslateblue": [72, 61, 139],
	    "darkslategray": [47, 79, 79],
	    "darkslategrey": [47, 79, 79],
	    "darkturquoise": [0, 206, 209],
	    "darkviolet": [148, 0, 211],
	    "deeppink": [255, 20, 147],
	    "deepskyblue": [0, 191, 255],
	    "dimgray": [105, 105, 105],
	    "dimgrey": [105, 105, 105],
	    "dodgerblue": [30, 144, 255],
	    "firebrick": [178, 34, 34],
	    "floralwhite": [255, 250, 240],
	    "forestgreen": [34, 139, 34],
	    "fuchsia": [255, 0, 255],
	    "gainsboro": [220, 220, 220],
	    "ghostwhite": [248, 248, 255],
	    "gold": [255, 215, 0],
	    "goldenrod": [218, 165, 32],
	    "gray": [128, 128, 128],
	    "green": [0, 128, 0],
	    "greenyellow": [173, 255, 47],
	    "grey": [128, 128, 128],
	    "honeydew": [240, 255, 240],
	    "hotpink": [255, 105, 180],
	    "indianred": [205, 92, 92],
	    "indigo": [75, 0, 130],
	    "ivory": [255, 255, 240],
	    "khaki": [240, 230, 140],
	    "lavender": [230, 230, 250],
	    "lavenderblush": [255, 240, 245],
	    "lawngreen": [124, 252, 0],
	    "lemonchiffon": [255, 250, 205],
	    "lightblue": [173, 216, 230],
	    "lightcoral": [240, 128, 128],
	    "lightcyan": [224, 255, 255],
	    "lightgoldenrodyellow": [250, 250, 210],
	    "lightgray": [211, 211, 211],
	    "lightgreen": [144, 238, 144],
	    "lightgrey": [211, 211, 211],
	    "lightpink": [255, 182, 193],
	    "lightsalmon": [255, 160, 122],
	    "lightseagreen": [32, 178, 170],
	    "lightskyblue": [135, 206, 250],
	    "lightslategray": [119, 136, 153],
	    "lightslategrey": [119, 136, 153],
	    "lightsteelblue": [176, 196, 222],
	    "lightyellow": [255, 255, 224],
	    "lime": [0, 255, 0],
	    "limegreen": [50, 205, 50],
	    "linen": [250, 240, 230],
	    "magenta": [255, 0, 255],
	    "maroon": [128, 0, 0],
	    "mediumaquamarine": [102, 205, 170],
	    "mediumblue": [0, 0, 205],
	    "mediumorchid": [186, 85, 211],
	    "mediumpurple": [147, 112, 219],
	    "mediumseagreen": [60, 179, 113],
	    "mediumslateblue": [123, 104, 238],
	    "mediumspringgreen": [0, 250, 154],
	    "mediumturquoise": [72, 209, 204],
	    "mediumvioletred": [199, 21, 133],
	    "midnightblue": [25, 25, 112],
	    "mintcream": [245, 255, 250],
	    "mistyrose": [255, 228, 225],
	    "moccasin": [255, 228, 181],
	    "navajowhite": [255, 222, 173],
	    "navy": [0, 0, 128],
	    "oldlace": [253, 245, 230],
	    "olive": [128, 128, 0],
	    "olivedrab": [107, 142, 35],
	    "orange": [255, 165, 0],
	    "orangered": [255, 69, 0],
	    "orchid": [218, 112, 214],
	    "palegoldenrod": [238, 232, 170],
	    "palegreen": [152, 251, 152],
	    "paleturquoise": [175, 238, 238],
	    "palevioletred": [219, 112, 147],
	    "papayawhip": [255, 239, 213],
	    "peachpuff": [255, 218, 185],
	    "peru": [205, 133, 63],
	    "pink": [255, 192, 203],
	    "plum": [221, 160, 221],
	    "powderblue": [176, 224, 230],
	    "purple": [128, 0, 128],
	    "rebeccapurple": [102, 51, 153],
	    "red": [255, 0, 0],
	    "rosybrown": [188, 143, 143],
	    "royalblue": [65, 105, 225],
	    "saddlebrown": [139, 69, 19],
	    "salmon": [250, 128, 114],
	    "sandybrown": [244, 164, 96],
	    "seagreen": [46, 139, 87],
	    "seashell": [255, 245, 238],
	    "sienna": [160, 82, 45],
	    "silver": [192, 192, 192],
	    "skyblue": [135, 206, 235],
	    "slateblue": [106, 90, 205],
	    "slategray": [112, 128, 144],
	    "slategrey": [112, 128, 144],
	    "snow": [255, 250, 250],
	    "springgreen": [0, 255, 127],
	    "steelblue": [70, 130, 180],
	    "tan": [210, 180, 140],
	    "teal": [0, 128, 128],
	    "thistle": [216, 191, 216],
	    "tomato": [255, 99, 71],
	    "turquoise": [64, 224, 208],
	    "violet": [238, 130, 238],
	    "wheat": [245, 222, 179],
	    "white": [255, 255, 255],
	    "whitesmoke": [245, 245, 245],
	    "yellow": [255, 255, 0],
	    "yellowgreen": [154, 205, 50]
	  };
	  return colorName;
	}

	/* MIT license */
	var conversions;
	var hasRequiredConversions;
	function requireConversions() {
	  if (hasRequiredConversions) return conversions;
	  hasRequiredConversions = 1;
	  /* eslint-disable no-mixed-operators */
	  const cssKeywords = requireColorName();

	  // NOTE: conversions should only return primitive values (i.e. arrays, or
	  //       values that give correct `typeof` results).
	  //       do not use box values types (i.e. Number(), String(), etc.)

	  const reverseKeywords = {};
	  for (const key of Object.keys(cssKeywords)) {
	    reverseKeywords[cssKeywords[key]] = key;
	  }
	  const convert = {
	    rgb: {
	      channels: 3,
	      labels: 'rgb'
	    },
	    hsl: {
	      channels: 3,
	      labels: 'hsl'
	    },
	    hsv: {
	      channels: 3,
	      labels: 'hsv'
	    },
	    hwb: {
	      channels: 3,
	      labels: 'hwb'
	    },
	    cmyk: {
	      channels: 4,
	      labels: 'cmyk'
	    },
	    xyz: {
	      channels: 3,
	      labels: 'xyz'
	    },
	    lab: {
	      channels: 3,
	      labels: 'lab'
	    },
	    lch: {
	      channels: 3,
	      labels: 'lch'
	    },
	    hex: {
	      channels: 1,
	      labels: ['hex']
	    },
	    keyword: {
	      channels: 1,
	      labels: ['keyword']
	    },
	    ansi16: {
	      channels: 1,
	      labels: ['ansi16']
	    },
	    ansi256: {
	      channels: 1,
	      labels: ['ansi256']
	    },
	    hcg: {
	      channels: 3,
	      labels: ['h', 'c', 'g']
	    },
	    apple: {
	      channels: 3,
	      labels: ['r16', 'g16', 'b16']
	    },
	    gray: {
	      channels: 1,
	      labels: ['gray']
	    }
	  };
	  conversions = convert;

	  // Hide .channels and .labels properties
	  for (const model of Object.keys(convert)) {
	    if (!('channels' in convert[model])) {
	      throw new Error('missing channels property: ' + model);
	    }
	    if (!('labels' in convert[model])) {
	      throw new Error('missing channel labels property: ' + model);
	    }
	    if (convert[model].labels.length !== convert[model].channels) {
	      throw new Error('channel and label counts mismatch: ' + model);
	    }
	    const {
	      channels,
	      labels
	    } = convert[model];
	    delete convert[model].channels;
	    delete convert[model].labels;
	    Object.defineProperty(convert[model], 'channels', {
	      value: channels
	    });
	    Object.defineProperty(convert[model], 'labels', {
	      value: labels
	    });
	  }
	  convert.rgb.hsl = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const min = Math.min(r, g, b);
	    const max = Math.max(r, g, b);
	    const delta = max - min;
	    let h;
	    let s;
	    if (max === min) {
	      h = 0;
	    } else if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else if (b === max) {
	      h = 4 + (r - g) / delta;
	    }
	    h = Math.min(h * 60, 360);
	    if (h < 0) {
	      h += 360;
	    }
	    const l = (min + max) / 2;
	    if (max === min) {
	      s = 0;
	    } else if (l <= 0.5) {
	      s = delta / (max + min);
	    } else {
	      s = delta / (2 - max - min);
	    }
	    return [h, s * 100, l * 100];
	  };
	  convert.rgb.hsv = function (rgb) {
	    let rdif;
	    let gdif;
	    let bdif;
	    let h;
	    let s;
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const v = Math.max(r, g, b);
	    const diff = v - Math.min(r, g, b);
	    const diffc = function (c) {
	      return (v - c) / 6 / diff + 1 / 2;
	    };
	    if (diff === 0) {
	      h = 0;
	      s = 0;
	    } else {
	      s = diff / v;
	      rdif = diffc(r);
	      gdif = diffc(g);
	      bdif = diffc(b);
	      if (r === v) {
	        h = bdif - gdif;
	      } else if (g === v) {
	        h = 1 / 3 + rdif - bdif;
	      } else if (b === v) {
	        h = 2 / 3 + gdif - rdif;
	      }
	      if (h < 0) {
	        h += 1;
	      } else if (h > 1) {
	        h -= 1;
	      }
	    }
	    return [h * 360, s * 100, v * 100];
	  };
	  convert.rgb.hwb = function (rgb) {
	    const r = rgb[0];
	    const g = rgb[1];
	    let b = rgb[2];
	    const h = convert.rgb.hsl(rgb)[0];
	    const w = 1 / 255 * Math.min(r, Math.min(g, b));
	    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
	    return [h, w * 100, b * 100];
	  };
	  convert.rgb.cmyk = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const k = Math.min(1 - r, 1 - g, 1 - b);
	    const c = (1 - r - k) / (1 - k) || 0;
	    const m = (1 - g - k) / (1 - k) || 0;
	    const y = (1 - b - k) / (1 - k) || 0;
	    return [c * 100, m * 100, y * 100, k * 100];
	  };
	  function comparativeDistance(x, y) {
	    /*
	    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	    */
	    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
	  }
	  convert.rgb.keyword = function (rgb) {
	    const reversed = reverseKeywords[rgb];
	    if (reversed) {
	      return reversed;
	    }
	    let currentClosestDistance = Infinity;
	    let currentClosestKeyword;
	    for (const keyword of Object.keys(cssKeywords)) {
	      const value = cssKeywords[keyword];

	      // Compute comparative distance
	      const distance = comparativeDistance(rgb, value);

	      // Check if its less, if so set as closest
	      if (distance < currentClosestDistance) {
	        currentClosestDistance = distance;
	        currentClosestKeyword = keyword;
	      }
	    }
	    return currentClosestKeyword;
	  };
	  convert.keyword.rgb = function (keyword) {
	    return cssKeywords[keyword];
	  };
	  convert.rgb.xyz = function (rgb) {
	    let r = rgb[0] / 255;
	    let g = rgb[1] / 255;
	    let b = rgb[2] / 255;

	    // Assume sRGB
	    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
	    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
	    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
	    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
	    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
	    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
	    return [x * 100, y * 100, z * 100];
	  };
	  convert.rgb.lab = function (rgb) {
	    const xyz = convert.rgb.xyz(rgb);
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.hsl.rgb = function (hsl) {
	    const h = hsl[0] / 360;
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    let t2;
	    let t3;
	    let val;
	    if (s === 0) {
	      val = l * 255;
	      return [val, val, val];
	    }
	    if (l < 0.5) {
	      t2 = l * (1 + s);
	    } else {
	      t2 = l + s - l * s;
	    }
	    const t1 = 2 * l - t2;
	    const rgb = [0, 0, 0];
	    for (let i = 0; i < 3; i++) {
	      t3 = h + 1 / 3 * -(i - 1);
	      if (t3 < 0) {
	        t3++;
	      }
	      if (t3 > 1) {
	        t3--;
	      }
	      if (6 * t3 < 1) {
	        val = t1 + (t2 - t1) * 6 * t3;
	      } else if (2 * t3 < 1) {
	        val = t2;
	      } else if (3 * t3 < 2) {
	        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	      } else {
	        val = t1;
	      }
	      rgb[i] = val * 255;
	    }
	    return rgb;
	  };
	  convert.hsl.hsv = function (hsl) {
	    const h = hsl[0];
	    let s = hsl[1] / 100;
	    let l = hsl[2] / 100;
	    let smin = s;
	    const lmin = Math.max(l, 0.01);
	    l *= 2;
	    s *= l <= 1 ? l : 2 - l;
	    smin *= lmin <= 1 ? lmin : 2 - lmin;
	    const v = (l + s) / 2;
	    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
	    return [h, sv * 100, v * 100];
	  };
	  convert.hsv.rgb = function (hsv) {
	    const h = hsv[0] / 60;
	    const s = hsv[1] / 100;
	    let v = hsv[2] / 100;
	    const hi = Math.floor(h) % 6;
	    const f = h - Math.floor(h);
	    const p = 255 * v * (1 - s);
	    const q = 255 * v * (1 - s * f);
	    const t = 255 * v * (1 - s * (1 - f));
	    v *= 255;
	    switch (hi) {
	      case 0:
	        return [v, t, p];
	      case 1:
	        return [q, v, p];
	      case 2:
	        return [p, v, t];
	      case 3:
	        return [p, q, v];
	      case 4:
	        return [t, p, v];
	      case 5:
	        return [v, p, q];
	    }
	  };
	  convert.hsv.hsl = function (hsv) {
	    const h = hsv[0];
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const vmin = Math.max(v, 0.01);
	    let sl;
	    let l;
	    l = (2 - s) * v;
	    const lmin = (2 - s) * vmin;
	    sl = s * vmin;
	    sl /= lmin <= 1 ? lmin : 2 - lmin;
	    sl = sl || 0;
	    l /= 2;
	    return [h, sl * 100, l * 100];
	  };

	  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	  convert.hwb.rgb = function (hwb) {
	    const h = hwb[0] / 360;
	    let wh = hwb[1] / 100;
	    let bl = hwb[2] / 100;
	    const ratio = wh + bl;
	    let f;

	    // Wh + bl cant be > 1
	    if (ratio > 1) {
	      wh /= ratio;
	      bl /= ratio;
	    }
	    const i = Math.floor(6 * h);
	    const v = 1 - bl;
	    f = 6 * h - i;
	    if ((i & 0x01) !== 0) {
	      f = 1 - f;
	    }
	    const n = wh + f * (v - wh); // Linear interpolation

	    let r;
	    let g;
	    let b;
	    /* eslint-disable max-statements-per-line,no-multi-spaces */
	    switch (i) {
	      default:
	      case 6:
	      case 0:
	        r = v;
	        g = n;
	        b = wh;
	        break;
	      case 1:
	        r = n;
	        g = v;
	        b = wh;
	        break;
	      case 2:
	        r = wh;
	        g = v;
	        b = n;
	        break;
	      case 3:
	        r = wh;
	        g = n;
	        b = v;
	        break;
	      case 4:
	        r = n;
	        g = wh;
	        b = v;
	        break;
	      case 5:
	        r = v;
	        g = wh;
	        b = n;
	        break;
	    }
	    /* eslint-enable max-statements-per-line,no-multi-spaces */

	    return [r * 255, g * 255, b * 255];
	  };
	  convert.cmyk.rgb = function (cmyk) {
	    const c = cmyk[0] / 100;
	    const m = cmyk[1] / 100;
	    const y = cmyk[2] / 100;
	    const k = cmyk[3] / 100;
	    const r = 1 - Math.min(1, c * (1 - k) + k);
	    const g = 1 - Math.min(1, m * (1 - k) + k);
	    const b = 1 - Math.min(1, y * (1 - k) + k);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.rgb = function (xyz) {
	    const x = xyz[0] / 100;
	    const y = xyz[1] / 100;
	    const z = xyz[2] / 100;
	    let r;
	    let g;
	    let b;
	    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
	    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
	    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

	    // Assume sRGB
	    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
	    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
	    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
	    r = Math.min(Math.max(0, r), 1);
	    g = Math.min(Math.max(0, g), 1);
	    b = Math.min(Math.max(0, b), 1);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.lab = function (xyz) {
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.lab.xyz = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let x;
	    let y;
	    let z;
	    y = (l + 16) / 116;
	    x = a / 500 + y;
	    z = y - b / 200;
	    const y2 = y ** 3;
	    const x2 = x ** 3;
	    const z2 = z ** 3;
	    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
	    x *= 95.047;
	    y *= 100;
	    z *= 108.883;
	    return [x, y, z];
	  };
	  convert.lab.lch = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let h;
	    const hr = Math.atan2(b, a);
	    h = hr * 360 / 2 / Math.PI;
	    if (h < 0) {
	      h += 360;
	    }
	    const c = Math.sqrt(a * a + b * b);
	    return [l, c, h];
	  };
	  convert.lch.lab = function (lch) {
	    const l = lch[0];
	    const c = lch[1];
	    const h = lch[2];
	    const hr = h / 360 * 2 * Math.PI;
	    const a = c * Math.cos(hr);
	    const b = c * Math.sin(hr);
	    return [l, a, b];
	  };
	  convert.rgb.ansi16 = function (args, saturation = null) {
	    const [r, g, b] = args;
	    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	    value = Math.round(value / 50);
	    if (value === 0) {
	      return 30;
	    }
	    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
	    if (value === 2) {
	      ansi += 60;
	    }
	    return ansi;
	  };
	  convert.hsv.ansi16 = function (args) {
	    // Optimization here; we already know the value and don't need to get
	    // it converted for us.
	    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	  };
	  convert.rgb.ansi256 = function (args) {
	    const r = args[0];
	    const g = args[1];
	    const b = args[2];

	    // We use the extended greyscale palette here, with the exception of
	    // black and white. normal palette only has 4 greyscale shades.
	    if (r === g && g === b) {
	      if (r < 8) {
	        return 16;
	      }
	      if (r > 248) {
	        return 231;
	      }
	      return Math.round((r - 8) / 247 * 24) + 232;
	    }
	    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	    return ansi;
	  };
	  convert.ansi16.rgb = function (args) {
	    let color = args % 10;

	    // Handle greyscale
	    if (color === 0 || color === 7) {
	      if (args > 50) {
	        color += 3.5;
	      }
	      color = color / 10.5 * 255;
	      return [color, color, color];
	    }
	    const mult = (~~(args > 50) + 1) * 0.5;
	    const r = (color & 1) * mult * 255;
	    const g = (color >> 1 & 1) * mult * 255;
	    const b = (color >> 2 & 1) * mult * 255;
	    return [r, g, b];
	  };
	  convert.ansi256.rgb = function (args) {
	    // Handle greyscale
	    if (args >= 232) {
	      const c = (args - 232) * 10 + 8;
	      return [c, c, c];
	    }
	    args -= 16;
	    let rem;
	    const r = Math.floor(args / 36) / 5 * 255;
	    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	    const b = rem % 6 / 5 * 255;
	    return [r, g, b];
	  };
	  convert.rgb.hex = function (args) {
	    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.hex.rgb = function (args) {
	    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	    if (!match) {
	      return [0, 0, 0];
	    }
	    let colorString = match[0];
	    if (match[0].length === 3) {
	      colorString = colorString.split('').map(char => {
	        return char + char;
	      }).join('');
	    }
	    const integer = parseInt(colorString, 16);
	    const r = integer >> 16 & 0xFF;
	    const g = integer >> 8 & 0xFF;
	    const b = integer & 0xFF;
	    return [r, g, b];
	  };
	  convert.rgb.hcg = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const max = Math.max(Math.max(r, g), b);
	    const min = Math.min(Math.min(r, g), b);
	    const chroma = max - min;
	    let grayscale;
	    let hue;
	    if (chroma < 1) {
	      grayscale = min / (1 - chroma);
	    } else {
	      grayscale = 0;
	    }
	    if (chroma <= 0) {
	      hue = 0;
	    } else if (max === r) {
	      hue = (g - b) / chroma % 6;
	    } else if (max === g) {
	      hue = 2 + (b - r) / chroma;
	    } else {
	      hue = 4 + (r - g) / chroma;
	    }
	    hue /= 6;
	    hue %= 1;
	    return [hue * 360, chroma * 100, grayscale * 100];
	  };
	  convert.hsl.hcg = function (hsl) {
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
	    let f = 0;
	    if (c < 1.0) {
	      f = (l - 0.5 * c) / (1.0 - c);
	    }
	    return [hsl[0], c * 100, f * 100];
	  };
	  convert.hsv.hcg = function (hsv) {
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const c = s * v;
	    let f = 0;
	    if (c < 1.0) {
	      f = (v - c) / (1 - c);
	    }
	    return [hsv[0], c * 100, f * 100];
	  };
	  convert.hcg.rgb = function (hcg) {
	    const h = hcg[0] / 360;
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    if (c === 0.0) {
	      return [g * 255, g * 255, g * 255];
	    }
	    const pure = [0, 0, 0];
	    const hi = h % 1 * 6;
	    const v = hi % 1;
	    const w = 1 - v;
	    let mg = 0;

	    /* eslint-disable max-statements-per-line */
	    switch (Math.floor(hi)) {
	      case 0:
	        pure[0] = 1;
	        pure[1] = v;
	        pure[2] = 0;
	        break;
	      case 1:
	        pure[0] = w;
	        pure[1] = 1;
	        pure[2] = 0;
	        break;
	      case 2:
	        pure[0] = 0;
	        pure[1] = 1;
	        pure[2] = v;
	        break;
	      case 3:
	        pure[0] = 0;
	        pure[1] = w;
	        pure[2] = 1;
	        break;
	      case 4:
	        pure[0] = v;
	        pure[1] = 0;
	        pure[2] = 1;
	        break;
	      default:
	        pure[0] = 1;
	        pure[1] = 0;
	        pure[2] = w;
	    }
	    /* eslint-enable max-statements-per-line */

	    mg = (1.0 - c) * g;
	    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
	  };
	  convert.hcg.hsv = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    let f = 0;
	    if (v > 0.0) {
	      f = c / v;
	    }
	    return [hcg[0], f * 100, v * 100];
	  };
	  convert.hcg.hsl = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const l = g * (1.0 - c) + 0.5 * c;
	    let s = 0;
	    if (l > 0.0 && l < 0.5) {
	      s = c / (2 * l);
	    } else if (l >= 0.5 && l < 1.0) {
	      s = c / (2 * (1 - l));
	    }
	    return [hcg[0], s * 100, l * 100];
	  };
	  convert.hcg.hwb = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    return [hcg[0], (v - c) * 100, (1 - v) * 100];
	  };
	  convert.hwb.hcg = function (hwb) {
	    const w = hwb[1] / 100;
	    const b = hwb[2] / 100;
	    const v = 1 - b;
	    const c = v - w;
	    let g = 0;
	    if (c < 1) {
	      g = (v - c) / (1 - c);
	    }
	    return [hwb[0], c * 100, g * 100];
	  };
	  convert.apple.rgb = function (apple) {
	    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
	  };
	  convert.rgb.apple = function (rgb) {
	    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
	  };
	  convert.gray.rgb = function (args) {
	    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	  };
	  convert.gray.hsl = function (args) {
	    return [0, 0, args[0]];
	  };
	  convert.gray.hsv = convert.gray.hsl;
	  convert.gray.hwb = function (gray) {
	    return [0, 100, gray[0]];
	  };
	  convert.gray.cmyk = function (gray) {
	    return [0, 0, 0, gray[0]];
	  };
	  convert.gray.lab = function (gray) {
	    return [gray[0], 0, 0];
	  };
	  convert.gray.hex = function (gray) {
	    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	    const integer = (val << 16) + (val << 8) + val;
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.rgb.gray = function (rgb) {
	    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	    return [val / 255 * 100];
	  };
	  return conversions;
	}

	var route;
	var hasRequiredRoute;
	function requireRoute() {
	  if (hasRequiredRoute) return route;
	  hasRequiredRoute = 1;
	  const conversions = requireConversions();

	  /*
	  	This function routes a model to all other models.
	  		all functions that are routed have a property `.conversion` attached
	  	to the returned synthetic function. This property is an array
	  	of strings, each with the steps in between the 'from' and 'to'
	  	color models (inclusive).
	  		conversions that are not possible simply are not included.
	  */

	  function buildGraph() {
	    const graph = {};
	    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
	    const models = Object.keys(conversions);
	    for (let len = models.length, i = 0; i < len; i++) {
	      graph[models[i]] = {
	        // http://jsperf.com/1-vs-infinity
	        // micro-opt, but this is simple.
	        distance: -1,
	        parent: null
	      };
	    }
	    return graph;
	  }

	  // https://en.wikipedia.org/wiki/Breadth-first_search
	  function deriveBFS(fromModel) {
	    const graph = buildGraph();
	    const queue = [fromModel]; // Unshift -> queue -> pop

	    graph[fromModel].distance = 0;
	    while (queue.length) {
	      const current = queue.pop();
	      const adjacents = Object.keys(conversions[current]);
	      for (let len = adjacents.length, i = 0; i < len; i++) {
	        const adjacent = adjacents[i];
	        const node = graph[adjacent];
	        if (node.distance === -1) {
	          node.distance = graph[current].distance + 1;
	          node.parent = current;
	          queue.unshift(adjacent);
	        }
	      }
	    }
	    return graph;
	  }
	  function link(from, to) {
	    return function (args) {
	      return to(from(args));
	    };
	  }
	  function wrapConversion(toModel, graph) {
	    const path = [graph[toModel].parent, toModel];
	    let fn = conversions[graph[toModel].parent][toModel];
	    let cur = graph[toModel].parent;
	    while (graph[cur].parent) {
	      path.unshift(graph[cur].parent);
	      fn = link(conversions[graph[cur].parent][cur], fn);
	      cur = graph[cur].parent;
	    }
	    fn.conversion = path;
	    return fn;
	  }
	  route = function (fromModel) {
	    const graph = deriveBFS(fromModel);
	    const conversion = {};
	    const models = Object.keys(graph);
	    for (let len = models.length, i = 0; i < len; i++) {
	      const toModel = models[i];
	      const node = graph[toModel];
	      if (node.parent === null) {
	        // No possible conversion, or this node is the source model.
	        continue;
	      }
	      conversion[toModel] = wrapConversion(toModel, graph);
	    }
	    return conversion;
	  };
	  return route;
	}

	var colorConvert;
	var hasRequiredColorConvert;
	function requireColorConvert() {
	  if (hasRequiredColorConvert) return colorConvert;
	  hasRequiredColorConvert = 1;
	  const conversions = requireConversions();
	  const route = requireRoute();
	  const convert = {};
	  const models = Object.keys(conversions);
	  function wrapRaw(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      return fn(args);
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  function wrapRounded(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      const result = fn(args);

	      // We're assuming the result is an array here.
	      // see notice in conversions.js; don't use box types
	      // in conversion functions.
	      if (typeof result === 'object') {
	        for (let len = result.length, i = 0; i < len; i++) {
	          result[i] = Math.round(result[i]);
	        }
	      }
	      return result;
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  models.forEach(fromModel => {
	    convert[fromModel] = {};
	    Object.defineProperty(convert[fromModel], 'channels', {
	      value: conversions[fromModel].channels
	    });
	    Object.defineProperty(convert[fromModel], 'labels', {
	      value: conversions[fromModel].labels
	    });
	    const routes = route(fromModel);
	    const routeModels = Object.keys(routes);
	    routeModels.forEach(toModel => {
	      const fn = routes[toModel];
	      convert[fromModel][toModel] = wrapRounded(fn);
	      convert[fromModel][toModel].raw = wrapRaw(fn);
	    });
	  });
	  colorConvert = convert;
	  return colorConvert;
	}

	ansiStyles$2.exports;
	(function (module) {

	  const wrapAnsi16 = (fn, offset) => (...args) => {
	    const code = fn(...args);
	    return `\u001B[${code + offset}m`;
	  };
	  const wrapAnsi256 = (fn, offset) => (...args) => {
	    const code = fn(...args);
	    return `\u001B[${38 + offset};5;${code}m`;
	  };
	  const wrapAnsi16m = (fn, offset) => (...args) => {
	    const rgb = fn(...args);
	    return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
	  };
	  const ansi2ansi = n => n;
	  const rgb2rgb = (r, g, b) => [r, g, b];
	  const setLazyProperty = (object, property, get) => {
	    Object.defineProperty(object, property, {
	      get: () => {
	        const value = get();
	        Object.defineProperty(object, property, {
	          value,
	          enumerable: true,
	          configurable: true
	        });
	        return value;
	      },
	      enumerable: true,
	      configurable: true
	    });
	  };

	  /** @type {typeof import('color-convert')} */
	  let colorConvert;
	  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	    if (colorConvert === undefined) {
	      colorConvert = requireColorConvert();
	    }
	    const offset = isBackground ? 10 : 0;
	    const styles = {};
	    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
	      const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
	      if (sourceSpace === targetSpace) {
	        styles[name] = wrap(identity, offset);
	      } else if (typeof suite === 'object') {
	        styles[name] = wrap(suite[targetSpace], offset);
	      }
	    }
	    return styles;
	  };
	  function assembleStyles() {
	    const codes = new Map();
	    const styles = {
	      modifier: {
	        reset: [0, 0],
	        // 21 isn't widely supported and 22 does the same thing
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        // Bright color
	        blackBright: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        // Bright color
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    };

	    // Alias bright black as gray (and grey)
	    styles.color.gray = styles.color.blackBright;
	    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	    styles.color.grey = styles.color.blackBright;
	    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
	    for (const [groupName, group] of Object.entries(styles)) {
	      for (const [styleName, style] of Object.entries(group)) {
	        styles[styleName] = {
	          open: `\u001B[${style[0]}m`,
	          close: `\u001B[${style[1]}m`
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }
	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	    }
	    Object.defineProperty(styles, 'codes', {
	      value: codes,
	      enumerable: false
	    });
	    styles.color.close = '\u001B[39m';
	    styles.bgColor.close = '\u001B[49m';
	    setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	    setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	    setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	    setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	    setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	    setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
	    return styles;
	  }

	  // Make the export immutable
	  Object.defineProperty(module, 'exports', {
	    enumerable: true,
	    get: assembleStyles
	  });
	})(ansiStyles$2);
	var ansiStylesExports = ansiStyles$2.exports;

	const stringWidth = stringWidthExports;
	const stripAnsi$1 = stripAnsi$3;
	const ansiStyles$1 = ansiStylesExports;
	const ESCAPES = new Set(['\u001B', '\u009B']);
	const END_CODE = 39;
	const wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;

	// Calculate the length of words split on ' ', ignoring
	// the extra characters added by ansi escape codes
	const wordLengths = string => string.split(' ').map(character => stringWidth(character));

	// Wrap a long word across multiple rows
	// Ansi escape codes do not count towards length
	const wrapWord = (rows, word, columns) => {
	  const characters = [...word];
	  let isInsideEscape = false;
	  let visible = stringWidth(stripAnsi$1(rows[rows.length - 1]));
	  for (const [index, character] of characters.entries()) {
	    const characterLength = stringWidth(character);
	    if (visible + characterLength <= columns) {
	      rows[rows.length - 1] += character;
	    } else {
	      rows.push(character);
	      visible = 0;
	    }
	    if (ESCAPES.has(character)) {
	      isInsideEscape = true;
	    } else if (isInsideEscape && character === 'm') {
	      isInsideEscape = false;
	      continue;
	    }
	    if (isInsideEscape) {
	      continue;
	    }
	    visible += characterLength;
	    if (visible === columns && index < characters.length - 1) {
	      rows.push('');
	      visible = 0;
	    }
	  }

	  // It's possible that the last row we copy over is only
	  // ansi escape characters, handle this edge-case
	  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
	    rows[rows.length - 2] += rows.pop();
	  }
	};

	// Trims spaces from a string ignoring invisible sequences
	const stringVisibleTrimSpacesRight = str => {
	  const words = str.split(' ');
	  let last = words.length;
	  while (last > 0) {
	    if (stringWidth(words[last - 1]) > 0) {
	      break;
	    }
	    last--;
	  }
	  if (last === words.length) {
	    return str;
	  }
	  return words.slice(0, last).join(' ') + words.slice(last).join('');
	};

	// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
	//
	// 'hard' will never allow a string to take up more than columns characters
	//
	// 'soft' allows long words to expand past the column length
	const exec = (string, columns, options = {}) => {
	  if (options.trim !== false && string.trim() === '') {
	    return '';
	  }
	  let pre = '';
	  let ret = '';
	  let escapeCode;
	  const lengths = wordLengths(string);
	  let rows = [''];
	  for (const [index, word] of string.split(' ').entries()) {
	    if (options.trim !== false) {
	      rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
	    }
	    let rowLength = stringWidth(rows[rows.length - 1]);
	    if (index !== 0) {
	      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
	        // If we start with a new word but the current row length equals the length of the columns, add a new row
	        rows.push('');
	        rowLength = 0;
	      }
	      if (rowLength > 0 || options.trim === false) {
	        rows[rows.length - 1] += ' ';
	        rowLength++;
	      }
	    }

	    // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
	    if (options.hard && lengths[index] > columns) {
	      const remainingColumns = columns - rowLength;
	      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
	      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
	      if (breaksStartingNextLine < breaksStartingThisLine) {
	        rows.push('');
	      }
	      wrapWord(rows, word, columns);
	      continue;
	    }
	    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
	      if (options.wordWrap === false && rowLength < columns) {
	        wrapWord(rows, word, columns);
	        continue;
	      }
	      rows.push('');
	    }
	    if (rowLength + lengths[index] > columns && options.wordWrap === false) {
	      wrapWord(rows, word, columns);
	      continue;
	    }
	    rows[rows.length - 1] += word;
	  }
	  if (options.trim !== false) {
	    rows = rows.map(stringVisibleTrimSpacesRight);
	  }
	  pre = rows.join('\n');
	  for (const [index, character] of [...pre].entries()) {
	    ret += character;
	    if (ESCAPES.has(character)) {
	      const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
	      escapeCode = code === END_CODE ? null : code;
	    }
	    const code = ansiStyles$1.codes.get(Number(escapeCode));
	    if (escapeCode && code) {
	      if (pre[index + 1] === '\n') {
	        ret += wrapAnsi(code);
	      } else if (character === '\n') {
	        ret += wrapAnsi(escapeCode);
	      }
	    }
	  }
	  return ret;
	};

	// For each newline, invoke the method separately
	var wrapAnsi_1 = (string, columns, options) => {
	  return String(string).normalize().replace(/\r\n/g, '\n').split('\n').map(line => exec(line, columns, options)).join('\n');
	};
	var wrapAnsi$1 = /*@__PURE__*/getDefaultExportFromCjs(wrapAnsi_1);

	var ora$1 = {exports: {}};

	var _polyfillNode_readline = {};

	var _polyfillNode_readline$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _polyfillNode_readline
	});

	var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_readline$1);

	/*
	The MIT License (MIT)

	Copyright (c) 2016 CoderPuppy

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	*/
	var _endianness;
	function endianness() {
	  if (typeof _endianness === 'undefined') {
	    var a = new ArrayBuffer(2);
	    var b = new Uint8Array(a);
	    var c = new Uint16Array(a);
	    b[0] = 1;
	    b[1] = 2;
	    if (c[0] === 258) {
	      _endianness = 'BE';
	    } else if (c[0] === 513){
	      _endianness = 'LE';
	    } else {
	      throw new Error('unable to figure out endianess');
	    }
	  }
	  return _endianness;
	}

	function hostname() {
	  if (typeof global$1.location !== 'undefined') {
	    return global$1.location.hostname
	  } else return '';
	}

	function loadavg() {
	  return [];
	}

	function uptime() {
	  return 0;
	}

	function freemem() {
	  return Number.MAX_VALUE;
	}

	function totalmem() {
	  return Number.MAX_VALUE;
	}

	function cpus() {
	  return [];
	}

	function type$1() {
	  return 'Browser';
	}

	function release () {
	  if (typeof global$1.navigator !== 'undefined') {
	    return global$1.navigator.appVersion;
	  }
	  return '';
	}

	function networkInterfaces () {
	  return {};
	}

	function getNetworkInterfaces () {
	  return {};
	}

	function arch() {
	  return 'javascript';
	}

	function platform() {
	  return 'browser';
	}

	function tmpDir$1() {
	  return '/tmp';
	}
	var tmpdir = tmpDir$1;

	var EOL = '\n';

	function homedir(){
	  return '$HOME'
	}

	var _polyfillNode_os = {
	  homedir: homedir,
	  EOL: EOL,
	  arch: arch,
	  platform: platform,
	  tmpdir: tmpdir,
	  tmpDir: tmpDir$1,
	  networkInterfaces:networkInterfaces,
	  getNetworkInterfaces: getNetworkInterfaces,
	  release: release,
	  type: type$1,
	  cpus: cpus,
	  totalmem: totalmem,
	  freemem: freemem,
	  uptime: uptime,
	  loadavg: loadavg,
	  hostname: hostname,
	  endianness: endianness,
	};

	var _polyfillNode_os$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EOL: EOL,
		arch: arch,
		cpus: cpus,
		default: _polyfillNode_os,
		endianness: endianness,
		freemem: freemem,
		getNetworkInterfaces: getNetworkInterfaces,
		homedir: homedir,
		hostname: hostname,
		loadavg: loadavg,
		networkInterfaces: networkInterfaces,
		platform: platform,
		release: release,
		tmpDir: tmpDir$1,
		tmpdir: tmpdir,
		totalmem: totalmem,
		type: type$1,
		uptime: uptime
	});

	var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_os$1);

	var hasFlag$1 = (flag, argv = process.argv) => {
	  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
	  const position = argv.indexOf(prefix + flag);
	  const terminatorPosition = argv.indexOf('--');
	  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};

	const os = require$$0$2;
	const tty = require$$1$3;
	const hasFlag = hasFlag$1;
	const {
	  env
	} = process;
	let forceColor;
	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
	  forceColor = 0;
	} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
	  forceColor = 1;
	}
	if ('FORCE_COLOR' in env) {
	  if (env.FORCE_COLOR === 'true') {
	    forceColor = 1;
	  } else if (env.FORCE_COLOR === 'false') {
	    forceColor = 0;
	  } else {
	    forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	  }
	}
	function translateLevel(level) {
	  if (level === 0) {
	    return false;
	  }
	  return {
	    level,
	    hasBasic: true,
	    has256: level >= 2,
	    has16m: level >= 3
	  };
	}
	function supportsColor(haveStream, streamIsTTY) {
	  if (forceColor === 0) {
	    return 0;
	  }
	  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
	    return 3;
	  }
	  if (hasFlag('color=256')) {
	    return 2;
	  }
	  if (haveStream && !streamIsTTY && forceColor === undefined) {
	    return 0;
	  }
	  const min = forceColor || 0;
	  if (env.TERM === 'dumb') {
	    return min;
	  }
	  if (process.platform === 'win32') {
	    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
	    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
	    const osRelease = os.release().split('.');
	    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
	      return Number(osRelease[2]) >= 14931 ? 3 : 2;
	    }
	    return 1;
	  }
	  if ('CI' in env) {
	    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
	      return 1;
	    }
	    return min;
	  }
	  if ('TEAMCITY_VERSION' in env) {
	    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	  }
	  if (env.COLORTERM === 'truecolor') {
	    return 3;
	  }
	  if ('TERM_PROGRAM' in env) {
	    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
	    switch (env.TERM_PROGRAM) {
	      case 'iTerm.app':
	        return version >= 3 ? 3 : 2;
	      case 'Apple_Terminal':
	        return 2;
	      // No default
	    }
	  }
	  if (/-256(color)?$/i.test(env.TERM)) {
	    return 2;
	  }
	  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
	    return 1;
	  }
	  if ('COLORTERM' in env) {
	    return 1;
	  }
	  return min;
	}
	function getSupportLevel(stream) {
	  const level = supportsColor(stream, stream && stream.isTTY);
	  return translateLevel(level);
	}
	var supportsColor_1 = {
	  supportsColor: getSupportLevel,
	  stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	  stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};

	const stringReplaceAll$1 = (string, substring, replacer) => {
	  let index = string.indexOf(substring);
	  if (index === -1) {
	    return string;
	  }
	  const substringLength = substring.length;
	  let endIndex = 0;
	  let returnValue = '';
	  do {
	    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
	    endIndex = index + substringLength;
	    index = string.indexOf(substring, endIndex);
	  } while (index !== -1);
	  returnValue += string.substr(endIndex);
	  return returnValue;
	};
	const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
	  let endIndex = 0;
	  let returnValue = '';
	  do {
	    const gotCR = string[index - 1] === '\r';
	    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
	    endIndex = index + 1;
	    index = string.indexOf('\n', endIndex);
	  } while (index !== -1);
	  returnValue += string.substr(endIndex);
	  return returnValue;
	};
	var util = {
	  stringReplaceAll: stringReplaceAll$1,
	  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
	};

	var templates;
	var hasRequiredTemplates;
	function requireTemplates() {
	  if (hasRequiredTemplates) return templates;
	  hasRequiredTemplates = 1;
	  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
	  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
	  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
	  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
	  const ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', '\u001B'], ['a', '\u0007']]);
	  function unescape(c) {
	    const u = c[0] === 'u';
	    const bracket = c[1] === '{';
	    if (u && !bracket && c.length === 5 || c[0] === 'x' && c.length === 3) {
	      return String.fromCharCode(parseInt(c.slice(1), 16));
	    }
	    if (u && bracket) {
	      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	    }
	    return ESCAPES.get(c) || c;
	  }
	  function parseArguments(name, arguments_) {
	    const results = [];
	    const chunks = arguments_.trim().split(/\s*,\s*/g);
	    let matches;
	    for (const chunk of chunks) {
	      const number = Number(chunk);
	      if (!Number.isNaN(number)) {
	        results.push(number);
	      } else if (matches = chunk.match(STRING_REGEX)) {
	        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
	      } else {
	        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
	      }
	    }
	    return results;
	  }
	  function parseStyle(style) {
	    STYLE_REGEX.lastIndex = 0;
	    const results = [];
	    let matches;
	    while ((matches = STYLE_REGEX.exec(style)) !== null) {
	      const name = matches[1];
	      if (matches[2]) {
	        const args = parseArguments(name, matches[2]);
	        results.push([name].concat(args));
	      } else {
	        results.push([name]);
	      }
	    }
	    return results;
	  }
	  function buildStyle(chalk, styles) {
	    const enabled = {};
	    for (const layer of styles) {
	      for (const style of layer.styles) {
	        enabled[style[0]] = layer.inverse ? null : style.slice(1);
	      }
	    }
	    let current = chalk;
	    for (const [styleName, styles] of Object.entries(enabled)) {
	      if (!Array.isArray(styles)) {
	        continue;
	      }
	      if (!(styleName in current)) {
	        throw new Error(`Unknown Chalk style: ${styleName}`);
	      }
	      current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	    }
	    return current;
	  }
	  templates = (chalk, temporary) => {
	    const styles = [];
	    const chunks = [];
	    let chunk = [];

	    // eslint-disable-next-line max-params
	    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
	      if (escapeCharacter) {
	        chunk.push(unescape(escapeCharacter));
	      } else if (style) {
	        const string = chunk.join('');
	        chunk = [];
	        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
	        styles.push({
	          inverse,
	          styles: parseStyle(style)
	        });
	      } else if (close) {
	        if (styles.length === 0) {
	          throw new Error('Found extraneous } in Chalk template literal');
	        }
	        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
	        chunk = [];
	        styles.pop();
	      } else {
	        chunk.push(character);
	      }
	    });
	    chunks.push(chunk.join(''));
	    if (styles.length > 0) {
	      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
	      throw new Error(errMessage);
	    }
	    return chunks.join('');
	  };
	  return templates;
	}

	const ansiStyles = ansiStylesExports;
	const {
	  stdout: stdoutColor,
	  stderr: stderrColor
	} = supportsColor_1;
	const {
	  stringReplaceAll,
	  stringEncaseCRLFWithFirstIndex
	} = util;
	const {
	  isArray
	} = Array;

	// `supportsColor.level`  `ansiStyles.color[name]` mapping
	const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
	const styles = Object.create(null);
	const applyOptions = (object, options = {}) => {
	  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
	    throw new Error('The `level` option should be an integer from 0 to 3');
	  }

	  // Detect level if not set manually
	  const colorLevel = stdoutColor ? stdoutColor.level : 0;
	  object.level = options.level === undefined ? colorLevel : options.level;
	};
	class ChalkClass {
	  constructor(options) {
	    // eslint-disable-next-line no-constructor-return
	    return chalkFactory(options);
	  }
	}
	const chalkFactory = options => {
	  const chalk = {};
	  applyOptions(chalk, options);
	  chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
	  Object.setPrototypeOf(chalk, Chalk.prototype);
	  Object.setPrototypeOf(chalk.template, chalk);
	  chalk.template.constructor = () => {
	    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	  };
	  chalk.template.Instance = ChalkClass;
	  return chalk.template;
	};
	function Chalk(options) {
	  return chalkFactory(options);
	}
	for (const [styleName, style] of Object.entries(ansiStyles)) {
	  styles[styleName] = {
	    get() {
	      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
	      Object.defineProperty(this, styleName, {
	        value: builder
	      });
	      return builder;
	    }
	  };
	}
	styles.visible = {
	  get() {
	    const builder = createBuilder(this, this._styler, true);
	    Object.defineProperty(this, 'visible', {
	      value: builder
	    });
	    return builder;
	  }
	};
	const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
	for (const model of usedModels) {
	  styles[model] = {
	    get() {
	      const {
	        level
	      } = this;
	      return function (...arguments_) {
	        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
	        return createBuilder(this, styler, this._isEmpty);
	      };
	    }
	  };
	}
	for (const model of usedModels) {
	  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	  styles[bgModel] = {
	    get() {
	      const {
	        level
	      } = this;
	      return function (...arguments_) {
	        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
	        return createBuilder(this, styler, this._isEmpty);
	      };
	    }
	  };
	}
	const proto = Object.defineProperties(() => {}, {
	  ...styles,
	  level: {
	    enumerable: true,
	    get() {
	      return this._generator.level;
	    },
	    set(level) {
	      this._generator.level = level;
	    }
	  }
	});
	const createStyler = (open, close, parent) => {
	  let openAll;
	  let closeAll;
	  if (parent === undefined) {
	    openAll = open;
	    closeAll = close;
	  } else {
	    openAll = parent.openAll + open;
	    closeAll = close + parent.closeAll;
	  }
	  return {
	    open,
	    close,
	    openAll,
	    closeAll,
	    parent
	  };
	};
	const createBuilder = (self, _styler, _isEmpty) => {
	  const builder = (...arguments_) => {
	    if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
	      // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
	      return applyStyle(builder, chalkTag(builder, ...arguments_));
	    }

	    // Single argument is hot path, implicit coercion is faster than anything
	    // eslint-disable-next-line no-implicit-coercion
	    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
	  };

	  // We alter the prototype because we must return a function, but there is
	  // no way to create a function with a different prototype
	  Object.setPrototypeOf(builder, proto);
	  builder._generator = self;
	  builder._styler = _styler;
	  builder._isEmpty = _isEmpty;
	  return builder;
	};
	const applyStyle = (self, string) => {
	  if (self.level <= 0 || !string) {
	    return self._isEmpty ? '' : string;
	  }
	  let styler = self._styler;
	  if (styler === undefined) {
	    return string;
	  }
	  const {
	    openAll,
	    closeAll
	  } = styler;
	  if (string.indexOf('\u001B') !== -1) {
	    while (styler !== undefined) {
	      // Replace any instances already present with a re-opening code
	      // otherwise only the part of the string until said closing code
	      // will be colored, and the rest will simply be 'plain'.
	      string = stringReplaceAll(string, styler.close, styler.open);
	      styler = styler.parent;
	    }
	  }

	  // We can move both next actions out of loop, because remaining actions in loop won't have
	  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	  const lfIndex = string.indexOf('\n');
	  if (lfIndex !== -1) {
	    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	  }
	  return openAll + string + closeAll;
	};
	let template;
	const chalkTag = (chalk, ...strings) => {
	  const [firstString] = strings;
	  if (!isArray(firstString) || !isArray(firstString.raw)) {
	    // If chalk() was called by itself or with a string,
	    // return the string itself as a string.
	    return strings.join(' ');
	  }
	  const arguments_ = strings.slice(1);
	  const parts = [firstString.raw[0]];
	  for (let i = 1; i < firstString.length; i++) {
	    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
	  }
	  if (template === undefined) {
	    template = requireTemplates();
	  }
	  return template(chalk, parts.join(''));
	};
	Object.defineProperties(Chalk.prototype, styles);
	const chalk$2 = Chalk(); // eslint-disable-line new-cap
	chalk$2.supportsColor = stdoutColor;
	chalk$2.stderr = Chalk({
	  level: stderrColor ? stderrColor.level : 0
	}); // eslint-disable-line new-cap
	chalk$2.stderr.supportsColor = stderrColor;
	var source = chalk$2;

	var isUnicodeSupported$2 = () => {
	  if (process.platform !== 'win32') {
	    return true;
	  }
	  return Boolean(process.env.CI) || Boolean(process.env.WT_SESSION) ||
	  // Windows Terminal
	  process.env.TERM_PROGRAM === 'vscode' || process.env.TERM === 'xterm-256color' || process.env.TERM === 'alacritty';
	};

	const chalk$1 = source;
	const isUnicodeSupported$1 = isUnicodeSupported$2;
	const main$1 = {
	  info: chalk$1.blue(''),
	  success: chalk$1.green(''),
	  warning: chalk$1.yellow(''),
	  error: chalk$1.red('')
	};
	const fallback = {
	  info: chalk$1.blue('i'),
	  success: chalk$1.green(''),
	  warning: chalk$1.yellow(''),
	  error: chalk$1.red('')
	};
	var logSymbols$1 = isUnicodeSupported$1() ? main$1 : fallback;

	var wcwidth$2 = {exports: {}};

	var clone$1 = {exports: {}};

	(function (module) {
	  var clone = function () {

	    /**
	     * Clones (copies) an Object using deep copying.
	     *
	     * This function supports circular references by default, but if you are certain
	     * there are no circular references in your object, you can save some CPU time
	     * by calling clone(obj, false).
	     *
	     * Caution: if `circular` is false and `parent` contains circular references,
	     * your program may enter an infinite loop and crash.
	     *
	     * @param `parent` - the object to be cloned
	     * @param `circular` - set to true if the object to be cloned may contain
	     *    circular references. (optional - true by default)
	     * @param `depth` - set to a number if the object is only to be cloned to
	     *    a particular depth. (optional - defaults to Infinity)
	     * @param `prototype` - sets the prototype to be used when cloning an object.
	     *    (optional - defaults to parent prototype).
	    */
	    function clone(parent, circular, depth, prototype) {
	      if (typeof circular === 'object') {
	        depth = circular.depth;
	        prototype = circular.prototype;
	        circular.filter;
	        circular = circular.circular;
	      }
	      // maintain two arrays for circular references, where corresponding parents
	      // and children have the same index
	      var allParents = [];
	      var allChildren = [];
	      var useBuffer = typeof Buffer != 'undefined';
	      if (typeof circular == 'undefined') circular = true;
	      if (typeof depth == 'undefined') depth = Infinity;

	      // recurse this function so we don't reset allParents and allChildren
	      function _clone(parent, depth) {
	        // cloning null always returns null
	        if (parent === null) return null;
	        if (depth == 0) return parent;
	        var child;
	        var proto;
	        if (typeof parent != 'object') {
	          return parent;
	        }
	        if (clone.__isArray(parent)) {
	          child = [];
	        } else if (clone.__isRegExp(parent)) {
	          child = new RegExp(parent.source, __getRegExpFlags(parent));
	          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	        } else if (clone.__isDate(parent)) {
	          child = new Date(parent.getTime());
	        } else if (useBuffer && Buffer.isBuffer(parent)) {
	          if (Buffer.allocUnsafe) {
	            // Node.js >= 4.5.0
	            child = Buffer.allocUnsafe(parent.length);
	          } else {
	            // Older Node.js versions
	            child = new Buffer(parent.length);
	          }
	          parent.copy(child);
	          return child;
	        } else {
	          if (typeof prototype == 'undefined') {
	            proto = Object.getPrototypeOf(parent);
	            child = Object.create(proto);
	          } else {
	            child = Object.create(prototype);
	            proto = prototype;
	          }
	        }
	        if (circular) {
	          var index = allParents.indexOf(parent);
	          if (index != -1) {
	            return allChildren[index];
	          }
	          allParents.push(parent);
	          allChildren.push(child);
	        }
	        for (var i in parent) {
	          var attrs;
	          if (proto) {
	            attrs = Object.getOwnPropertyDescriptor(proto, i);
	          }
	          if (attrs && attrs.set == null) {
	            continue;
	          }
	          child[i] = _clone(parent[i], depth - 1);
	        }
	        return child;
	      }
	      return _clone(parent, depth);
	    }

	    /**
	     * Simple flat clone using prototype, accepts only objects, usefull for property
	     * override on FLAT configuration object (no nested props).
	     *
	     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	     * works.
	     */
	    clone.clonePrototype = function clonePrototype(parent) {
	      if (parent === null) return null;
	      var c = function () {};
	      c.prototype = parent;
	      return new c();
	    };

	    // private utility functions

	    function __objToStr(o) {
	      return Object.prototype.toString.call(o);
	    }
	    clone.__objToStr = __objToStr;
	    function __isDate(o) {
	      return typeof o === 'object' && __objToStr(o) === '[object Date]';
	    }
	    clone.__isDate = __isDate;
	    function __isArray(o) {
	      return typeof o === 'object' && __objToStr(o) === '[object Array]';
	    }
	    clone.__isArray = __isArray;
	    function __isRegExp(o) {
	      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	    }
	    clone.__isRegExp = __isRegExp;
	    function __getRegExpFlags(re) {
	      var flags = '';
	      if (re.global) flags += 'g';
	      if (re.ignoreCase) flags += 'i';
	      if (re.multiline) flags += 'm';
	      return flags;
	    }
	    clone.__getRegExpFlags = __getRegExpFlags;
	    return clone;
	  }();
	  if (module.exports) {
	    module.exports = clone;
	  }
	})(clone$1);
	var cloneExports = clone$1.exports;

	var clone = cloneExports;
	var defaults$1 = function (options, defaults) {
	  options = options || {};
	  Object.keys(defaults).forEach(function (key) {
	    if (typeof options[key] === 'undefined') {
	      options[key] = clone(defaults[key]);
	    }
	  });
	  return options;
	};

	var combining$1 = [[0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489], [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2], [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603], [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670], [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED], [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A], [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902], [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D], [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981], [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD], [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C], [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D], [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC], [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD], [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C], [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D], [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0], [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48], [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC], [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD], [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D], [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6], [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E], [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC], [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35], [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E], [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97], [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030], [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039], [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F], [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753], [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD], [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD], [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922], [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B], [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34], [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42], [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF], [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063], [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F], [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B], [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F], [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB], [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F], [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169], [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD], [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F], [0xE0100, 0xE01EF]];

	var defaults = defaults$1;
	var combining = combining$1;
	var DEFAULTS = {
	  nul: 0,
	  control: 0
	};
	wcwidth$2.exports = function wcwidth(str) {
	  return wcswidth(str, DEFAULTS);
	};
	wcwidth$2.exports.config = function (opts) {
	  opts = defaults(opts || {}, DEFAULTS);
	  return function wcwidth(str) {
	    return wcswidth(str, opts);
	  };
	};

	/*
	 *  The following functions define the column width of an ISO 10646
	 *  character as follows:
	 *  - The null character (U+0000) has a column width of 0.
	 *  - Other C0/C1 control characters and DEL will lead to a return value
	 *    of -1.
	 *  - Non-spacing and enclosing combining characters (general category
	 *    code Mn or Me in the
	 *    Unicode database) have a column width of 0.
	 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
	 *  - Other format characters (general category code Cf in the Unicode
	 *    database) and ZERO WIDTH
	 *    SPACE (U+200B) have a column width of 0.
	 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
	 *    have a column width of 0.
	 *  - Spacing characters in the East Asian Wide (W) or East Asian
	 *    Full-width (F) category as
	 *    defined in Unicode Technical Report #11 have a column width of 2.
	 *  - All remaining characters (including all printable ISO 8859-1 and
	 *    WGL4 characters, Unicode control characters, etc.) have a column
	 *    width of 1.
	 *  This implementation assumes that characters are encoded in ISO 10646.
	*/

	function wcswidth(str, opts) {
	  if (typeof str !== 'string') return wcwidth$1(str, opts);
	  var s = 0;
	  for (var i = 0; i < str.length; i++) {
	    var n = wcwidth$1(str.charCodeAt(i), opts);
	    if (n < 0) return -1;
	    s += n;
	  }
	  return s;
	}
	function wcwidth$1(ucs, opts) {
	  // test for 8-bit control characters
	  if (ucs === 0) return opts.nul;
	  if (ucs < 32 || ucs >= 0x7f && ucs < 0xa0) return opts.control;

	  // binary search in table of non-spacing characters
	  if (bisearch(ucs)) return 0;

	  // if we arrive here, ucs is not a combining or C0/C1 control character
	  return 1 + (ucs >= 0x1100 && (ucs <= 0x115f ||
	  // Hangul Jamo init. consonants
	  ucs == 0x2329 || ucs == 0x232a || ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f ||
	  // CJK ... Yi
	  ucs >= 0xac00 && ucs <= 0xd7a3 ||
	  // Hangul Syllables
	  ucs >= 0xf900 && ucs <= 0xfaff ||
	  // CJK Compatibility Ideographs
	  ucs >= 0xfe10 && ucs <= 0xfe19 ||
	  // Vertical forms
	  ucs >= 0xfe30 && ucs <= 0xfe6f ||
	  // CJK Compatibility Forms
	  ucs >= 0xff00 && ucs <= 0xff60 ||
	  // Fullwidth Forms
	  ucs >= 0xffe0 && ucs <= 0xffe6 || ucs >= 0x20000 && ucs <= 0x2fffd || ucs >= 0x30000 && ucs <= 0x3fffd));
	}
	function bisearch(ucs) {
	  var min = 0;
	  var max = combining.length - 1;
	  var mid;
	  if (ucs < combining[0][0] || ucs > combining[max][1]) return false;
	  while (max >= min) {
	    mid = Math.floor((min + max) / 2);
	    if (ucs > combining[mid][1]) min = mid + 1;else if (ucs < combining[mid][0]) max = mid - 1;else return true;
	  }
	  return false;
	}
	var wcwidthExports = wcwidth$2.exports;

	var isInteractive$1 = ({
	  stream = process.stdout
	} = {}) => {
	  return Boolean(stream && stream.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env));
	};

	var bl = {exports: {}};

	var readable = {exports: {}};

	var stream;
	var hasRequiredStream;
	function requireStream() {
	  if (hasRequiredStream) return stream;
	  hasRequiredStream = 1;
	  stream = require$$0$5;
	  return stream;
	}

	var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);

	var buffer_list;
	var hasRequiredBuffer_list;
	function requireBuffer_list() {
	  if (hasRequiredBuffer_list) return buffer_list;
	  hasRequiredBuffer_list = 1;
	  function ownKeys(object, enumerableOnly) {
	    var keys = Object.keys(object);
	    if (Object.getOwnPropertySymbols) {
	      var symbols = Object.getOwnPropertySymbols(object);
	      enumerableOnly && (symbols = symbols.filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	      })), keys.push.apply(keys, symbols);
	    }
	    return keys;
	  }
	  function _objectSpread(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = null != arguments[i] ? arguments[i] : {};
	      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    key = _toPropertyKey(key);
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }
	  function _defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	    }
	  }
	  function _createClass(Constructor, protoProps, staticProps) {
	    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	    Object.defineProperty(Constructor, "prototype", {
	      writable: false
	    });
	    return Constructor;
	  }
	  function _toPropertyKey(arg) {
	    var key = _toPrimitive(arg, "string");
	    return typeof key === "symbol" ? key : String(key);
	  }
	  function _toPrimitive(input, hint) {
	    if (typeof input !== "object" || input === null) return input;
	    var prim = input[Symbol.toPrimitive];
	    if (prim !== undefined) {
	      var res = prim.call(input, hint || "default");
	      if (typeof res !== "object") return res;
	      throw new TypeError("@@toPrimitive must return a primitive value.");
	    }
	    return (hint === "string" ? String : Number)(input);
	  }
	  var _require = require$$0$1,
	    Buffer = _require.Buffer;
	  var _require2 = require$$0$4,
	    inspect = _require2.inspect;
	  var custom = inspect && inspect.custom || 'inspect';
	  function copyBuffer(src, target, offset) {
	    Buffer.prototype.copy.call(src, target, offset);
	  }
	  buffer_list = /*#__PURE__*/function () {
	    function BufferList() {
	      _classCallCheck(this, BufferList);
	      this.head = null;
	      this.tail = null;
	      this.length = 0;
	    }
	    _createClass(BufferList, [{
	      key: "push",
	      value: function push(v) {
	        var entry = {
	          data: v,
	          next: null
	        };
	        if (this.length > 0) this.tail.next = entry;else this.head = entry;
	        this.tail = entry;
	        ++this.length;
	      }
	    }, {
	      key: "unshift",
	      value: function unshift(v) {
	        var entry = {
	          data: v,
	          next: this.head
	        };
	        if (this.length === 0) this.tail = entry;
	        this.head = entry;
	        ++this.length;
	      }
	    }, {
	      key: "shift",
	      value: function shift() {
	        if (this.length === 0) return;
	        var ret = this.head.data;
	        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	        --this.length;
	        return ret;
	      }
	    }, {
	      key: "clear",
	      value: function clear() {
	        this.head = this.tail = null;
	        this.length = 0;
	      }
	    }, {
	      key: "join",
	      value: function join(s) {
	        if (this.length === 0) return '';
	        var p = this.head;
	        var ret = '' + p.data;
	        while (p = p.next) ret += s + p.data;
	        return ret;
	      }
	    }, {
	      key: "concat",
	      value: function concat(n) {
	        if (this.length === 0) return Buffer.alloc(0);
	        var ret = Buffer.allocUnsafe(n >>> 0);
	        var p = this.head;
	        var i = 0;
	        while (p) {
	          copyBuffer(p.data, ret, i);
	          i += p.data.length;
	          p = p.next;
	        }
	        return ret;
	      }

	      // Consumes a specified amount of bytes or characters from the buffered data.
	    }, {
	      key: "consume",
	      value: function consume(n, hasStrings) {
	        var ret;
	        if (n < this.head.data.length) {
	          // `slice` is the same for buffers and strings.
	          ret = this.head.data.slice(0, n);
	          this.head.data = this.head.data.slice(n);
	        } else if (n === this.head.data.length) {
	          // First chunk is a perfect match.
	          ret = this.shift();
	        } else {
	          // Result spans more than one buffer.
	          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	        }
	        return ret;
	      }
	    }, {
	      key: "first",
	      value: function first() {
	        return this.head.data;
	      }

	      // Consumes a specified amount of characters from the buffered data.
	    }, {
	      key: "_getString",
	      value: function _getString(n) {
	        var p = this.head;
	        var c = 1;
	        var ret = p.data;
	        n -= ret.length;
	        while (p = p.next) {
	          var str = p.data;
	          var nb = n > str.length ? str.length : n;
	          if (nb === str.length) ret += str;else ret += str.slice(0, n);
	          n -= nb;
	          if (n === 0) {
	            if (nb === str.length) {
	              ++c;
	              if (p.next) this.head = p.next;else this.head = this.tail = null;
	            } else {
	              this.head = p;
	              p.data = str.slice(nb);
	            }
	            break;
	          }
	          ++c;
	        }
	        this.length -= c;
	        return ret;
	      }

	      // Consumes a specified amount of bytes from the buffered data.
	    }, {
	      key: "_getBuffer",
	      value: function _getBuffer(n) {
	        var ret = Buffer.allocUnsafe(n);
	        var p = this.head;
	        var c = 1;
	        p.data.copy(ret);
	        n -= p.data.length;
	        while (p = p.next) {
	          var buf = p.data;
	          var nb = n > buf.length ? buf.length : n;
	          buf.copy(ret, ret.length - n, 0, nb);
	          n -= nb;
	          if (n === 0) {
	            if (nb === buf.length) {
	              ++c;
	              if (p.next) this.head = p.next;else this.head = this.tail = null;
	            } else {
	              this.head = p;
	              p.data = buf.slice(nb);
	            }
	            break;
	          }
	          ++c;
	        }
	        this.length -= c;
	        return ret;
	      }

	      // Make sure the linked list only shows the minimal necessary information.
	    }, {
	      key: custom,
	      value: function value(_, options) {
	        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	          // Only inspect one level.
	          depth: 0,
	          // It should not recurse.
	          customInspect: false
	        }));
	      }
	    }]);
	    return BufferList;
	  }();
	  return buffer_list;
	}

	var destroy_1;
	var hasRequiredDestroy;
	function requireDestroy() {
	  if (hasRequiredDestroy) return destroy_1;
	  hasRequiredDestroy = 1;

	  // undocumented cb() API, needed for core, not for public API
	  function destroy(err, cb) {
	    var _this = this;
	    var readableDestroyed = this._readableState && this._readableState.destroyed;
	    var writableDestroyed = this._writableState && this._writableState.destroyed;
	    if (readableDestroyed || writableDestroyed) {
	      if (cb) {
	        cb(err);
	      } else if (err) {
	        if (!this._writableState) {
	          process.nextTick(emitErrorNT, this, err);
	        } else if (!this._writableState.errorEmitted) {
	          this._writableState.errorEmitted = true;
	          process.nextTick(emitErrorNT, this, err);
	        }
	      }
	      return this;
	    }

	    // we set destroyed to true before firing error callbacks in order
	    // to make it re-entrance safe in case destroy() is called within callbacks

	    if (this._readableState) {
	      this._readableState.destroyed = true;
	    }

	    // if this is a duplex stream mark the writable part as destroyed as well
	    if (this._writableState) {
	      this._writableState.destroyed = true;
	    }
	    this._destroy(err || null, function (err) {
	      if (!cb && err) {
	        if (!_this._writableState) {
	          process.nextTick(emitErrorAndCloseNT, _this, err);
	        } else if (!_this._writableState.errorEmitted) {
	          _this._writableState.errorEmitted = true;
	          process.nextTick(emitErrorAndCloseNT, _this, err);
	        } else {
	          process.nextTick(emitCloseNT, _this);
	        }
	      } else if (cb) {
	        process.nextTick(emitCloseNT, _this);
	        cb(err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    });
	    return this;
	  }
	  function emitErrorAndCloseNT(self, err) {
	    emitErrorNT(self, err);
	    emitCloseNT(self);
	  }
	  function emitCloseNT(self) {
	    if (self._writableState && !self._writableState.emitClose) return;
	    if (self._readableState && !self._readableState.emitClose) return;
	    self.emit('close');
	  }
	  function undestroy() {
	    if (this._readableState) {
	      this._readableState.destroyed = false;
	      this._readableState.reading = false;
	      this._readableState.ended = false;
	      this._readableState.endEmitted = false;
	    }
	    if (this._writableState) {
	      this._writableState.destroyed = false;
	      this._writableState.ended = false;
	      this._writableState.ending = false;
	      this._writableState.finalCalled = false;
	      this._writableState.prefinished = false;
	      this._writableState.finished = false;
	      this._writableState.errorEmitted = false;
	    }
	  }
	  function emitErrorNT(self, err) {
	    self.emit('error', err);
	  }
	  function errorOrDestroy(stream, err) {
	    // We have tests that rely on errors being emitted
	    // in the same tick, so changing this is semver major.
	    // For now when you opt-in to autoDestroy we allow
	    // the error to be emitted nextTick. In a future
	    // semver major update we should change the default to this.

	    var rState = stream._readableState;
	    var wState = stream._writableState;
	    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	  }
	  destroy_1 = {
	    destroy: destroy,
	    undestroy: undestroy,
	    errorOrDestroy: errorOrDestroy
	  };
	  return destroy_1;
	}

	var errors = {};

	var hasRequiredErrors;
	function requireErrors() {
	  if (hasRequiredErrors) return errors;
	  hasRequiredErrors = 1;
	  const codes = {};
	  function createErrorType(code, message, Base) {
	    if (!Base) {
	      Base = Error;
	    }
	    function getMessage(arg1, arg2, arg3) {
	      if (typeof message === 'string') {
	        return message;
	      } else {
	        return message(arg1, arg2, arg3);
	      }
	    }
	    class NodeError extends Base {
	      constructor(arg1, arg2, arg3) {
	        super(getMessage(arg1, arg2, arg3));
	      }
	    }
	    NodeError.prototype.name = Base.name;
	    NodeError.prototype.code = code;
	    codes[code] = NodeError;
	  }

	  // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	  function oneOf(expected, thing) {
	    if (Array.isArray(expected)) {
	      const len = expected.length;
	      expected = expected.map(i => String(i));
	      if (len > 2) {
	        return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
	      } else if (len === 2) {
	        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
	      } else {
	        return `of ${thing} ${expected[0]}`;
	      }
	    } else {
	      return `of ${thing} ${String(expected)}`;
	    }
	  }

	  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	  function startsWith(str, search, pos) {
	    return str.substr(0 , search.length) === search;
	  }

	  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	  function endsWith(str, search, this_len) {
	    if (this_len === undefined || this_len > str.length) {
	      this_len = str.length;
	    }
	    return str.substring(this_len - search.length, this_len) === search;
	  }

	  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	  function includes(str, search, start) {
	    if (typeof start !== 'number') {
	      start = 0;
	    }
	    if (start + search.length > str.length) {
	      return false;
	    } else {
	      return str.indexOf(search, start) !== -1;
	    }
	  }
	  createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	    return 'The value "' + value + '" is invalid for option "' + name + '"';
	  }, TypeError);
	  createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	    // determiner: 'must be' or 'must not be'
	    let determiner;
	    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	      determiner = 'must not be';
	      expected = expected.replace(/^not /, '');
	    } else {
	      determiner = 'must be';
	    }
	    let msg;
	    if (endsWith(name, ' argument')) {
	      // For cases like 'first argument'
	      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
	    } else {
	      const type = includes(name, '.') ? 'property' : 'argument';
	      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
	    }
	    msg += `. Received type ${typeof actual}`;
	    return msg;
	  }, TypeError);
	  createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	  createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	    return 'The ' + name + ' method is not implemented';
	  });
	  createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	  createErrorType('ERR_STREAM_DESTROYED', function (name) {
	    return 'Cannot call ' + name + ' after a stream was destroyed';
	  });
	  createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	  createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	  createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	  createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	  createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	    return 'Unknown encoding: ' + arg;
	  }, TypeError);
	  createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
	  errors.codes = codes;
	  return errors;
	}

	var state;
	var hasRequiredState;
	function requireState() {
	  if (hasRequiredState) return state;
	  hasRequiredState = 1;
	  var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
	  function highWaterMarkFrom(options, isDuplex, duplexKey) {
	    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	  }
	  function getHighWaterMark(state, options, duplexKey, isDuplex) {
	    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	    if (hwm != null) {
	      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	        var name = isDuplex ? duplexKey : 'highWaterMark';
	        throw new ERR_INVALID_OPT_VALUE(name, hwm);
	      }
	      return Math.floor(hwm);
	    }

	    // Default value
	    return state.objectMode ? 16 : 16 * 1024;
	  }
	  state = {
	    getHighWaterMark: getHighWaterMark
	  };
	  return state;
	}

	var inherits$1;
	if (typeof Object.create === 'function'){
	  inherits$1 = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits$1 = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$2 = inherits$1;

	var _polyfillNode_inherits = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: inherits$2
	});

	var require$$1$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_inherits);

	var node;
	var hasRequiredNode;
	function requireNode() {
	  if (hasRequiredNode) return node;
	  hasRequiredNode = 1;
	  /**
	   * For Node.js, simply re-export the core `util.deprecate` function.
	   */

	  node = require$$0$4.deprecate;
	  return node;
	}

	var _stream_writable;
	var hasRequired_stream_writable;
	function require_stream_writable() {
	  if (hasRequired_stream_writable) return _stream_writable;
	  hasRequired_stream_writable = 1;
	  _stream_writable = Writable;

	  // It seems a linked list but it is not
	  // there will be only 2 of these for each stream
	  function CorkedRequest(state) {
	    var _this = this;
	    this.next = null;
	    this.entry = null;
	    this.finish = function () {
	      onCorkedFinish(_this, state);
	    };
	  }
	  /* </replacement> */

	  /*<replacement>*/
	  var Duplex;
	  /*</replacement>*/

	  Writable.WritableState = WritableState;

	  /*<replacement>*/
	  var internalUtil = {
	    deprecate: requireNode()
	  };
	  /*</replacement>*/

	  /*<replacement>*/
	  var Stream = requireStream();
	  /*</replacement>*/

	  var Buffer = require$$0$1.Buffer;
	  var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	  function _uint8ArrayToBuffer(chunk) {
	    return Buffer.from(chunk);
	  }
	  function _isUint8Array(obj) {
	    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	  }
	  var destroyImpl = requireDestroy();
	  var _require = requireState(),
	    getHighWaterMark = _require.getHighWaterMark;
	  var _require$codes = requireErrors().codes,
	    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	  var errorOrDestroy = destroyImpl.errorOrDestroy;
	  require$$1$2(Writable, Stream);
	  function nop() {}
	  function WritableState(options, stream, isDuplex) {
	    Duplex = Duplex || require_stream_duplex();
	    options = options || {};

	    // Duplex streams are both readable and writable, but share
	    // the same options object.
	    // However, some cases require setting options to different
	    // values for the readable and the writable sides of the duplex stream,
	    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	    // object stream flag to indicate whether or not this stream
	    // contains buffers or objects.
	    this.objectMode = !!options.objectMode;
	    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	    // the point at which write() starts returning false
	    // Note: 0 is a valid value, means that we always return false if
	    // the entire buffer is not flushed immediately on write()
	    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	    // if _final has been called
	    this.finalCalled = false;

	    // drain event flag.
	    this.needDrain = false;
	    // at the start of calling end()
	    this.ending = false;
	    // when end() has been called, and returned
	    this.ended = false;
	    // when 'finish' is emitted
	    this.finished = false;

	    // has it been destroyed
	    this.destroyed = false;

	    // should we decode strings into buffers before passing to _write?
	    // this is here so that some node-core streams can optimize string
	    // handling at a lower level.
	    var noDecode = options.decodeStrings === false;
	    this.decodeStrings = !noDecode;

	    // Crypto is kind of old and crusty.  Historically, its default string
	    // encoding is 'binary' so we have to make this configurable.
	    // Everything else in the universe uses 'utf8', though.
	    this.defaultEncoding = options.defaultEncoding || 'utf8';

	    // not an actual buffer we keep track of, but a measurement
	    // of how much we're waiting to get pushed to some underlying
	    // socket or file.
	    this.length = 0;

	    // a flag to see when we're in the middle of a write.
	    this.writing = false;

	    // when true all writes will be buffered until .uncork() call
	    this.corked = 0;

	    // a flag to be able to tell if the onwrite cb is called immediately,
	    // or on a later tick.  We set this to true at first, because any
	    // actions that shouldn't happen until "later" should generally also
	    // not happen before the first write call.
	    this.sync = true;

	    // a flag to know if we're processing previously buffered items, which
	    // may call the _write() callback in the same tick, so that we don't
	    // end up in an overlapped onwrite situation.
	    this.bufferProcessing = false;

	    // the callback that's passed to _write(chunk,cb)
	    this.onwrite = function (er) {
	      onwrite(stream, er);
	    };

	    // the callback that the user supplies to write(chunk,encoding,cb)
	    this.writecb = null;

	    // the amount that is being written when _write is called.
	    this.writelen = 0;
	    this.bufferedRequest = null;
	    this.lastBufferedRequest = null;

	    // number of pending user-supplied write callbacks
	    // this must be 0 before 'finish' can be emitted
	    this.pendingcb = 0;

	    // emit prefinish if the only thing we're waiting for is _write cbs
	    // This is relevant for synchronous Transform streams
	    this.prefinished = false;

	    // True if the error was already emitted and should not be thrown again
	    this.errorEmitted = false;

	    // Should close be emitted on destroy. Defaults to true.
	    this.emitClose = options.emitClose !== false;

	    // Should .destroy() be called after 'finish' (and potentially 'end')
	    this.autoDestroy = !!options.autoDestroy;

	    // count buffered requests
	    this.bufferedRequestCount = 0;

	    // allocate the first CorkedRequest, there is always
	    // one allocated and free to use, and we maintain at most two
	    this.corkedRequestsFree = new CorkedRequest(this);
	  }
	  WritableState.prototype.getBuffer = function getBuffer() {
	    var current = this.bufferedRequest;
	    var out = [];
	    while (current) {
	      out.push(current);
	      current = current.next;
	    }
	    return out;
	  };
	  (function () {
	    try {
	      Object.defineProperty(WritableState.prototype, 'buffer', {
	        get: internalUtil.deprecate(function writableStateBufferGetter() {
	          return this.getBuffer();
	        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	      });
	    } catch (_) {}
	  })();

	  // Test _writableState for inheritance to account for Duplex streams,
	  // whose prototype chain only points to Readable.
	  var realHasInstance;
	  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	    realHasInstance = Function.prototype[Symbol.hasInstance];
	    Object.defineProperty(Writable, Symbol.hasInstance, {
	      value: function value(object) {
	        if (realHasInstance.call(this, object)) return true;
	        if (this !== Writable) return false;
	        return object && object._writableState instanceof WritableState;
	      }
	    });
	  } else {
	    realHasInstance = function realHasInstance(object) {
	      return object instanceof this;
	    };
	  }
	  function Writable(options) {
	    Duplex = Duplex || require_stream_duplex();

	    // Writable ctor is applied to Duplexes, too.
	    // `realHasInstance` is necessary because using plain `instanceof`
	    // would return false, as no `_writableState` property is attached.

	    // Trying to use the custom `instanceof` for Writable here will also break the
	    // Node.js LazyTransform implementation, which has a non-trivial getter for
	    // `_writableState` that would lead to infinite recursion.

	    // Checking for a Stream.Duplex instance is faster here instead of inside
	    // the WritableState constructor, at least with V8 6.5
	    var isDuplex = this instanceof Duplex;
	    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	    this._writableState = new WritableState(options, this, isDuplex);

	    // legacy.
	    this.writable = true;
	    if (options) {
	      if (typeof options.write === 'function') this._write = options.write;
	      if (typeof options.writev === 'function') this._writev = options.writev;
	      if (typeof options.destroy === 'function') this._destroy = options.destroy;
	      if (typeof options.final === 'function') this._final = options.final;
	    }
	    Stream.call(this);
	  }

	  // Otherwise people can pipe Writable streams, which is just wrong.
	  Writable.prototype.pipe = function () {
	    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	  };
	  function writeAfterEnd(stream, cb) {
	    var er = new ERR_STREAM_WRITE_AFTER_END();
	    // TODO: defer error events consistently everywhere, not just the cb
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	  }

	  // Checks that a user-supplied chunk is valid, especially for the particular
	  // mode the stream is in. Currently this means that `null` is never accepted
	  // and undefined/non-string values are only allowed in object mode.
	  function validChunk(stream, state, chunk, cb) {
	    var er;
	    if (chunk === null) {
	      er = new ERR_STREAM_NULL_VALUES();
	    } else if (typeof chunk !== 'string' && !state.objectMode) {
	      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	    }
	    if (er) {
	      errorOrDestroy(stream, er);
	      process.nextTick(cb, er);
	      return false;
	    }
	    return true;
	  }
	  Writable.prototype.write = function (chunk, encoding, cb) {
	    var state = this._writableState;
	    var ret = false;
	    var isBuf = !state.objectMode && _isUint8Array(chunk);
	    if (isBuf && !Buffer.isBuffer(chunk)) {
	      chunk = _uint8ArrayToBuffer(chunk);
	    }
	    if (typeof encoding === 'function') {
	      cb = encoding;
	      encoding = null;
	    }
	    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	    if (typeof cb !== 'function') cb = nop;
	    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	      state.pendingcb++;
	      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	    }
	    return ret;
	  };
	  Writable.prototype.cork = function () {
	    this._writableState.corked++;
	  };
	  Writable.prototype.uncork = function () {
	    var state = this._writableState;
	    if (state.corked) {
	      state.corked--;
	      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	    }
	  };
	  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	    // node::ParseEncoding() requires lower case.
	    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	    this._writableState.defaultEncoding = encoding;
	    return this;
	  };
	  Object.defineProperty(Writable.prototype, 'writableBuffer', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState && this._writableState.getBuffer();
	    }
	  });
	  function decodeChunk(state, chunk, encoding) {
	    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	      chunk = Buffer.from(chunk, encoding);
	    }
	    return chunk;
	  }
	  Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState.highWaterMark;
	    }
	  });

	  // if we're already writing something, then just put this
	  // in the queue, and wait our turn.  Otherwise, call _write
	  // If we return false, then we need a drain event, so set that flag.
	  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	    if (!isBuf) {
	      var newChunk = decodeChunk(state, chunk, encoding);
	      if (chunk !== newChunk) {
	        isBuf = true;
	        encoding = 'buffer';
	        chunk = newChunk;
	      }
	    }
	    var len = state.objectMode ? 1 : chunk.length;
	    state.length += len;
	    var ret = state.length < state.highWaterMark;
	    // we must ensure that previous needDrain will not be reset to false.
	    if (!ret) state.needDrain = true;
	    if (state.writing || state.corked) {
	      var last = state.lastBufferedRequest;
	      state.lastBufferedRequest = {
	        chunk: chunk,
	        encoding: encoding,
	        isBuf: isBuf,
	        callback: cb,
	        next: null
	      };
	      if (last) {
	        last.next = state.lastBufferedRequest;
	      } else {
	        state.bufferedRequest = state.lastBufferedRequest;
	      }
	      state.bufferedRequestCount += 1;
	    } else {
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	    }
	    return ret;
	  }
	  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	    state.writelen = len;
	    state.writecb = cb;
	    state.writing = true;
	    state.sync = true;
	    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	    state.sync = false;
	  }
	  function onwriteError(stream, state, sync, er, cb) {
	    --state.pendingcb;
	    if (sync) {
	      // defer the callback if we are being called synchronously
	      // to avoid piling up things on the stack
	      process.nextTick(cb, er);
	      // this can emit finish, and it will always happen
	      // after error
	      process.nextTick(finishMaybe, stream, state);
	      stream._writableState.errorEmitted = true;
	      errorOrDestroy(stream, er);
	    } else {
	      // the caller expect this to happen before if
	      // it is async
	      cb(er);
	      stream._writableState.errorEmitted = true;
	      errorOrDestroy(stream, er);
	      // this can emit finish, but finish must
	      // always follow error
	      finishMaybe(stream, state);
	    }
	  }
	  function onwriteStateUpdate(state) {
	    state.writing = false;
	    state.writecb = null;
	    state.length -= state.writelen;
	    state.writelen = 0;
	  }
	  function onwrite(stream, er) {
	    var state = stream._writableState;
	    var sync = state.sync;
	    var cb = state.writecb;
	    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	    onwriteStateUpdate(state);
	    if (er) onwriteError(stream, state, sync, er, cb);else {
	      // Check if we're actually ready to finish, but don't emit yet
	      var finished = needFinish(state) || stream.destroyed;
	      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	        clearBuffer(stream, state);
	      }
	      if (sync) {
	        process.nextTick(afterWrite, stream, state, finished, cb);
	      } else {
	        afterWrite(stream, state, finished, cb);
	      }
	    }
	  }
	  function afterWrite(stream, state, finished, cb) {
	    if (!finished) onwriteDrain(stream, state);
	    state.pendingcb--;
	    cb();
	    finishMaybe(stream, state);
	  }

	  // Must force callback to be called on nextTick, so that we don't
	  // emit 'drain' before the write() consumer gets the 'false' return
	  // value, and has a chance to attach a 'drain' listener.
	  function onwriteDrain(stream, state) {
	    if (state.length === 0 && state.needDrain) {
	      state.needDrain = false;
	      stream.emit('drain');
	    }
	  }

	  // if there's something in the buffer waiting, then process it
	  function clearBuffer(stream, state) {
	    state.bufferProcessing = true;
	    var entry = state.bufferedRequest;
	    if (stream._writev && entry && entry.next) {
	      // Fast case, write everything using _writev()
	      var l = state.bufferedRequestCount;
	      var buffer = new Array(l);
	      var holder = state.corkedRequestsFree;
	      holder.entry = entry;
	      var count = 0;
	      var allBuffers = true;
	      while (entry) {
	        buffer[count] = entry;
	        if (!entry.isBuf) allBuffers = false;
	        entry = entry.next;
	        count += 1;
	      }
	      buffer.allBuffers = allBuffers;
	      doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	      // doWrite is almost always async, defer these to save a bit of time
	      // as the hot path ends with doWrite
	      state.pendingcb++;
	      state.lastBufferedRequest = null;
	      if (holder.next) {
	        state.corkedRequestsFree = holder.next;
	        holder.next = null;
	      } else {
	        state.corkedRequestsFree = new CorkedRequest(state);
	      }
	      state.bufferedRequestCount = 0;
	    } else {
	      // Slow case, write chunks one-by-one
	      while (entry) {
	        var chunk = entry.chunk;
	        var encoding = entry.encoding;
	        var cb = entry.callback;
	        var len = state.objectMode ? 1 : chunk.length;
	        doWrite(stream, state, false, len, chunk, encoding, cb);
	        entry = entry.next;
	        state.bufferedRequestCount--;
	        // if we didn't call the onwrite immediately, then
	        // it means that we need to wait until it does.
	        // also, that means that the chunk and cb are currently
	        // being processed, so move the buffer counter past them.
	        if (state.writing) {
	          break;
	        }
	      }
	      if (entry === null) state.lastBufferedRequest = null;
	    }
	    state.bufferedRequest = entry;
	    state.bufferProcessing = false;
	  }
	  Writable.prototype._write = function (chunk, encoding, cb) {
	    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	  };
	  Writable.prototype._writev = null;
	  Writable.prototype.end = function (chunk, encoding, cb) {
	    var state = this._writableState;
	    if (typeof chunk === 'function') {
	      cb = chunk;
	      chunk = null;
	      encoding = null;
	    } else if (typeof encoding === 'function') {
	      cb = encoding;
	      encoding = null;
	    }
	    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	    // .end() fully uncorks
	    if (state.corked) {
	      state.corked = 1;
	      this.uncork();
	    }

	    // ignore unnecessary end() calls.
	    if (!state.ending) endWritable(this, state, cb);
	    return this;
	  };
	  Object.defineProperty(Writable.prototype, 'writableLength', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState.length;
	    }
	  });
	  function needFinish(state) {
	    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	  }
	  function callFinal(stream, state) {
	    stream._final(function (err) {
	      state.pendingcb--;
	      if (err) {
	        errorOrDestroy(stream, err);
	      }
	      state.prefinished = true;
	      stream.emit('prefinish');
	      finishMaybe(stream, state);
	    });
	  }
	  function prefinish(stream, state) {
	    if (!state.prefinished && !state.finalCalled) {
	      if (typeof stream._final === 'function' && !state.destroyed) {
	        state.pendingcb++;
	        state.finalCalled = true;
	        process.nextTick(callFinal, stream, state);
	      } else {
	        state.prefinished = true;
	        stream.emit('prefinish');
	      }
	    }
	  }
	  function finishMaybe(stream, state) {
	    var need = needFinish(state);
	    if (need) {
	      prefinish(stream, state);
	      if (state.pendingcb === 0) {
	        state.finished = true;
	        stream.emit('finish');
	        if (state.autoDestroy) {
	          // In case of duplex streams we need a way to detect
	          // if the readable side is ready for autoDestroy as well
	          var rState = stream._readableState;
	          if (!rState || rState.autoDestroy && rState.endEmitted) {
	            stream.destroy();
	          }
	        }
	      }
	    }
	    return need;
	  }
	  function endWritable(stream, state, cb) {
	    state.ending = true;
	    finishMaybe(stream, state);
	    if (cb) {
	      if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	    }
	    state.ended = true;
	    stream.writable = false;
	  }
	  function onCorkedFinish(corkReq, state, err) {
	    var entry = corkReq.entry;
	    corkReq.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }

	    // reuse the free corkReq.
	    state.corkedRequestsFree.next = corkReq;
	  }
	  Object.defineProperty(Writable.prototype, 'destroyed', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      if (this._writableState === undefined) {
	        return false;
	      }
	      return this._writableState.destroyed;
	    },
	    set: function set(value) {
	      // we ignore the value if the stream
	      // has not been initialized yet
	      if (!this._writableState) {
	        return;
	      }

	      // backward compatibility, the user is explicitly
	      // managing destroyed
	      this._writableState.destroyed = value;
	    }
	  });
	  Writable.prototype.destroy = destroyImpl.destroy;
	  Writable.prototype._undestroy = destroyImpl.undestroy;
	  Writable.prototype._destroy = function (err, cb) {
	    cb(err);
	  };
	  return _stream_writable;
	}

	var _stream_duplex;
	var hasRequired_stream_duplex;
	function require_stream_duplex() {
	  if (hasRequired_stream_duplex) return _stream_duplex;
	  hasRequired_stream_duplex = 1;

	  /*<replacement>*/
	  var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	  };
	  /*</replacement>*/

	  _stream_duplex = Duplex;
	  var Readable = require_stream_readable();
	  var Writable = require_stream_writable();
	  require$$1$2(Duplex, Readable);
	  {
	    // Allow the keys array to be GC'ed.
	    var keys = objectKeys(Writable.prototype);
	    for (var v = 0; v < keys.length; v++) {
	      var method = keys[v];
	      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	    }
	  }
	  function Duplex(options) {
	    if (!(this instanceof Duplex)) return new Duplex(options);
	    Readable.call(this, options);
	    Writable.call(this, options);
	    this.allowHalfOpen = true;
	    if (options) {
	      if (options.readable === false) this.readable = false;
	      if (options.writable === false) this.writable = false;
	      if (options.allowHalfOpen === false) {
	        this.allowHalfOpen = false;
	        this.once('end', onend);
	      }
	    }
	  }
	  Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState.highWaterMark;
	    }
	  });
	  Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState && this._writableState.getBuffer();
	    }
	  });
	  Object.defineProperty(Duplex.prototype, 'writableLength', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._writableState.length;
	    }
	  });

	  // the no-half-open enforcer
	  function onend() {
	    // If the writable side ended, then we're ok.
	    if (this._writableState.ended) return;

	    // no more data can be written.
	    // But allow more writes to happen in this tick.
	    process.nextTick(onEndNT, this);
	  }
	  function onEndNT(self) {
	    self.end();
	  }
	  Object.defineProperty(Duplex.prototype, 'destroyed', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      if (this._readableState === undefined || this._writableState === undefined) {
	        return false;
	      }
	      return this._readableState.destroyed && this._writableState.destroyed;
	    },
	    set: function set(value) {
	      // we ignore the value if the stream
	      // has not been initialized yet
	      if (this._readableState === undefined || this._writableState === undefined) {
	        return;
	      }

	      // backward compatibility, the user is explicitly
	      // managing destroyed
	      this._readableState.destroyed = value;
	      this._writableState.destroyed = value;
	    }
	  });
	  return _stream_duplex;
	}

	var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);

	var endOfStream;
	var hasRequiredEndOfStream;
	function requireEndOfStream() {
	  if (hasRequiredEndOfStream) return endOfStream;
	  hasRequiredEndOfStream = 1;
	  var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
	  function once(callback) {
	    var called = false;
	    return function () {
	      if (called) return;
	      called = true;
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      callback.apply(this, args);
	    };
	  }
	  function noop() {}
	  function isRequest(stream) {
	    return stream.setHeader && typeof stream.abort === 'function';
	  }
	  function eos(stream, opts, callback) {
	    if (typeof opts === 'function') return eos(stream, null, opts);
	    if (!opts) opts = {};
	    callback = once(callback || noop);
	    var readable = opts.readable || opts.readable !== false && stream.readable;
	    var writable = opts.writable || opts.writable !== false && stream.writable;
	    var onlegacyfinish = function onlegacyfinish() {
	      if (!stream.writable) onfinish();
	    };
	    var writableEnded = stream._writableState && stream._writableState.finished;
	    var onfinish = function onfinish() {
	      writable = false;
	      writableEnded = true;
	      if (!readable) callback.call(stream);
	    };
	    var readableEnded = stream._readableState && stream._readableState.endEmitted;
	    var onend = function onend() {
	      readable = false;
	      readableEnded = true;
	      if (!writable) callback.call(stream);
	    };
	    var onerror = function onerror(err) {
	      callback.call(stream, err);
	    };
	    var onclose = function onclose() {
	      var err;
	      if (readable && !readableEnded) {
	        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	        return callback.call(stream, err);
	      }
	      if (writable && !writableEnded) {
	        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	        return callback.call(stream, err);
	      }
	    };
	    var onrequest = function onrequest() {
	      stream.req.on('finish', onfinish);
	    };
	    if (isRequest(stream)) {
	      stream.on('complete', onfinish);
	      stream.on('abort', onclose);
	      if (stream.req) onrequest();else stream.on('request', onrequest);
	    } else if (writable && !stream._writableState) {
	      // legacy streams
	      stream.on('end', onlegacyfinish);
	      stream.on('close', onlegacyfinish);
	    }
	    stream.on('end', onend);
	    stream.on('finish', onfinish);
	    if (opts.error !== false) stream.on('error', onerror);
	    stream.on('close', onclose);
	    return function () {
	      stream.removeListener('complete', onfinish);
	      stream.removeListener('abort', onclose);
	      stream.removeListener('request', onrequest);
	      if (stream.req) stream.req.removeListener('finish', onfinish);
	      stream.removeListener('end', onlegacyfinish);
	      stream.removeListener('close', onlegacyfinish);
	      stream.removeListener('finish', onfinish);
	      stream.removeListener('end', onend);
	      stream.removeListener('error', onerror);
	      stream.removeListener('close', onclose);
	    };
	  }
	  endOfStream = eos;
	  return endOfStream;
	}

	var async_iterator;
	var hasRequiredAsync_iterator;
	function requireAsync_iterator() {
	  if (hasRequiredAsync_iterator) return async_iterator;
	  hasRequiredAsync_iterator = 1;
	  var _Object$setPrototypeO;
	  function _defineProperty(obj, key, value) {
	    key = _toPropertyKey(key);
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toPropertyKey(arg) {
	    var key = _toPrimitive(arg, "string");
	    return typeof key === "symbol" ? key : String(key);
	  }
	  function _toPrimitive(input, hint) {
	    if (typeof input !== "object" || input === null) return input;
	    var prim = input[Symbol.toPrimitive];
	    if (prim !== undefined) {
	      var res = prim.call(input, hint || "default");
	      if (typeof res !== "object") return res;
	      throw new TypeError("@@toPrimitive must return a primitive value.");
	    }
	    return (hint === "string" ? String : Number)(input);
	  }
	  var finished = requireEndOfStream();
	  var kLastResolve = Symbol('lastResolve');
	  var kLastReject = Symbol('lastReject');
	  var kError = Symbol('error');
	  var kEnded = Symbol('ended');
	  var kLastPromise = Symbol('lastPromise');
	  var kHandlePromise = Symbol('handlePromise');
	  var kStream = Symbol('stream');
	  function createIterResult(value, done) {
	    return {
	      value: value,
	      done: done
	    };
	  }
	  function readAndResolve(iter) {
	    var resolve = iter[kLastResolve];
	    if (resolve !== null) {
	      var data = iter[kStream].read();
	      // we defer if data is null
	      // we can be expecting either 'end' or
	      // 'error'
	      if (data !== null) {
	        iter[kLastPromise] = null;
	        iter[kLastResolve] = null;
	        iter[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      }
	    }
	  }
	  function onReadable(iter) {
	    // we wait for the next tick, because it might
	    // emit an error with process.nextTick
	    process.nextTick(readAndResolve, iter);
	  }
	  function wrapForNext(lastPromise, iter) {
	    return function (resolve, reject) {
	      lastPromise.then(function () {
	        if (iter[kEnded]) {
	          resolve(createIterResult(undefined, true));
	          return;
	        }
	        iter[kHandlePromise](resolve, reject);
	      }, reject);
	    };
	  }
	  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	    get stream() {
	      return this[kStream];
	    },
	    next: function next() {
	      var _this = this;
	      // if we have detected an error in the meanwhile
	      // reject straight away
	      var error = this[kError];
	      if (error !== null) {
	        return Promise.reject(error);
	      }
	      if (this[kEnded]) {
	        return Promise.resolve(createIterResult(undefined, true));
	      }
	      if (this[kStream].destroyed) {
	        // We need to defer via nextTick because if .destroy(err) is
	        // called, the error will be emitted via nextTick, and
	        // we cannot guarantee that there is no error lingering around
	        // waiting to be emitted.
	        return new Promise(function (resolve, reject) {
	          process.nextTick(function () {
	            if (_this[kError]) {
	              reject(_this[kError]);
	            } else {
	              resolve(createIterResult(undefined, true));
	            }
	          });
	        });
	      }

	      // if we have multiple next() calls
	      // we will wait for the previous Promise to finish
	      // this logic is optimized to support for await loops,
	      // where next() is only called once at a time
	      var lastPromise = this[kLastPromise];
	      var promise;
	      if (lastPromise) {
	        promise = new Promise(wrapForNext(lastPromise, this));
	      } else {
	        // fast path needed to support multiple this.push()
	        // without triggering the next() queue
	        var data = this[kStream].read();
	        if (data !== null) {
	          return Promise.resolve(createIterResult(data, false));
	        }
	        promise = new Promise(this[kHandlePromise]);
	      }
	      this[kLastPromise] = promise;
	      return promise;
	    }
	  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	    return this;
	  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	    var _this2 = this;
	    // destroy(err, cb) is a private API
	    // we can guarantee we have that here, because we control the
	    // Readable class this is attached to
	    return new Promise(function (resolve, reject) {
	      _this2[kStream].destroy(null, function (err) {
	        if (err) {
	          reject(err);
	          return;
	        }
	        resolve(createIterResult(undefined, true));
	      });
	    });
	  }), _Object$setPrototypeO), AsyncIteratorPrototype);
	  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	    var _Object$create;
	    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	      value: stream,
	      writable: true
	    }), _defineProperty(_Object$create, kLastResolve, {
	      value: null,
	      writable: true
	    }), _defineProperty(_Object$create, kLastReject, {
	      value: null,
	      writable: true
	    }), _defineProperty(_Object$create, kError, {
	      value: null,
	      writable: true
	    }), _defineProperty(_Object$create, kEnded, {
	      value: stream._readableState.endEmitted,
	      writable: true
	    }), _defineProperty(_Object$create, kHandlePromise, {
	      value: function value(resolve, reject) {
	        var data = iterator[kStream].read();
	        if (data) {
	          iterator[kLastPromise] = null;
	          iterator[kLastResolve] = null;
	          iterator[kLastReject] = null;
	          resolve(createIterResult(data, false));
	        } else {
	          iterator[kLastResolve] = resolve;
	          iterator[kLastReject] = reject;
	        }
	      },
	      writable: true
	    }), _Object$create));
	    iterator[kLastPromise] = null;
	    finished(stream, function (err) {
	      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	        var reject = iterator[kLastReject];
	        // reject if we are waiting for data in the Promise
	        // returned by next() and store the error
	        if (reject !== null) {
	          iterator[kLastPromise] = null;
	          iterator[kLastResolve] = null;
	          iterator[kLastReject] = null;
	          reject(err);
	        }
	        iterator[kError] = err;
	        return;
	      }
	      var resolve = iterator[kLastResolve];
	      if (resolve !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(undefined, true));
	      }
	      iterator[kEnded] = true;
	    });
	    stream.on('readable', onReadable.bind(null, iterator));
	    return iterator;
	  };
	  async_iterator = createReadableStreamAsyncIterator;
	  return async_iterator;
	}

	var from_1;
	var hasRequiredFrom;
	function requireFrom() {
	  if (hasRequiredFrom) return from_1;
	  hasRequiredFrom = 1;
	  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	    try {
	      var info = gen[key](arg);
	      var value = info.value;
	    } catch (error) {
	      reject(error);
	      return;
	    }
	    if (info.done) {
	      resolve(value);
	    } else {
	      Promise.resolve(value).then(_next, _throw);
	    }
	  }
	  function _asyncToGenerator(fn) {
	    return function () {
	      var self = this,
	        args = arguments;
	      return new Promise(function (resolve, reject) {
	        var gen = fn.apply(self, args);
	        function _next(value) {
	          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	        }
	        function _throw(err) {
	          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	        }
	        _next(undefined);
	      });
	    };
	  }
	  function ownKeys(object, enumerableOnly) {
	    var keys = Object.keys(object);
	    if (Object.getOwnPropertySymbols) {
	      var symbols = Object.getOwnPropertySymbols(object);
	      enumerableOnly && (symbols = symbols.filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	      })), keys.push.apply(keys, symbols);
	    }
	    return keys;
	  }
	  function _objectSpread(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = null != arguments[i] ? arguments[i] : {};
	      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    key = _toPropertyKey(key);
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toPropertyKey(arg) {
	    var key = _toPrimitive(arg, "string");
	    return typeof key === "symbol" ? key : String(key);
	  }
	  function _toPrimitive(input, hint) {
	    if (typeof input !== "object" || input === null) return input;
	    var prim = input[Symbol.toPrimitive];
	    if (prim !== undefined) {
	      var res = prim.call(input, hint || "default");
	      if (typeof res !== "object") return res;
	      throw new TypeError("@@toPrimitive must return a primitive value.");
	    }
	    return (hint === "string" ? String : Number)(input);
	  }
	  var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
	  function from(Readable, iterable, opts) {
	    var iterator;
	    if (iterable && typeof iterable.next === 'function') {
	      iterator = iterable;
	    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
	    var readable = new Readable(_objectSpread({
	      objectMode: true
	    }, opts));
	    // Reading boolean to protect against _read
	    // being called before last iteration completion.
	    var reading = false;
	    readable._read = function () {
	      if (!reading) {
	        reading = true;
	        next();
	      }
	    };
	    function next() {
	      return _next2.apply(this, arguments);
	    }
	    function _next2() {
	      _next2 = _asyncToGenerator(function* () {
	        try {
	          var _yield$iterator$next = yield iterator.next(),
	            value = _yield$iterator$next.value,
	            done = _yield$iterator$next.done;
	          if (done) {
	            readable.push(null);
	          } else if (readable.push(yield value)) {
	            next();
	          } else {
	            reading = false;
	          }
	        } catch (err) {
	          readable.destroy(err);
	        }
	      });
	      return _next2.apply(this, arguments);
	    }
	    return readable;
	  }
	  from_1 = from;
	  return from_1;
	}

	var _stream_readable;
	var hasRequired_stream_readable;
	function require_stream_readable() {
	  if (hasRequired_stream_readable) return _stream_readable;
	  hasRequired_stream_readable = 1;
	  _stream_readable = Readable;

	  /*<replacement>*/
	  var Duplex;
	  /*</replacement>*/

	  Readable.ReadableState = ReadableState;

	  /*<replacement>*/
	  require$$0$8.EventEmitter;
	  var EElistenerCount = function EElistenerCount(emitter, type) {
	    return emitter.listeners(type).length;
	  };
	  /*</replacement>*/

	  /*<replacement>*/
	  var Stream = requireStream();
	  /*</replacement>*/

	  var Buffer = require$$0$1.Buffer;
	  var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	  function _uint8ArrayToBuffer(chunk) {
	    return Buffer.from(chunk);
	  }
	  function _isUint8Array(obj) {
	    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	  }

	  /*<replacement>*/
	  var debugUtil = require$$0$4;
	  var debug;
	  if (debugUtil && debugUtil.debuglog) {
	    debug = debugUtil.debuglog('stream');
	  } else {
	    debug = function debug() {};
	  }
	  /*</replacement>*/

	  var BufferList = requireBuffer_list();
	  var destroyImpl = requireDestroy();
	  var _require = requireState(),
	    getHighWaterMark = _require.getHighWaterMark;
	  var _require$codes = requireErrors().codes,
	    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	  // Lazy loaded to improve the startup performance.
	  var StringDecoder;
	  var createReadableStreamAsyncIterator;
	  var from;
	  require$$1$2(Readable, Stream);
	  var errorOrDestroy = destroyImpl.errorOrDestroy;
	  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	  function prependListener(emitter, event, fn) {
	    // Sadly this is not cacheable as some libraries bundle their own
	    // event emitter implementation with them.
	    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	  function ReadableState(options, stream, isDuplex) {
	    Duplex = Duplex || require_stream_duplex();
	    options = options || {};

	    // Duplex streams are both readable and writable, but share
	    // the same options object.
	    // However, some cases require setting options to different
	    // values for the readable and the writable sides of the duplex stream.
	    // These options can be provided separately as readableXXX and writableXXX.
	    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	    // object stream flag. Used to make read(n) ignore n and to
	    // make all the buffer merging and length checks go away
	    this.objectMode = !!options.objectMode;
	    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	    // the point at which it stops calling _read() to fill the buffer
	    // Note: 0 is a valid value, means "don't call _read preemptively ever"
	    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	    // A linked list is used to store data chunks instead of an array because the
	    // linked list can remove elements from the beginning faster than
	    // array.shift()
	    this.buffer = new BufferList();
	    this.length = 0;
	    this.pipes = null;
	    this.pipesCount = 0;
	    this.flowing = null;
	    this.ended = false;
	    this.endEmitted = false;
	    this.reading = false;

	    // a flag to be able to tell if the event 'readable'/'data' is emitted
	    // immediately, or on a later tick.  We set this to true at first, because
	    // any actions that shouldn't happen until "later" should generally also
	    // not happen before the first read call.
	    this.sync = true;

	    // whenever we return null, then we set a flag to say
	    // that we're awaiting a 'readable' event emission.
	    this.needReadable = false;
	    this.emittedReadable = false;
	    this.readableListening = false;
	    this.resumeScheduled = false;
	    this.paused = true;

	    // Should close be emitted on destroy. Defaults to true.
	    this.emitClose = options.emitClose !== false;

	    // Should .destroy() be called after 'end' (and potentially 'finish')
	    this.autoDestroy = !!options.autoDestroy;

	    // has it been destroyed
	    this.destroyed = false;

	    // Crypto is kind of old and crusty.  Historically, its default string
	    // encoding is 'binary' so we have to make this configurable.
	    // Everything else in the universe uses 'utf8', though.
	    this.defaultEncoding = options.defaultEncoding || 'utf8';

	    // the number of writers that are awaiting a drain event in .pipe()s
	    this.awaitDrain = 0;

	    // if true, a maybeReadMore has been scheduled
	    this.readingMore = false;
	    this.decoder = null;
	    this.encoding = null;
	    if (options.encoding) {
	      if (!StringDecoder) StringDecoder = require$$1$1.StringDecoder;
	      this.decoder = new StringDecoder(options.encoding);
	      this.encoding = options.encoding;
	    }
	  }
	  function Readable(options) {
	    Duplex = Duplex || require_stream_duplex();
	    if (!(this instanceof Readable)) return new Readable(options);

	    // Checking for a Stream.Duplex instance is faster here instead of inside
	    // the ReadableState constructor, at least with V8 6.5
	    var isDuplex = this instanceof Duplex;
	    this._readableState = new ReadableState(options, this, isDuplex);

	    // legacy
	    this.readable = true;
	    if (options) {
	      if (typeof options.read === 'function') this._read = options.read;
	      if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    }
	    Stream.call(this);
	  }
	  Object.defineProperty(Readable.prototype, 'destroyed', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      if (this._readableState === undefined) {
	        return false;
	      }
	      return this._readableState.destroyed;
	    },
	    set: function set(value) {
	      // we ignore the value if the stream
	      // has not been initialized yet
	      if (!this._readableState) {
	        return;
	      }

	      // backward compatibility, the user is explicitly
	      // managing destroyed
	      this._readableState.destroyed = value;
	    }
	  });
	  Readable.prototype.destroy = destroyImpl.destroy;
	  Readable.prototype._undestroy = destroyImpl.undestroy;
	  Readable.prototype._destroy = function (err, cb) {
	    cb(err);
	  };

	  // Manually shove something into the read() buffer.
	  // This returns true if the highWaterMark has not been hit yet,
	  // similar to how Writable.write() returns true if you should
	  // write() some more.
	  Readable.prototype.push = function (chunk, encoding) {
	    var state = this._readableState;
	    var skipChunkCheck;
	    if (!state.objectMode) {
	      if (typeof chunk === 'string') {
	        encoding = encoding || state.defaultEncoding;
	        if (encoding !== state.encoding) {
	          chunk = Buffer.from(chunk, encoding);
	          encoding = '';
	        }
	        skipChunkCheck = true;
	      }
	    } else {
	      skipChunkCheck = true;
	    }
	    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	  };

	  // Unshift should *always* be something directly out of read()
	  Readable.prototype.unshift = function (chunk) {
	    return readableAddChunk(this, chunk, null, true, false);
	  };
	  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	    debug('readableAddChunk', chunk);
	    var state = stream._readableState;
	    if (chunk === null) {
	      state.reading = false;
	      onEofChunk(stream, state);
	    } else {
	      var er;
	      if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	      if (er) {
	        errorOrDestroy(stream, er);
	      } else if (state.objectMode || chunk && chunk.length > 0) {
	        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	          chunk = _uint8ArrayToBuffer(chunk);
	        }
	        if (addToFront) {
	          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	        } else if (state.ended) {
	          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	        } else if (state.destroyed) {
	          return false;
	        } else {
	          state.reading = false;
	          if (state.decoder && !encoding) {
	            chunk = state.decoder.write(chunk);
	            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	          } else {
	            addChunk(stream, state, chunk, false);
	          }
	        }
	      } else if (!addToFront) {
	        state.reading = false;
	        maybeReadMore(stream, state);
	      }
	    }

	    // We can push more data if we are below the highWaterMark.
	    // Also, if we have no data yet, we can stand some more bytes.
	    // This is to work around cases where hwm=0, such as the repl.
	    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	  }
	  function addChunk(stream, state, chunk, addToFront) {
	    if (state.flowing && state.length === 0 && !state.sync) {
	      state.awaitDrain = 0;
	      stream.emit('data', chunk);
	    } else {
	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	      if (state.needReadable) emitReadable(stream);
	    }
	    maybeReadMore(stream, state);
	  }
	  function chunkInvalid(state, chunk) {
	    var er;
	    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	    }
	    return er;
	  }
	  Readable.prototype.isPaused = function () {
	    return this._readableState.flowing === false;
	  };

	  // backwards compatibility.
	  Readable.prototype.setEncoding = function (enc) {
	    if (!StringDecoder) StringDecoder = require$$1$1.StringDecoder;
	    var decoder = new StringDecoder(enc);
	    this._readableState.decoder = decoder;
	    // If setEncoding(null), decoder.encoding equals utf8
	    this._readableState.encoding = this._readableState.decoder.encoding;

	    // Iterate over current buffer to convert already stored Buffers:
	    var p = this._readableState.buffer.head;
	    var content = '';
	    while (p !== null) {
	      content += decoder.write(p.data);
	      p = p.next;
	    }
	    this._readableState.buffer.clear();
	    if (content !== '') this._readableState.buffer.push(content);
	    this._readableState.length = content.length;
	    return this;
	  };

	  // Don't raise the hwm > 1GB
	  var MAX_HWM = 0x40000000;
	  function computeNewHighWaterMark(n) {
	    if (n >= MAX_HWM) {
	      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	      n = MAX_HWM;
	    } else {
	      // Get the next highest power of 2 to prevent increasing hwm excessively in
	      // tiny amounts
	      n--;
	      n |= n >>> 1;
	      n |= n >>> 2;
	      n |= n >>> 4;
	      n |= n >>> 8;
	      n |= n >>> 16;
	      n++;
	    }
	    return n;
	  }

	  // This function is designed to be inlinable, so please take care when making
	  // changes to the function body.
	  function howMuchToRead(n, state) {
	    if (n <= 0 || state.length === 0 && state.ended) return 0;
	    if (state.objectMode) return 1;
	    if (n !== n) {
	      // Only flow one buffer at a time
	      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	    }
	    // If we're asking for more than the current hwm, then raise the hwm.
	    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	    if (n <= state.length) return n;
	    // Don't have enough
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    }
	    return state.length;
	  }

	  // you can override either this method, or the async _read(n) below.
	  Readable.prototype.read = function (n) {
	    debug('read', n);
	    n = parseInt(n, 10);
	    var state = this._readableState;
	    var nOrig = n;
	    if (n !== 0) state.emittedReadable = false;

	    // if we're doing read(0) to trigger a readable event, but we
	    // already have a bunch of data in the buffer, then just trigger
	    // the 'readable' event and move on.
	    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	      debug('read: emitReadable', state.length, state.ended);
	      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	      return null;
	    }
	    n = howMuchToRead(n, state);

	    // if we've ended, and we're now clear, then finish it up.
	    if (n === 0 && state.ended) {
	      if (state.length === 0) endReadable(this);
	      return null;
	    }

	    // All the actual chunk generation logic needs to be
	    // *below* the call to _read.  The reason is that in certain
	    // synthetic stream cases, such as passthrough streams, _read
	    // may be a completely synchronous operation which may change
	    // the state of the read buffer, providing enough data when
	    // before there was *not* enough.
	    //
	    // So, the steps are:
	    // 1. Figure out what the state of things will be after we do
	    // a read from the buffer.
	    //
	    // 2. If that resulting state will trigger a _read, then call _read.
	    // Note that this may be asynchronous, or synchronous.  Yes, it is
	    // deeply ugly to write APIs this way, but that still doesn't mean
	    // that the Readable class should behave improperly, as streams are
	    // designed to be sync/async agnostic.
	    // Take note if the _read call is sync or async (ie, if the read call
	    // has returned yet), so that we know whether or not it's safe to emit
	    // 'readable' etc.
	    //
	    // 3. Actually pull the requested chunks out of the buffer and return.

	    // if we need a readable event, then we need to do some reading.
	    var doRead = state.needReadable;
	    debug('need readable', doRead);

	    // if we currently have less than the highWaterMark, then also read some
	    if (state.length === 0 || state.length - n < state.highWaterMark) {
	      doRead = true;
	      debug('length less than watermark', doRead);
	    }

	    // however, if we've ended, then there's no point, and if we're already
	    // reading, then it's unnecessary.
	    if (state.ended || state.reading) {
	      doRead = false;
	      debug('reading or ended', doRead);
	    } else if (doRead) {
	      debug('do read');
	      state.reading = true;
	      state.sync = true;
	      // if the length is currently zero, then we *need* a readable event.
	      if (state.length === 0) state.needReadable = true;
	      // call internal read method
	      this._read(state.highWaterMark);
	      state.sync = false;
	      // If _read pushed data synchronously, then `reading` will be false,
	      // and we need to re-evaluate how much data we can return to the user.
	      if (!state.reading) n = howMuchToRead(nOrig, state);
	    }
	    var ret;
	    if (n > 0) ret = fromList(n, state);else ret = null;
	    if (ret === null) {
	      state.needReadable = state.length <= state.highWaterMark;
	      n = 0;
	    } else {
	      state.length -= n;
	      state.awaitDrain = 0;
	    }
	    if (state.length === 0) {
	      // If we have nothing in the buffer, then we want to know
	      // as soon as we *do* get something into the buffer.
	      if (!state.ended) state.needReadable = true;

	      // If we tried to read() past the EOF, then emit end on the next tick.
	      if (nOrig !== n && state.ended) endReadable(this);
	    }
	    if (ret !== null) this.emit('data', ret);
	    return ret;
	  };
	  function onEofChunk(stream, state) {
	    debug('onEofChunk');
	    if (state.ended) return;
	    if (state.decoder) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) {
	        state.buffer.push(chunk);
	        state.length += state.objectMode ? 1 : chunk.length;
	      }
	    }
	    state.ended = true;
	    if (state.sync) {
	      // if we are sync, wait until next tick to emit the data.
	      // Otherwise we risk emitting data in the flow()
	      // the readable code triggers during a read() call
	      emitReadable(stream);
	    } else {
	      // emit 'readable' now to make sure it gets picked up.
	      state.needReadable = false;
	      if (!state.emittedReadable) {
	        state.emittedReadable = true;
	        emitReadable_(stream);
	      }
	    }
	  }

	  // Don't emit readable right away in sync mode, because this can trigger
	  // another read() call => stack overflow.  This way, it might trigger
	  // a nextTick recursion warning, but that's not so bad.
	  function emitReadable(stream) {
	    var state = stream._readableState;
	    debug('emitReadable', state.needReadable, state.emittedReadable);
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      debug('emitReadable', state.flowing);
	      state.emittedReadable = true;
	      process.nextTick(emitReadable_, stream);
	    }
	  }
	  function emitReadable_(stream) {
	    var state = stream._readableState;
	    debug('emitReadable_', state.destroyed, state.length, state.ended);
	    if (!state.destroyed && (state.length || state.ended)) {
	      stream.emit('readable');
	      state.emittedReadable = false;
	    }

	    // The stream needs another readable event if
	    // 1. It is not flowing, as the flow mechanism will take
	    //    care of it.
	    // 2. It is not ended.
	    // 3. It is below the highWaterMark, so we can schedule
	    //    another readable later.
	    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	    flow(stream);
	  }

	  // at this point, the user has presumably seen the 'readable' event,
	  // and called read() to consume some data.  that may have triggered
	  // in turn another _read(n) call, in which case reading = true if
	  // it's in progress.
	  // However, if we're not ended, or reading, and the length < hwm,
	  // then go ahead and try to read some more preemptively.
	  function maybeReadMore(stream, state) {
	    if (!state.readingMore) {
	      state.readingMore = true;
	      process.nextTick(maybeReadMore_, stream, state);
	    }
	  }
	  function maybeReadMore_(stream, state) {
	    // Attempt to read more data if we should.
	    //
	    // The conditions for reading more data are (one of):
	    // - Not enough data buffered (state.length < state.highWaterMark). The loop
	    //   is responsible for filling the buffer with enough data if such data
	    //   is available. If highWaterMark is 0 and we are not in the flowing mode
	    //   we should _not_ attempt to buffer any extra data. We'll get more data
	    //   when the stream consumer calls read() instead.
	    // - No data in the buffer, and the stream is in flowing mode. In this mode
	    //   the loop below is responsible for ensuring read() is called. Failing to
	    //   call read here would abort the flow and there's no other mechanism for
	    //   continuing the flow if the stream consumer has just subscribed to the
	    //   'data' event.
	    //
	    // In addition to the above conditions to keep reading data, the following
	    // conditions prevent the data from being read:
	    // - The stream has ended (state.ended).
	    // - There is already a pending 'read' operation (state.reading). This is a
	    //   case where the the stream has called the implementation defined _read()
	    //   method, but they are processing the call asynchronously and have _not_
	    //   called push() with new data. In this case we skip performing more
	    //   read()s. The execution ends in this method again after the _read() ends
	    //   up calling push() with more data.
	    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	      var len = state.length;
	      debug('maybeReadMore read 0');
	      stream.read(0);
	      if (len === state.length)
	        // didn't get any data, stop spinning.
	        break;
	    }
	    state.readingMore = false;
	  }

	  // abstract method.  to be overridden in specific implementation classes.
	  // call cb(er, data) where data is <= n in length.
	  // for virtual (non-string, non-buffer) streams, "length" is somewhat
	  // arbitrary, and perhaps not very meaningful.
	  Readable.prototype._read = function (n) {
	    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	  };
	  Readable.prototype.pipe = function (dest, pipeOpts) {
	    var src = this;
	    var state = this._readableState;
	    switch (state.pipesCount) {
	      case 0:
	        state.pipes = dest;
	        break;
	      case 1:
	        state.pipes = [state.pipes, dest];
	        break;
	      default:
	        state.pipes.push(dest);
	        break;
	    }
	    state.pipesCount += 1;
	    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	    var endFn = doEnd ? onend : unpipe;
	    if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	    dest.on('unpipe', onunpipe);
	    function onunpipe(readable, unpipeInfo) {
	      debug('onunpipe');
	      if (readable === src) {
	        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	          unpipeInfo.hasUnpiped = true;
	          cleanup();
	        }
	      }
	    }
	    function onend() {
	      debug('onend');
	      dest.end();
	    }

	    // when the dest drains, it reduces the awaitDrain counter
	    // on the source.  This would be more elegant with a .once()
	    // handler in flow(), but adding and removing repeatedly is
	    // too slow.
	    var ondrain = pipeOnDrain(src);
	    dest.on('drain', ondrain);
	    var cleanedUp = false;
	    function cleanup() {
	      debug('cleanup');
	      // cleanup event handlers once the pipe is broken
	      dest.removeListener('close', onclose);
	      dest.removeListener('finish', onfinish);
	      dest.removeListener('drain', ondrain);
	      dest.removeListener('error', onerror);
	      dest.removeListener('unpipe', onunpipe);
	      src.removeListener('end', onend);
	      src.removeListener('end', unpipe);
	      src.removeListener('data', ondata);
	      cleanedUp = true;

	      // if the reader is waiting for a drain event from this
	      // specific writer, then it would cause it to never start
	      // flowing again.
	      // So, if this is awaiting a drain, then we just call it now.
	      // If we don't know, then assume that we are waiting for one.
	      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	    }
	    src.on('data', ondata);
	    function ondata(chunk) {
	      debug('ondata');
	      var ret = dest.write(chunk);
	      debug('dest.write', ret);
	      if (ret === false) {
	        // If the user unpiped during `dest.write()`, it is possible
	        // to get stuck in a permanently paused state if that write
	        // also returned false.
	        // => Check whether `dest` is still a piping destination.
	        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	          debug('false write response, pause', state.awaitDrain);
	          state.awaitDrain++;
	        }
	        src.pause();
	      }
	    }

	    // if the dest has an error, then stop piping into it.
	    // however, don't suppress the throwing behavior for this.
	    function onerror(er) {
	      debug('onerror', er);
	      unpipe();
	      dest.removeListener('error', onerror);
	      if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	    }

	    // Make sure our error handler is attached before userland ones.
	    prependListener(dest, 'error', onerror);

	    // Both close and finish should trigger unpipe, but only once.
	    function onclose() {
	      dest.removeListener('finish', onfinish);
	      unpipe();
	    }
	    dest.once('close', onclose);
	    function onfinish() {
	      debug('onfinish');
	      dest.removeListener('close', onclose);
	      unpipe();
	    }
	    dest.once('finish', onfinish);
	    function unpipe() {
	      debug('unpipe');
	      src.unpipe(dest);
	    }

	    // tell the dest that it's being piped to
	    dest.emit('pipe', src);

	    // start the flow if it hasn't been started already.
	    if (!state.flowing) {
	      debug('pipe resume');
	      src.resume();
	    }
	    return dest;
	  };
	  function pipeOnDrain(src) {
	    return function pipeOnDrainFunctionResult() {
	      var state = src._readableState;
	      debug('pipeOnDrain', state.awaitDrain);
	      if (state.awaitDrain) state.awaitDrain--;
	      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	        state.flowing = true;
	        flow(src);
	      }
	    };
	  }
	  Readable.prototype.unpipe = function (dest) {
	    var state = this._readableState;
	    var unpipeInfo = {
	      hasUnpiped: false
	    };

	    // if we're not piping anywhere, then do nothing.
	    if (state.pipesCount === 0) return this;

	    // just one destination.  most common case.
	    if (state.pipesCount === 1) {
	      // passed in one, but it's not the right one.
	      if (dest && dest !== state.pipes) return this;
	      if (!dest) dest = state.pipes;

	      // got a match.
	      state.pipes = null;
	      state.pipesCount = 0;
	      state.flowing = false;
	      if (dest) dest.emit('unpipe', this, unpipeInfo);
	      return this;
	    }

	    // slow case. multiple pipe destinations.

	    if (!dest) {
	      // remove all.
	      var dests = state.pipes;
	      var len = state.pipesCount;
	      state.pipes = null;
	      state.pipesCount = 0;
	      state.flowing = false;
	      for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	        hasUnpiped: false
	      });
	      return this;
	    }

	    // try to find the right one.
	    var index = indexOf(state.pipes, dest);
	    if (index === -1) return this;
	    state.pipes.splice(index, 1);
	    state.pipesCount -= 1;
	    if (state.pipesCount === 1) state.pipes = state.pipes[0];
	    dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  };

	  // set up data events if they are asked for
	  // Ensure readable listeners eventually get something
	  Readable.prototype.on = function (ev, fn) {
	    var res = Stream.prototype.on.call(this, ev, fn);
	    var state = this._readableState;
	    if (ev === 'data') {
	      // update readableListening so that resume() may be a no-op
	      // a few lines down. This is needed to support once('readable').
	      state.readableListening = this.listenerCount('readable') > 0;

	      // Try start flowing on next tick if stream isn't explicitly paused
	      if (state.flowing !== false) this.resume();
	    } else if (ev === 'readable') {
	      if (!state.endEmitted && !state.readableListening) {
	        state.readableListening = state.needReadable = true;
	        state.flowing = false;
	        state.emittedReadable = false;
	        debug('on readable', state.length, state.reading);
	        if (state.length) {
	          emitReadable(this);
	        } else if (!state.reading) {
	          process.nextTick(nReadingNextTick, this);
	        }
	      }
	    }
	    return res;
	  };
	  Readable.prototype.addListener = Readable.prototype.on;
	  Readable.prototype.removeListener = function (ev, fn) {
	    var res = Stream.prototype.removeListener.call(this, ev, fn);
	    if (ev === 'readable') {
	      // We need to check if there is someone still listening to
	      // readable and reset the state. However this needs to happen
	      // after readable has been emitted but before I/O (nextTick) to
	      // support once('readable', fn) cycles. This means that calling
	      // resume within the same tick will have no
	      // effect.
	      process.nextTick(updateReadableListening, this);
	    }
	    return res;
	  };
	  Readable.prototype.removeAllListeners = function (ev) {
	    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	    if (ev === 'readable' || ev === undefined) {
	      // We need to check if there is someone still listening to
	      // readable and reset the state. However this needs to happen
	      // after readable has been emitted but before I/O (nextTick) to
	      // support once('readable', fn) cycles. This means that calling
	      // resume within the same tick will have no
	      // effect.
	      process.nextTick(updateReadableListening, this);
	    }
	    return res;
	  };
	  function updateReadableListening(self) {
	    var state = self._readableState;
	    state.readableListening = self.listenerCount('readable') > 0;
	    if (state.resumeScheduled && !state.paused) {
	      // flowing needs to be set to true now, otherwise
	      // the upcoming resume will not flow.
	      state.flowing = true;

	      // crude way to check if we should resume
	    } else if (self.listenerCount('data') > 0) {
	      self.resume();
	    }
	  }
	  function nReadingNextTick(self) {
	    debug('readable nexttick read 0');
	    self.read(0);
	  }

	  // pause() and resume() are remnants of the legacy readable stream API
	  // If the user uses them, then switch into old mode.
	  Readable.prototype.resume = function () {
	    var state = this._readableState;
	    if (!state.flowing) {
	      debug('resume');
	      // we flow only if there is no one listening
	      // for readable, but we still have to call
	      // resume()
	      state.flowing = !state.readableListening;
	      resume(this, state);
	    }
	    state.paused = false;
	    return this;
	  };
	  function resume(stream, state) {
	    if (!state.resumeScheduled) {
	      state.resumeScheduled = true;
	      process.nextTick(resume_, stream, state);
	    }
	  }
	  function resume_(stream, state) {
	    debug('resume', state.reading);
	    if (!state.reading) {
	      stream.read(0);
	    }
	    state.resumeScheduled = false;
	    stream.emit('resume');
	    flow(stream);
	    if (state.flowing && !state.reading) stream.read(0);
	  }
	  Readable.prototype.pause = function () {
	    debug('call pause flowing=%j', this._readableState.flowing);
	    if (this._readableState.flowing !== false) {
	      debug('pause');
	      this._readableState.flowing = false;
	      this.emit('pause');
	    }
	    this._readableState.paused = true;
	    return this;
	  };
	  function flow(stream) {
	    var state = stream._readableState;
	    debug('flow', state.flowing);
	    while (state.flowing && stream.read() !== null);
	  }

	  // wrap an old-style stream as the async data source.
	  // This is *not* part of the readable stream interface.
	  // It is an ugly unfortunate mess of history.
	  Readable.prototype.wrap = function (stream) {
	    var _this = this;
	    var state = this._readableState;
	    var paused = false;
	    stream.on('end', function () {
	      debug('wrapped end');
	      if (state.decoder && !state.ended) {
	        var chunk = state.decoder.end();
	        if (chunk && chunk.length) _this.push(chunk);
	      }
	      _this.push(null);
	    });
	    stream.on('data', function (chunk) {
	      debug('wrapped data');
	      if (state.decoder) chunk = state.decoder.write(chunk);

	      // don't skip over falsy values in objectMode
	      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	      var ret = _this.push(chunk);
	      if (!ret) {
	        paused = true;
	        stream.pause();
	      }
	    });

	    // proxy all the other methods.
	    // important when wrapping filters and duplexes.
	    for (var i in stream) {
	      if (this[i] === undefined && typeof stream[i] === 'function') {
	        this[i] = function methodWrap(method) {
	          return function methodWrapReturnFunction() {
	            return stream[method].apply(stream, arguments);
	          };
	        }(i);
	      }
	    }

	    // proxy certain important events.
	    for (var n = 0; n < kProxyEvents.length; n++) {
	      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	    }

	    // when we try to consume some more bytes, simply unpause the
	    // underlying stream.
	    this._read = function (n) {
	      debug('wrapped _read', n);
	      if (paused) {
	        paused = false;
	        stream.resume();
	      }
	    };
	    return this;
	  };
	  if (typeof Symbol === 'function') {
	    Readable.prototype[Symbol.asyncIterator] = function () {
	      if (createReadableStreamAsyncIterator === undefined) {
	        createReadableStreamAsyncIterator = requireAsync_iterator();
	      }
	      return createReadableStreamAsyncIterator(this);
	    };
	  }
	  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._readableState.highWaterMark;
	    }
	  });
	  Object.defineProperty(Readable.prototype, 'readableBuffer', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._readableState && this._readableState.buffer;
	    }
	  });
	  Object.defineProperty(Readable.prototype, 'readableFlowing', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._readableState.flowing;
	    },
	    set: function set(state) {
	      if (this._readableState) {
	        this._readableState.flowing = state;
	      }
	    }
	  });

	  // exposed for testing purposes only.
	  Readable._fromList = fromList;
	  Object.defineProperty(Readable.prototype, 'readableLength', {
	    // making it explicit this property is not enumerable
	    // because otherwise some prototype manipulation in
	    // userland will fail
	    enumerable: false,
	    get: function get() {
	      return this._readableState.length;
	    }
	  });

	  // Pluck off n bytes from an array of buffers.
	  // Length is the combined lengths of all the buffers in the list.
	  // This function is designed to be inlinable, so please take care when making
	  // changes to the function body.
	  function fromList(n, state) {
	    // nothing buffered
	    if (state.length === 0) return null;
	    var ret;
	    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	      // read it all, truncate the list
	      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	      state.buffer.clear();
	    } else {
	      // read part of list
	      ret = state.buffer.consume(n, state.decoder);
	    }
	    return ret;
	  }
	  function endReadable(stream) {
	    var state = stream._readableState;
	    debug('endReadable', state.endEmitted);
	    if (!state.endEmitted) {
	      state.ended = true;
	      process.nextTick(endReadableNT, state, stream);
	    }
	  }
	  function endReadableNT(state, stream) {
	    debug('endReadableNT', state.endEmitted, state.length);

	    // Check that we didn't get one last unshift.
	    if (!state.endEmitted && state.length === 0) {
	      state.endEmitted = true;
	      stream.readable = false;
	      stream.emit('end');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the writable side is ready for autoDestroy as well
	        var wState = stream._writableState;
	        if (!wState || wState.autoDestroy && wState.finished) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  if (typeof Symbol === 'function') {
	    Readable.from = function (iterable, opts) {
	      if (from === undefined) {
	        from = requireFrom();
	      }
	      return from(Readable, iterable, opts);
	    };
	  }
	  function indexOf(xs, x) {
	    for (var i = 0, l = xs.length; i < l; i++) {
	      if (xs[i] === x) return i;
	    }
	    return -1;
	  }
	  return _stream_readable;
	}

	var _stream_transform;
	var hasRequired_stream_transform;
	function require_stream_transform() {
	  if (hasRequired_stream_transform) return _stream_transform;
	  hasRequired_stream_transform = 1;
	  _stream_transform = Transform;
	  var _require$codes = requireErrors().codes,
	    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	  var Duplex = require_stream_duplex();
	  require$$1$2(Transform, Duplex);
	  function afterTransform(er, data) {
	    var ts = this._transformState;
	    ts.transforming = false;
	    var cb = ts.writecb;
	    if (cb === null) {
	      return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	    }
	    ts.writechunk = null;
	    ts.writecb = null;
	    if (data != null)
	      // single equals check for both `null` and `undefined`
	      this.push(data);
	    cb(er);
	    var rs = this._readableState;
	    rs.reading = false;
	    if (rs.needReadable || rs.length < rs.highWaterMark) {
	      this._read(rs.highWaterMark);
	    }
	  }
	  function Transform(options) {
	    if (!(this instanceof Transform)) return new Transform(options);
	    Duplex.call(this, options);
	    this._transformState = {
	      afterTransform: afterTransform.bind(this),
	      needTransform: false,
	      transforming: false,
	      writecb: null,
	      writechunk: null,
	      writeencoding: null
	    };

	    // start out asking for a readable event once data is transformed.
	    this._readableState.needReadable = true;

	    // we have implemented the _read method, and done the other things
	    // that Readable wants before the first _read call, so unset the
	    // sync guard flag.
	    this._readableState.sync = false;
	    if (options) {
	      if (typeof options.transform === 'function') this._transform = options.transform;
	      if (typeof options.flush === 'function') this._flush = options.flush;
	    }

	    // When the writable side finishes, then flush out anything remaining.
	    this.on('prefinish', prefinish);
	  }
	  function prefinish() {
	    var _this = this;
	    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	      this._flush(function (er, data) {
	        done(_this, er, data);
	      });
	    } else {
	      done(this, null, null);
	    }
	  }
	  Transform.prototype.push = function (chunk, encoding) {
	    this._transformState.needTransform = false;
	    return Duplex.prototype.push.call(this, chunk, encoding);
	  };

	  // This is the part where you do stuff!
	  // override this function in implementation classes.
	  // 'chunk' is an input chunk.
	  //
	  // Call `push(newChunk)` to pass along transformed output
	  // to the readable side.  You may call 'push' zero or more times.
	  //
	  // Call `cb(err)` when you are done with this chunk.  If you pass
	  // an error, then that'll put the hurt on the whole operation.  If you
	  // never call cb(), then you'll never get another chunk.
	  Transform.prototype._transform = function (chunk, encoding, cb) {
	    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	  };
	  Transform.prototype._write = function (chunk, encoding, cb) {
	    var ts = this._transformState;
	    ts.writecb = cb;
	    ts.writechunk = chunk;
	    ts.writeencoding = encoding;
	    if (!ts.transforming) {
	      var rs = this._readableState;
	      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	    }
	  };

	  // Doesn't matter what the args are here.
	  // _transform does all the work.
	  // That we got here means that the readable side wants more data.
	  Transform.prototype._read = function (n) {
	    var ts = this._transformState;
	    if (ts.writechunk !== null && !ts.transforming) {
	      ts.transforming = true;
	      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	    } else {
	      // mark that we need a transform, so that any data that comes in
	      // will get processed, now that we've asked for it.
	      ts.needTransform = true;
	    }
	  };
	  Transform.prototype._destroy = function (err, cb) {
	    Duplex.prototype._destroy.call(this, err, function (err2) {
	      cb(err2);
	    });
	  };
	  function done(stream, er, data) {
	    if (er) return stream.emit('error', er);
	    if (data != null)
	      // single equals check for both `null` and `undefined`
	      stream.push(data);

	    // TODO(BridgeAR): Write a test for these two error cases
	    // if there's nothing in the write buffer, then that means
	    // that nothing more will ever be provided
	    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	    return stream.push(null);
	  }
	  return _stream_transform;
	}

	var _stream_passthrough;
	var hasRequired_stream_passthrough;
	function require_stream_passthrough() {
	  if (hasRequired_stream_passthrough) return _stream_passthrough;
	  hasRequired_stream_passthrough = 1;
	  _stream_passthrough = PassThrough;
	  var Transform = require_stream_transform();
	  require$$1$2(PassThrough, Transform);
	  function PassThrough(options) {
	    if (!(this instanceof PassThrough)) return new PassThrough(options);
	    Transform.call(this, options);
	  }
	  PassThrough.prototype._transform = function (chunk, encoding, cb) {
	    cb(null, chunk);
	  };
	  return _stream_passthrough;
	}

	var pipeline_1;
	var hasRequiredPipeline;
	function requirePipeline() {
	  if (hasRequiredPipeline) return pipeline_1;
	  hasRequiredPipeline = 1;
	  var eos;
	  function once(callback) {
	    var called = false;
	    return function () {
	      if (called) return;
	      called = true;
	      callback.apply(void 0, arguments);
	    };
	  }
	  var _require$codes = requireErrors().codes,
	    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	  function noop(err) {
	    // Rethrow the error if it exists to avoid swallowing it
	    if (err) throw err;
	  }
	  function isRequest(stream) {
	    return stream.setHeader && typeof stream.abort === 'function';
	  }
	  function destroyer(stream, reading, writing, callback) {
	    callback = once(callback);
	    var closed = false;
	    stream.on('close', function () {
	      closed = true;
	    });
	    if (eos === undefined) eos = requireEndOfStream();
	    eos(stream, {
	      readable: reading,
	      writable: writing
	    }, function (err) {
	      if (err) return callback(err);
	      closed = true;
	      callback();
	    });
	    var destroyed = false;
	    return function (err) {
	      if (closed) return;
	      if (destroyed) return;
	      destroyed = true;

	      // request.destroy just do .end - .abort is what we want
	      if (isRequest(stream)) return stream.abort();
	      if (typeof stream.destroy === 'function') return stream.destroy();
	      callback(err || new ERR_STREAM_DESTROYED('pipe'));
	    };
	  }
	  function call(fn) {
	    fn();
	  }
	  function pipe(from, to) {
	    return from.pipe(to);
	  }
	  function popCallback(streams) {
	    if (!streams.length) return noop;
	    if (typeof streams[streams.length - 1] !== 'function') return noop;
	    return streams.pop();
	  }
	  function pipeline() {
	    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	      streams[_key] = arguments[_key];
	    }
	    var callback = popCallback(streams);
	    if (Array.isArray(streams[0])) streams = streams[0];
	    if (streams.length < 2) {
	      throw new ERR_MISSING_ARGS('streams');
	    }
	    var error;
	    var destroys = streams.map(function (stream, i) {
	      var reading = i < streams.length - 1;
	      var writing = i > 0;
	      return destroyer(stream, reading, writing, function (err) {
	        if (!error) error = err;
	        if (err) destroys.forEach(call);
	        if (reading) return;
	        destroys.forEach(call);
	        callback(error);
	      });
	    });
	    return streams.reduce(pipe);
	  }
	  pipeline_1 = pipeline;
	  return pipeline_1;
	}

	(function (module, exports) {
	  var Stream = require$$0$5;
	  if (process.env.READABLE_STREAM === 'disable' && Stream) {
	    module.exports = Stream.Readable;
	    Object.assign(module.exports, Stream);
	    module.exports.Stream = Stream;
	  } else {
	    exports = module.exports = require_stream_readable();
	    exports.Stream = Stream || exports;
	    exports.Readable = exports;
	    exports.Writable = require_stream_writable();
	    exports.Duplex = require_stream_duplex();
	    exports.Transform = require_stream_transform();
	    exports.PassThrough = require_stream_passthrough();
	    exports.finished = requireEndOfStream();
	    exports.pipeline = requirePipeline();
	  }
	})(readable, readable.exports);
	var readableExports = readable.exports;

	const {
	  Buffer: Buffer$2
	} = require$$0$1;
	const symbol = Symbol.for('BufferList');
	function BufferList$1(buf) {
	  if (!(this instanceof BufferList$1)) {
	    return new BufferList$1(buf);
	  }
	  BufferList$1._init.call(this, buf);
	}
	BufferList$1._init = function _init(buf) {
	  Object.defineProperty(this, symbol, {
	    value: true
	  });
	  this._bufs = [];
	  this.length = 0;
	  if (buf) {
	    this.append(buf);
	  }
	};
	BufferList$1.prototype._new = function _new(buf) {
	  return new BufferList$1(buf);
	};
	BufferList$1.prototype._offset = function _offset(offset) {
	  if (offset === 0) {
	    return [0, 0];
	  }
	  let tot = 0;
	  for (let i = 0; i < this._bufs.length; i++) {
	    const _t = tot + this._bufs[i].length;
	    if (offset < _t || i === this._bufs.length - 1) {
	      return [i, offset - tot];
	    }
	    tot = _t;
	  }
	};
	BufferList$1.prototype._reverseOffset = function (blOffset) {
	  const bufferId = blOffset[0];
	  let offset = blOffset[1];
	  for (let i = 0; i < bufferId; i++) {
	    offset += this._bufs[i].length;
	  }
	  return offset;
	};
	BufferList$1.prototype.get = function get(index) {
	  if (index > this.length || index < 0) {
	    return undefined;
	  }
	  const offset = this._offset(index);
	  return this._bufs[offset[0]][offset[1]];
	};
	BufferList$1.prototype.slice = function slice(start, end) {
	  if (typeof start === 'number' && start < 0) {
	    start += this.length;
	  }
	  if (typeof end === 'number' && end < 0) {
	    end += this.length;
	  }
	  return this.copy(null, 0, start, end);
	};
	BufferList$1.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart !== 'number' || srcStart < 0) {
	    srcStart = 0;
	  }
	  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
	    srcEnd = this.length;
	  }
	  if (srcStart >= this.length) {
	    return dst || Buffer$2.alloc(0);
	  }
	  if (srcEnd <= 0) {
	    return dst || Buffer$2.alloc(0);
	  }
	  const copy = !!dst;
	  const off = this._offset(srcStart);
	  const len = srcEnd - srcStart;
	  let bytes = len;
	  let bufoff = copy && dstStart || 0;
	  let start = off[1];

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd === this.length) {
	    if (!copy) {
	      // slice, but full concat if multiple buffers
	      return this._bufs.length === 1 ? this._bufs[0] : Buffer$2.concat(this._bufs, this.length);
	    }

	    // copy, need to copy individual buffers
	    for (let i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }
	    return dst;
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
	  }
	  if (!copy) {
	    // a slice, we need something to copy in to
	    dst = Buffer$2.allocUnsafe(len);
	  }
	  for (let i = off[0]; i < this._bufs.length; i++) {
	    const l = this._bufs[i].length - start;
	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break;
	    }
	    bytes -= l;
	    if (start) {
	      start = 0;
	    }
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff);
	  return dst;
	};
	BufferList$1.prototype.shallowSlice = function shallowSlice(start, end) {
	  start = start || 0;
	  end = typeof end !== 'number' ? this.length : end;
	  if (start < 0) {
	    start += this.length;
	  }
	  if (end < 0) {
	    end += this.length;
	  }
	  if (start === end) {
	    return this._new();
	  }
	  const startOffset = this._offset(start);
	  const endOffset = this._offset(end);
	  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
	  if (endOffset[1] === 0) {
	    buffers.pop();
	  } else {
	    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
	  }
	  if (startOffset[1] !== 0) {
	    buffers[0] = buffers[0].slice(startOffset[1]);
	  }
	  return this._new(buffers);
	};
	BufferList$1.prototype.toString = function toString(encoding, start, end) {
	  return this.slice(start, end).toString(encoding);
	};
	BufferList$1.prototype.consume = function consume(bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this;
	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break;
	    }
	  }
	  return this;
	};
	BufferList$1.prototype.duplicate = function duplicate() {
	  const copy = this._new();
	  for (let i = 0; i < this._bufs.length; i++) {
	    copy.append(this._bufs[i]);
	  }
	  return copy;
	};
	BufferList$1.prototype.append = function append(buf) {
	  if (buf == null) {
	    return this;
	  }
	  if (buf.buffer) {
	    // append a view of the underlying ArrayBuffer
	    this._appendBuffer(Buffer$2.from(buf.buffer, buf.byteOffset, buf.byteLength));
	  } else if (Array.isArray(buf)) {
	    for (let i = 0; i < buf.length; i++) {
	      this.append(buf[i]);
	    }
	  } else if (this._isBufferList(buf)) {
	    // unwrap argument into individual BufferLists
	    for (let i = 0; i < buf._bufs.length; i++) {
	      this.append(buf._bufs[i]);
	    }
	  } else {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf === 'number') {
	      buf = buf.toString();
	    }
	    this._appendBuffer(Buffer$2.from(buf));
	  }
	  return this;
	};
	BufferList$1.prototype._appendBuffer = function appendBuffer(buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};
	BufferList$1.prototype.indexOf = function (search, offset, encoding) {
	  if (encoding === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;
	  }
	  if (typeof search === 'function' || Array.isArray(search)) {
	    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
	  } else if (typeof search === 'number') {
	    search = Buffer$2.from([search]);
	  } else if (typeof search === 'string') {
	    search = Buffer$2.from(search, encoding);
	  } else if (this._isBufferList(search)) {
	    search = search.slice();
	  } else if (Array.isArray(search.buffer)) {
	    search = Buffer$2.from(search.buffer, search.byteOffset, search.byteLength);
	  } else if (!Buffer$2.isBuffer(search)) {
	    search = Buffer$2.from(search);
	  }
	  offset = Number(offset || 0);
	  if (isNaN(offset)) {
	    offset = 0;
	  }
	  if (offset < 0) {
	    offset = this.length + offset;
	  }
	  if (offset < 0) {
	    offset = 0;
	  }
	  if (search.length === 0) {
	    return offset > this.length ? this.length : offset;
	  }
	  const blOffset = this._offset(offset);
	  let blIndex = blOffset[0]; // index of which internal buffer we're working on
	  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

	  // scan over each buffer
	  for (; blIndex < this._bufs.length; blIndex++) {
	    const buff = this._bufs[blIndex];
	    while (buffOffset < buff.length) {
	      const availableWindow = buff.length - buffOffset;
	      if (availableWindow >= search.length) {
	        const nativeSearchResult = buff.indexOf(search, buffOffset);
	        if (nativeSearchResult !== -1) {
	          return this._reverseOffset([blIndex, nativeSearchResult]);
	        }
	        buffOffset = buff.length - search.length + 1; // end of native search window
	      } else {
	        const revOffset = this._reverseOffset([blIndex, buffOffset]);
	        if (this._match(revOffset, search)) {
	          return revOffset;
	        }
	        buffOffset++;
	      }
	    }
	    buffOffset = 0;
	  }
	  return -1;
	};
	BufferList$1.prototype._match = function (offset, search) {
	  if (this.length - offset < search.length) {
	    return false;
	  }
	  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
	    if (this.get(offset + searchOffset) !== search[searchOffset]) {
	      return false;
	    }
	  }
	  return true;
	};
	(function () {
	  const methods = {
	    readDoubleBE: 8,
	    readDoubleLE: 8,
	    readFloatBE: 4,
	    readFloatLE: 4,
	    readInt32BE: 4,
	    readInt32LE: 4,
	    readUInt32BE: 4,
	    readUInt32LE: 4,
	    readInt16BE: 2,
	    readInt16LE: 2,
	    readUInt16BE: 2,
	    readUInt16LE: 2,
	    readInt8: 1,
	    readUInt8: 1,
	    readIntBE: null,
	    readIntLE: null,
	    readUIntBE: null,
	    readUIntLE: null
	  };
	  for (const m in methods) {
	    (function (m) {
	      if (methods[m] === null) {
	        BufferList$1.prototype[m] = function (offset, byteLength) {
	          return this.slice(offset, offset + byteLength)[m](0, byteLength);
	        };
	      } else {
	        BufferList$1.prototype[m] = function (offset = 0) {
	          return this.slice(offset, offset + methods[m])[m](0);
	        };
	      }
	    })(m);
	  }
	})();

	// Used internally by the class and also as an indicator of this object being
	// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
	// environment because there could be multiple different copies of the
	// BufferList class and some `BufferList`s might be `BufferList`s.
	BufferList$1.prototype._isBufferList = function _isBufferList(b) {
	  return b instanceof BufferList$1 || BufferList$1.isBufferList(b);
	};
	BufferList$1.isBufferList = function isBufferList(b) {
	  return b != null && b[symbol];
	};
	var BufferList_1 = BufferList$1;

	const DuplexStream = readableExports.Duplex;
	const inherits = require$$1$2;
	const BufferList = BufferList_1;
	function BufferListStream$1(callback) {
	  if (!(this instanceof BufferListStream$1)) {
	    return new BufferListStream$1(callback);
	  }
	  if (typeof callback === 'function') {
	    this._callback = callback;
	    const piper = function piper(err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);
	    this.on('pipe', function onPipe(src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe(src) {
	      src.removeListener('error', piper);
	    });
	    callback = null;
	  }
	  BufferList._init.call(this, callback);
	  DuplexStream.call(this);
	}
	inherits(BufferListStream$1, DuplexStream);
	Object.assign(BufferListStream$1.prototype, BufferList.prototype);
	BufferListStream$1.prototype._new = function _new(callback) {
	  return new BufferListStream$1(callback);
	};
	BufferListStream$1.prototype._write = function _write(buf, encoding, callback) {
	  this._appendBuffer(buf);
	  if (typeof callback === 'function') {
	    callback();
	  }
	};
	BufferListStream$1.prototype._read = function _read(size) {
	  if (!this.length) {
	    return this.push(null);
	  }
	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};
	BufferListStream$1.prototype.end = function end(chunk) {
	  DuplexStream.prototype.end.call(this, chunk);
	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};
	BufferListStream$1.prototype._destroy = function _destroy(err, cb) {
	  this._bufs.length = 0;
	  this.length = 0;
	  cb(err);
	};
	BufferListStream$1.prototype._isBufferList = function _isBufferList(b) {
	  return b instanceof BufferListStream$1 || b instanceof BufferList || BufferListStream$1.isBufferList(b);
	};
	BufferListStream$1.isBufferList = BufferList.isBufferList;
	bl.exports = BufferListStream$1;
	bl.exports.BufferListStream = BufferListStream$1;
	bl.exports.BufferList = BufferList;
	var blExports = bl.exports;

	const readline = require$$0$3;
	const chalk = source;
	const cliCursor = cliCursor$2;
	const cliSpinners = cliSpinners$1;
	const logSymbols = logSymbols$1;
	const stripAnsi = stripAnsi$3;
	const wcwidth = wcwidthExports;
	const isInteractive = isInteractive$1;
	const isUnicodeSupported = isUnicodeSupported$2;
	const {
	  BufferListStream
	} = blExports;
	const TEXT = Symbol('text');
	const PREFIX_TEXT = Symbol('prefixText');
	const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

	class StdinDiscarder {
	  constructor() {
	    this.requests = 0;
	    this.mutedStream = new BufferListStream();
	    this.mutedStream.pipe(process.stdout);
	    const self = this; // eslint-disable-line unicorn/no-this-assignment
	    this.ourEmit = function (event, data, ...args) {
	      const {
	        stdin
	      } = process;
	      if (self.requests > 0 || stdin.emit === self.ourEmit) {
	        if (event === 'keypress') {
	          // Fixes readline behavior
	          return;
	        }
	        if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
	          process.emit('SIGINT');
	        }
	        Reflect.apply(self.oldEmit, this, [event, data, ...args]);
	      } else {
	        Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
	      }
	    };
	  }
	  start() {
	    this.requests++;
	    if (this.requests === 1) {
	      this.realStart();
	    }
	  }
	  stop() {
	    if (this.requests <= 0) {
	      throw new Error('`stop` called more times than `start`');
	    }
	    this.requests--;
	    if (this.requests === 0) {
	      this.realStop();
	    }
	  }
	  realStart() {
	    // No known way to make it work reliably on Windows
	    if (process.platform === 'win32') {
	      return;
	    }
	    this.rl = readline.createInterface({
	      input: process.stdin,
	      output: this.mutedStream
	    });
	    this.rl.on('SIGINT', () => {
	      if (process.listenerCount('SIGINT') === 0) {
	        process.emit('SIGINT');
	      } else {
	        this.rl.close();
	        process.kill(process.pid, 'SIGINT');
	      }
	    });
	  }
	  realStop() {
	    if (process.platform === 'win32') {
	      return;
	    }
	    this.rl.close();
	    this.rl = undefined;
	  }
	}
	let stdinDiscarder;
	class Ora {
	  constructor(options) {
	    if (!stdinDiscarder) {
	      stdinDiscarder = new StdinDiscarder();
	    }
	    if (typeof options === 'string') {
	      options = {
	        text: options
	      };
	    }
	    this.options = {
	      text: '',
	      color: 'cyan',
	      stream: process.stderr,
	      discardStdin: true,
	      ...options
	    };
	    this.spinner = this.options.spinner;
	    this.color = this.options.color;
	    this.hideCursor = this.options.hideCursor !== false;
	    this.interval = this.options.interval || this.spinner.interval || 100;
	    this.stream = this.options.stream;
	    this.id = undefined;
	    this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({
	      stream: this.stream
	    });
	    this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false;

	    // Set *after* `this.stream`
	    this.text = this.options.text;
	    this.prefixText = this.options.prefixText;
	    this.linesToClear = 0;
	    this.indent = this.options.indent;
	    this.discardStdin = this.options.discardStdin;
	    this.isDiscardingStdin = false;
	  }
	  get indent() {
	    return this._indent;
	  }
	  set indent(indent = 0) {
	    if (!(indent >= 0 && Number.isInteger(indent))) {
	      throw new Error('The `indent` option must be an integer from 0 and up');
	    }
	    this._indent = indent;
	  }
	  _updateInterval(interval) {
	    if (interval !== undefined) {
	      this.interval = interval;
	    }
	  }
	  get spinner() {
	    return this._spinner;
	  }
	  set spinner(spinner) {
	    this.frameIndex = 0;
	    if (typeof spinner === 'object') {
	      if (spinner.frames === undefined) {
	        throw new Error('The given spinner must have a `frames` property');
	      }
	      this._spinner = spinner;
	    } else if (!isUnicodeSupported()) {
	      this._spinner = cliSpinners.line;
	    } else if (spinner === undefined) {
	      // Set default spinner
	      this._spinner = cliSpinners.dots;
	    } else if (spinner !== 'default' && cliSpinners[spinner]) {
	      this._spinner = cliSpinners[spinner];
	    } else {
	      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
	    }
	    this._updateInterval(this._spinner.interval);
	  }
	  get text() {
	    return this[TEXT];
	  }
	  set text(value) {
	    this[TEXT] = value;
	    this.updateLineCount();
	  }
	  get prefixText() {
	    return this[PREFIX_TEXT];
	  }
	  set prefixText(value) {
	    this[PREFIX_TEXT] = value;
	    this.updateLineCount();
	  }
	  get isSpinning() {
	    return this.id !== undefined;
	  }
	  getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {
	    if (typeof prefixText === 'string') {
	      return prefixText + postfix;
	    }
	    if (typeof prefixText === 'function') {
	      return prefixText() + postfix;
	    }
	    return '';
	  }
	  updateLineCount() {
	    const columns = this.stream.columns || 80;
	    const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');
	    this.lineCount = 0;
	    for (const line of stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\n')) {
	      this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
	    }
	  }
	  get isEnabled() {
	    return this._isEnabled && !this.isSilent;
	  }
	  set isEnabled(value) {
	    if (typeof value !== 'boolean') {
	      throw new TypeError('The `isEnabled` option must be a boolean');
	    }
	    this._isEnabled = value;
	  }
	  get isSilent() {
	    return this._isSilent;
	  }
	  set isSilent(value) {
	    if (typeof value !== 'boolean') {
	      throw new TypeError('The `isSilent` option must be a boolean');
	    }
	    this._isSilent = value;
	  }
	  frame() {
	    const {
	      frames
	    } = this.spinner;
	    let frame = frames[this.frameIndex];
	    if (this.color) {
	      frame = chalk[this.color](frame);
	    }
	    this.frameIndex = ++this.frameIndex % frames.length;
	    const fullPrefixText = typeof this.prefixText === 'string' && this.prefixText !== '' ? this.prefixText + ' ' : '';
	    const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
	    return fullPrefixText + frame + fullText;
	  }
	  clear() {
	    if (!this.isEnabled || !this.stream.isTTY) {
	      return this;
	    }
	    for (let i = 0; i < this.linesToClear; i++) {
	      if (i > 0) {
	        this.stream.moveCursor(0, -1);
	      }
	      this.stream.clearLine();
	      this.stream.cursorTo(this.indent);
	    }
	    this.linesToClear = 0;
	    return this;
	  }
	  render() {
	    if (this.isSilent) {
	      return this;
	    }
	    this.clear();
	    this.stream.write(this.frame());
	    this.linesToClear = this.lineCount;
	    return this;
	  }
	  start(text) {
	    if (text) {
	      this.text = text;
	    }
	    if (this.isSilent) {
	      return this;
	    }
	    if (!this.isEnabled) {
	      if (this.text) {
	        this.stream.write(`- ${this.text}\n`);
	      }
	      return this;
	    }
	    if (this.isSpinning) {
	      return this;
	    }
	    if (this.hideCursor) {
	      cliCursor.hide(this.stream);
	    }
	    if (this.discardStdin && process.stdin.isTTY) {
	      this.isDiscardingStdin = true;
	      stdinDiscarder.start();
	    }
	    this.render();
	    this.id = setInterval(this.render.bind(this), this.interval);
	    return this;
	  }
	  stop() {
	    if (!this.isEnabled) {
	      return this;
	    }
	    clearInterval(this.id);
	    this.id = undefined;
	    this.frameIndex = 0;
	    this.clear();
	    if (this.hideCursor) {
	      cliCursor.show(this.stream);
	    }
	    if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
	      stdinDiscarder.stop();
	      this.isDiscardingStdin = false;
	    }
	    return this;
	  }
	  succeed(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols.success,
	      text
	    });
	  }
	  fail(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols.error,
	      text
	    });
	  }
	  warn(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols.warning,
	      text
	    });
	  }
	  info(text) {
	    return this.stopAndPersist({
	      symbol: logSymbols.info,
	      text
	    });
	  }
	  stopAndPersist(options = {}) {
	    if (this.isSilent) {
	      return this;
	    }
	    const prefixText = options.prefixText || this.prefixText;
	    const text = options.text || this.text;
	    const fullText = typeof text === 'string' ? ' ' + text : '';
	    this.stop();
	    this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\n`);
	    return this;
	  }
	}
	const oraFactory = function (options) {
	  return new Ora(options);
	};
	ora$1.exports = oraFactory;
	ora$1.exports.promise = (action, options) => {
	  // eslint-disable-next-line promise/prefer-await-to-then
	  if (typeof action.then !== 'function') {
	    throw new TypeError('Parameter `action` must be a Promise');
	  }
	  const spinner = new Ora(options);
	  spinner.start();
	  (async () => {
	    try {
	      await action;
	      spinner.succeed();
	    } catch {
	      spinner.fail();
	    }
	  })();
	  return spinner;
	};
	var oraExports = ora$1.exports;
	var ora = /*@__PURE__*/getDefaultExportFromCjs(oraExports);

	var ansiEscapes$1 = {exports: {}};

	(function (module) {

	  const ansiEscapes = module.exports;
	  // TODO: remove this in the next major version
	  module.exports.default = ansiEscapes;
	  const ESC = '\u001B[';
	  const OSC = '\u001B]';
	  const BEL = '\u0007';
	  const SEP = ';';
	  const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';
	  ansiEscapes.cursorTo = (x, y) => {
	    if (typeof x !== 'number') {
	      throw new TypeError('The `x` argument is required');
	    }
	    if (typeof y !== 'number') {
	      return ESC + (x + 1) + 'G';
	    }
	    return ESC + (y + 1) + ';' + (x + 1) + 'H';
	  };
	  ansiEscapes.cursorMove = (x, y) => {
	    if (typeof x !== 'number') {
	      throw new TypeError('The `x` argument is required');
	    }
	    let ret = '';
	    if (x < 0) {
	      ret += ESC + -x + 'D';
	    } else if (x > 0) {
	      ret += ESC + x + 'C';
	    }
	    if (y < 0) {
	      ret += ESC + -y + 'A';
	    } else if (y > 0) {
	      ret += ESC + y + 'B';
	    }
	    return ret;
	  };
	  ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
	  ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
	  ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
	  ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';
	  ansiEscapes.cursorLeft = ESC + 'G';
	  ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
	  ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
	  ansiEscapes.cursorGetPosition = ESC + '6n';
	  ansiEscapes.cursorNextLine = ESC + 'E';
	  ansiEscapes.cursorPrevLine = ESC + 'F';
	  ansiEscapes.cursorHide = ESC + '?25l';
	  ansiEscapes.cursorShow = ESC + '?25h';
	  ansiEscapes.eraseLines = count => {
	    let clear = '';
	    for (let i = 0; i < count; i++) {
	      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
	    }
	    if (count) {
	      clear += ansiEscapes.cursorLeft;
	    }
	    return clear;
	  };
	  ansiEscapes.eraseEndLine = ESC + 'K';
	  ansiEscapes.eraseStartLine = ESC + '1K';
	  ansiEscapes.eraseLine = ESC + '2K';
	  ansiEscapes.eraseDown = ESC + 'J';
	  ansiEscapes.eraseUp = ESC + '1J';
	  ansiEscapes.eraseScreen = ESC + '2J';
	  ansiEscapes.scrollUp = ESC + 'S';
	  ansiEscapes.scrollDown = ESC + 'T';
	  ansiEscapes.clearScreen = '\u001Bc';
	  ansiEscapes.clearTerminal = process.platform === 'win32' ? `${ansiEscapes.eraseScreen}${ESC}0f` :
	  // 1. Erases the screen (Only done in case `2` is not supported)
	  // 2. Erases the whole screen including scrollback buffer
	  // 3. Moves cursor to the top-left position
	  // More info: https://www.real-world-systems.com/docs/ANSIcode.html
	  `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
	  ansiEscapes.beep = BEL;
	  ansiEscapes.link = (text, url) => {
	    return [OSC, '8', SEP, SEP, url, BEL, text, OSC, '8', SEP, SEP, BEL].join('');
	  };
	  ansiEscapes.image = (buffer, options = {}) => {
	    let ret = `${OSC}1337;File=inline=1`;
	    if (options.width) {
	      ret += `;width=${options.width}`;
	    }
	    if (options.height) {
	      ret += `;height=${options.height}`;
	    }
	    if (options.preserveAspectRatio === false) {
	      ret += ';preserveAspectRatio=0';
	    }
	    return ret + ':' + buffer.toString('base64') + BEL;
	  };
	  ansiEscapes.iTerm = {
	    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
	    annotation: (message, options = {}) => {
	      let ret = `${OSC}1337;`;
	      const hasX = typeof options.x !== 'undefined';
	      const hasY = typeof options.y !== 'undefined';
	      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
	        throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
	      }
	      message = message.replace(/\|/g, '');
	      ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';
	      if (options.length > 0) {
	        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join('|');
	      } else {
	        ret += message;
	      }
	      return ret + BEL;
	    }
	  };
	})(ansiEscapes$1);
	var ansiEscapesExports = ansiEscapes$1.exports;
	var ansiEscapes = /*@__PURE__*/getDefaultExportFromCjs(ansiEscapesExports);

	/**
	 * Move cursor left by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go left (default to 1)
	 */

	const left = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorBackward(x));
	};

	/**
	 * Move cursor right by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go left (default to 1)
	 */

	const right = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorForward(x));
	};

	/**
	 * Move cursor up by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go up (default to 1)
	 */

	const up = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorUp(x));
	};

	/**
	 * Move cursor down by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go down (default to 1)
	 */

	const down = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorDown(x));
	};

	/**
	 * Clear current line
	 * @param  {Readline} rl  - Readline instance
	 * @param  {Number}   len - number of line to delete
	 */
	const clearLine = function (rl, len) {
	  rl.output.write(ansiEscapes.eraseLines(len));
	};

	function height(content) {
	  return content.split('\n').length;
	}

	/** @param {string} content */
	function lastLine(content) {
	  return content.split('\n').pop();
	}
	class ScreenManager {
	  constructor(rl) {
	    // These variables are keeping information to allow correct prompt re-rendering
	    this.height = 0;
	    this.extraLinesUnderPrompt = 0;
	    this.rl = rl;
	  }
	  renderWithSpinner(content, bottomContent) {
	    if (this.spinnerId) {
	      clearInterval(this.spinnerId);
	    }
	    let spinner;
	    let contentFunc;
	    let bottomContentFunc;
	    if (bottomContent) {
	      spinner = ora(bottomContent);
	      contentFunc = () => content;
	      bottomContentFunc = () => spinner.frame();
	    } else {
	      spinner = ora(content);
	      contentFunc = () => spinner.frame();
	      bottomContentFunc = () => '';
	    }
	    this.spinnerId = setInterval(() => this.render(contentFunc(), bottomContentFunc(), true), spinner.interval);
	  }
	  render(content, bottomContent, spinning = false) {
	    if (this.spinnerId && !spinning) {
	      clearInterval(this.spinnerId);
	    }
	    this.rl.output.unmute();
	    this.clean(this.extraLinesUnderPrompt);

	    /**
	     * Write message to screen and setPrompt to control backspace
	     */

	    const promptLine = lastLine(content);
	    const rawPromptLine = stripAnsi$4(promptLine);

	    // Remove the rl.line from our prompt. We can't rely on the content of
	    // rl.line (mainly because of the password prompt), so just rely on it's
	    // length.
	    let prompt = rawPromptLine;
	    if (this.rl.line.length > 0) {
	      prompt = prompt.slice(0, -this.rl.line.length);
	    }
	    this.rl.setPrompt(prompt);

	    // SetPrompt will change cursor position, now we can get correct value
	    const cursorPos = this.rl._getCursorPos();
	    const width = this.normalizedCliWidth();
	    content = this.forceLineReturn(content, width);
	    bottomContent &&= this.forceLineReturn(bottomContent, width);

	    // Manually insert an extra line if we're at the end of the line.
	    // This prevent the cursor from appearing at the beginning of the
	    // current line.
	    if (rawPromptLine.length % width === 0) {
	      content += '\n';
	    }
	    const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
	    this.rl.output.write(fullContent);

	    /**
	     * Re-adjust the cursor at the correct position.
	     */

	    // We need to consider parts of the prompt under the cursor as part of the bottom
	    // content in order to correctly cleanup and re-render.
	    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
	    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
	    if (bottomContentHeight > 0) {
	      up(this.rl, bottomContentHeight);
	    }

	    // Reset cursor at the beginning of the line
	    left(this.rl, stringWidth$2(lastLine(fullContent)));

	    // Adjust cursor on the right
	    if (cursorPos.cols > 0) {
	      right(this.rl, cursorPos.cols);
	    }

	    /**
	     * Set up state for next re-rendering
	     */
	    this.extraLinesUnderPrompt = bottomContentHeight;
	    this.height = height(fullContent);
	    this.rl.output.mute();
	  }
	  clean(extraLines) {
	    if (extraLines > 0) {
	      down(this.rl, extraLines);
	    }
	    clearLine(this.rl, this.height);
	  }
	  done() {
	    this.rl.setPrompt('');
	    this.rl.output.unmute();
	    this.rl.output.write('\n');
	  }
	  releaseCursor() {
	    if (this.extraLinesUnderPrompt > 0) {
	      down(this.rl, this.extraLinesUnderPrompt);
	    }
	  }
	  normalizedCliWidth() {
	    const width = cliWidth$1({
	      defaultWidth: 80,
	      output: this.rl.output
	    });
	    return width;
	  }

	  /**
	   * @param {string[]} lines
	   */
	  breakLines(lines, width = this.normalizedCliWidth()) {
	    // Break lines who're longer than the cli width so we can normalize the natural line
	    // returns behavior across terminals.
	    // re: trim: false; by default, `wrap-ansi` trims whitespace, which
	    // is not what we want.
	    // re: hard: true; by default', `wrap-ansi` does soft wrapping
	    return lines.map(line => wrapAnsi$1(line, width, {
	      trim: false,
	      hard: true
	    }).split('\n'));
	  }

	  /**
	   * @param {string} content
	   */
	  forceLineReturn(content, width = this.normalizedCliWidth()) {
	    return this.breakLines(content.split('\n'), width).flat().join('\n');
	  }
	}

	/**
	 * Base prompt implementation
	 * Should be extended by prompt types.
	 */
	const _$1 = {
	  defaults: defaults$3,
	  clone: clone$3
	};
	class Prompt {
	  constructor(question, rl, answers) {
	    // Setup instance defaults property
	    Object.assign(this, {
	      answers,
	      status: 'pending'
	    });

	    // Set defaults prompt options
	    this.opt = _$1.defaults(_$1.clone(question), {
	      validate: () => true,
	      validatingText: '',
	      filter: val => val,
	      filteringText: '',
	      when: () => true,
	      suffix: '',
	      prefix: chalk$3.green('?'),
	      transformer: val => val
	    });

	    // Make sure name is present
	    if (!this.opt.name) {
	      this.throwParamError('name');
	    }

	    // Set default message if no message defined
	    this.opt.message ||= this.opt.name + ':';

	    // Normalize choices
	    if (Array.isArray(this.opt.choices)) {
	      this.opt.choices = new Choices(this.opt.choices, answers);
	    }
	    this.rl = rl;
	    this.screen = new ScreenManager(this.rl);
	  }

	  /**
	   * Start the Inquiry session and manage output value filtering
	   * @return {Promise}
	   */

	  run() {
	    return new Promise((resolve, reject) => {
	      this._run(value => resolve(value), error => reject(error));
	    });
	  }

	  // Default noop (this one should be overwritten in prompts)
	  _run(cb) {
	    cb();
	  }

	  /**
	   * Throw an error telling a required parameter is missing
	   * @param  {String} name Name of the missing param
	   * @return {Throw Error}
	   */

	  throwParamError(name) {
	    throw new Error('You must provide a `' + name + '` parameter');
	  }

	  /**
	   * Called when the UI closes. Override to do any specific cleanup necessary
	   */
	  close() {
	    this.screen.releaseCursor();
	  }

	  /**
	   * Run the provided validation method each time a submit event occur.
	   * @param  {Rx.Observable} submit - submit event flow
	   * @return {Object}        Object containing two observables: `success` and `error`
	   */
	  handleSubmitEvents(submit) {
	    const validate = runAsync$1(this.opt.validate);
	    const asyncFilter = runAsync$1(this.opt.filter);
	    const validation = submit.pipe(flatMap(value => {
	      this.startSpinner(value, this.opt.filteringText);
	      return asyncFilter(value, this.answers).then(filteredValue => {
	        this.startSpinner(filteredValue, this.opt.validatingText);
	        return validate(filteredValue, this.answers).then(isValid => ({
	          isValid,
	          value: filteredValue
	        }), error_ => ({
	          isValid: error_,
	          value: filteredValue
	        }));
	      }, error_ => ({
	        isValid: error_
	      }));
	    }), share());
	    const success = validation.pipe(filter$2(state => state.isValid === true), take(1));
	    const error = validation.pipe(filter$2(state => state.isValid !== true), takeUntil(success));
	    return {
	      success,
	      error
	    };
	  }
	  startSpinner(value, bottomContent) {
	    value = this.getSpinningValue(value);
	    // If the question will spin, cut off the prefix (for layout purposes)
	    const content = bottomContent ? this.getQuestion() + value : this.getQuestion().slice(this.opt.prefix.length + 1) + value;
	    this.screen.renderWithSpinner(content, bottomContent);
	  }

	  /**
	   * Allow override, e.g. for password prompts
	   * See: https://github.com/SBoudrias/Inquirer.js/issues/1022
	   *
	   * @return {String} value to display while spinning
	   */
	  getSpinningValue(value) {
	    return value;
	  }

	  /**
	   * Generate the prompt question string
	   * @return {String} prompt question string
	   */
	  getQuestion() {
	    let message = (this.opt.prefix ? this.opt.prefix + ' ' : '') + chalk$3.bold(this.opt.message) + this.opt.suffix + chalk$3.reset(' ');

	    // Append the default if available, and if question isn't touched/answered
	    if (this.opt.default != null && this.status !== 'touched' && this.status !== 'answered') {
	      // If default password is supplied, hide it
	      message += this.opt.type === 'password' ? chalk$3.italic.dim('[hidden] ') : chalk$3.dim('(' + this.opt.default + ') ');
	    }
	    return message;
	  }
	}

	/**
	 * `list` type prompt
	 */

	class ListPrompt extends Prompt {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);
	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }
	    this.firstRender = true;
	    this.selected = 0;
	    const def = this.opt.default;

	    // If def is a Number, then use as index. Otherwise, check for value.
	    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
	      this.selected = def;
	    } else if (typeof def !== 'number' && def != null) {
	      const index = this.opt.choices.realChoices.findIndex(({
	        value
	      }) => value === def);
	      this.selected = Math.max(index, 0);
	    }

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;
	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(this.screen, {
	      isInfinite: shouldLoop
	    });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;
	    const events = observe(this.rl);
	    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey.pipe(takeUntil(events.line)).forEach(this.onDownKey.bind(this));
	    events.numberKey.pipe(takeUntil(events.line)).forEach(this.onNumberKey.bind(this));
	    events.line.pipe(take(1), map$2(this.getCurrentValue.bind(this)), flatMap(value => runAsync$1(this.opt.filter)(value, this.answers).catch(error => error))).forEach(this.onSubmit.bind(this));

	    // Init the prompt
	    cliCursor$1.hide();
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ListPrompt} self
	   */

	  render() {
	    // Render question
	    let message = this.getQuestion();
	    if (this.firstRender) {
	      message += chalk$3.dim('(Use arrow keys)');
	    }

	    // Render choices or answer depending on the state
	    if (this.status === 'answered') {
	      message += chalk$3.cyan(this.opt.choices.getChoice(this.selected).short);
	    } else {
	      const choicesStr = listRender(this.opt.choices, this.selected);
	      const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.selected));
	      const realIndexPosition = this.opt.choices.reduce((acc, value, i) => {
	        // Dont count lines past the choice we are looking at
	        if (i > indexPosition) {
	          return acc;
	        }
	        // Add line if it's a separator
	        if (value.type === 'separator') {
	          return acc + 1;
	        }
	        let l = value.name;
	        // Non-strings take up one line
	        if (typeof l !== 'string') {
	          return acc + 1;
	        }

	        // Calculate lines taken up by string
	        l = l.split('\n');
	        return acc + l.length;
	      }, 0) - 1;
	      message += '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
	    }
	    this.firstRender = false;
	    this.screen.render(message);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onSubmit(value) {
	    this.status = 'answered';

	    // Rerender prompt
	    this.render();
	    this.screen.done();
	    cliCursor$1.show();
	    this.done(value);
	  }
	  getCurrentValue() {
	    return this.opt.choices.getChoice(this.selected).value;
	  }

	  /**
	   * When user press a key
	   */
	  onUpKey() {
	    this.selected = incrementListIndex(this.selected, 'up', this.opt);
	    this.render();
	  }
	  onDownKey() {
	    this.selected = incrementListIndex(this.selected, 'down', this.opt);
	    this.render();
	  }
	  onNumberKey(input) {
	    if (input <= this.opt.choices.realLength) {
	      this.selected = input - 1;
	    }
	    this.render();
	  }
	}

	/**
	 * Function for rendering list choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */
	function listRender(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;
	  choices.forEach((choice, i) => {
	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += '  ' + choice + '\n';
	      return;
	    }
	    if (choice.disabled) {
	      separatorOffset++;
	      output += '  - ' + choice.name;
	      output += ` (${typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'})`;
	      output += '\n';
	      return;
	    }
	    const isSelected = i - separatorOffset === pointer;
	    let line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
	    if (isSelected) {
	      line = chalk$3.cyan(line);
	    }
	    output += line + ' \n';
	  });
	  return output.replaceAll(/\n$/g, '');
	}

	/**
	 * `input` type prompt
	 */

	class InputPrompt extends Prompt {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    const submit = events.line.pipe(map$2(this.filterInput.bind(this)));
	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

	    // Init
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {InputPrompt} self
	   */

	  render(error) {
	    let bottomContent = '';
	    let appendContent = '';
	    let message = this.getQuestion();
	    const {
	      transformer
	    } = this.opt;
	    const isFinal = this.status === 'answered';
	    appendContent = isFinal ? this.answer : this.rl.line;
	    if (transformer) {
	      message += transformer(appendContent, this.answers, {
	        isFinal
	      });
	    } else {
	      message += isFinal ? chalk$3.cyan(appendContent) : appendContent;
	    }
	    if (error) {
	      bottomContent = chalk$3.red('>> ') + error;
	    }
	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  filterInput(input) {
	    if (!input) {
	      return this.opt.default == null ? '' : this.opt.default;
	    }
	    return input;
	  }
	  onEnd(state) {
	    this.answer = state.value;
	    this.status = 'answered';

	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(state.value);
	  }
	  onError({
	    value = '',
	    isValid
	  }) {
	    this.rl.line += value;
	    this.rl.cursor += value.length;
	    this.render(isValid);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.status = 'touched';
	    this.render();
	  }
	}

	/**
	 * `input` type prompt
	 */


	/**
	 * Extention of the Input prompt specifically for use with number inputs.
	 */

	class NumberPrompt extends InputPrompt {
	  filterInput(input) {
	    if (input && typeof input === 'string') {
	      input = input.trim();
	      // Match a number in the input
	      const numberMatch = input.match(/(^-?\d+|^-?\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
	      // If a number is found, return that input.
	      if (numberMatch) {
	        return Number(numberMatch[0]);
	      }
	    }

	    // If the input was invalid return the default value.
	    return this.opt.default == null ? Number.NaN : this.opt.default;
	  }
	}

	/**
	 * `confirm` type prompt
	 */

	class ConfirmPrompt extends Prompt {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);
	    let rawDefault = true;
	    Object.assign(this.opt, {
	      filter(input) {
	        if (input != null && input !== '') {
	          if (/^y(es)?/i.test(input)) return true;
	          if (/^n(o)?/i.test(input)) return false;
	        }
	        return rawDefault;
	      }
	    });
	    if (this.opt.default != null) {
	      rawDefault = Boolean(this.opt.default);
	    }
	    this.opt.default = rawDefault ? 'Y/n' : 'y/N';
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb   Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    events.keypress.pipe(takeUntil(events.line)).forEach(this.onKeypress.bind(this));
	    events.line.pipe(take(1)).forEach(this.onEnd.bind(this));

	    // Init
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ConfirmPrompt} self
	   */

	  render(answer) {
	    let message = this.getQuestion();
	    if (typeof answer === 'boolean') {
	      message += chalk$3.cyan(answer ? 'Yes' : 'No');
	    } else if (answer) {
	      message += answer;
	    } else {
	      message += this.rl.line;
	    }
	    this.screen.render(message);
	    return this;
	  }

	  /**
	   * When user press `enter` key
	   */

	  onEnd(input) {
	    this.status = 'answered';
	    let output = this.opt.filter(input);
	    if (this.opt.transformer) {
	      output = this.opt.transformer(output);
	    }
	    this.render(output);
	    this.screen.done();
	    this.done(output);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.render();
	  }
	}

	/**
	 * `rawlist` type prompt
	 */

	class RawListPrompt extends Prompt {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);
	    this.hiddenLine = '';
	    this.lastKey = '';
	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }
	    this.opt.validChoices = this.opt.choices.filter(Separator.exclude);
	    this.selected = 0;
	    this.rawDefault = 0;
	    Object.assign(this.opt, {
	      validate(val) {
	        return val != null;
	      }
	    });
	    const def = this.opt.default;
	    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
	      this.selected = def;
	      this.rawDefault = def;
	    } else if (typeof def !== 'number' && def != null) {
	      const index = this.opt.choices.realChoices.findIndex(({
	        value
	      }) => value === def);
	      const safeIndex = Math.max(index, 0);
	      this.selected = safeIndex;
	      this.rawDefault = safeIndex;
	    }

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;
	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(undefined, {
	      isInfinite: shouldLoop
	    });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    const submit = events.line.pipe(map$2(this.getCurrentValue.bind(this)));
	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    events.normalizedUpKey.pipe(takeUntil(validation.success)).forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey.pipe(takeUntil(validation.success)).forEach(this.onDownKey.bind(this));
	    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));
	    // Init the prompt
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {RawListPrompt} self
	   */

	  render(error) {
	    // Render question
	    let message = this.getQuestion();
	    let bottomContent = '';
	    if (this.status === 'answered') {
	      message += chalk$3.cyan(this.opt.choices.getChoice(this.selected).short);
	    } else {
	      const choicesStr = renderChoices$2(this.opt.choices, this.selected);
	      message += '\n' + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize);
	      message += '\n  Answer: ';
	    }
	    message += this.rl.line;
	    if (error) {
	      bottomContent = '\n' + chalk$3.red('>> ') + error;
	    }
	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  getCurrentValue(index) {
	    if (index == null) {
	      index = this.rawDefault;
	    } else if (index === '') {
	      this.selected = this.selected === undefined ? -1 : this.selected;
	      index = this.selected;
	    } else {
	      index -= 1;
	    }
	    const choice = this.opt.choices.getChoice(index);
	    return choice ? choice.value : null;
	  }
	  onEnd(state) {
	    this.status = 'answered';
	    this.answer = state.value;

	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(state.value);
	  }
	  onError() {
	    this.render('Please enter a valid index');
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    let index;
	    if (this.lastKey === 'arrow') {
	      index = this.hiddenLine.length > 0 ? Number(this.hiddenLine) - 1 : 0;
	    } else {
	      index = this.rl.line.length > 0 ? Number(this.rl.line) - 1 : 0;
	    }
	    this.lastKey = '';
	    this.selected = this.opt.choices.getChoice(index) ? index : undefined;
	    this.render();
	  }

	  /**
	   * When user press up key
	   */

	  onUpKey() {
	    this.onArrowKey('up');
	  }

	  /**
	   * When user press down key
	   */

	  onDownKey() {
	    this.onArrowKey('down');
	  }

	  /**
	   * When user press up or down key
	   * @param {String} type Arrow type: up or down
	   */

	  onArrowKey(type) {
	    this.selected = incrementListIndex(this.selected, type, this.opt) || 0;
	    this.hiddenLine = String(this.selected + 1);
	    this.rl.line = '';
	    this.lastKey = 'arrow';
	  }
	}

	/**
	 * Function for rendering list choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */

	function renderChoices$2(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;
	  choices.forEach((choice, i) => {
	    output += output ? '\n  ' : '  ';
	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += ' ' + choice;
	      return;
	    }
	    const index = i - separatorOffset;
	    let display = index + 1 + ') ' + choice.name;
	    if (index === pointer) {
	      display = chalk$3.cyan(display);
	    }
	    output += display;
	  });
	  return output;
	}

	/**
	 * `rawlist` type prompt
	 */

	class ExpandPrompt extends Prompt {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);
	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }
	    this.validateChoices(this.opt.choices);

	    // Add the default `help` (/expand) option
	    this.opt.choices.push({
	      key: 'h',
	      name: 'Help, list all options',
	      value: 'help'
	    });
	    this.opt.validate = choice => {
	      if (choice == null) {
	        return 'Please enter a valid command';
	      }
	      return choice !== 'help';
	    };

	    // Setup the default string (capitalize the default key)
	    this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);
	    this.paginator = new Paginator(this.screen);
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Save user answer and update prompt to show selected option.
	    const events = observe(this.rl);
	    const validation = this.handleSubmitEvents(events.line.pipe(map$2(this.getCurrentValue.bind(this))));
	    validation.success.forEach(this.onSubmit.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    this.keypressObs = events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

	    // Init the prompt
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ExpandPrompt} self
	   */

	  render(error, hint) {
	    let message = this.getQuestion();
	    let bottomContent = '';
	    if (this.status === 'answered') {
	      message += chalk$3.cyan(this.answer);
	    } else if (this.status === 'expanded') {
	      const choicesStr = renderChoices$1(this.opt.choices, this.selectedKey);
	      message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);
	      message += '\n  Answer: ';
	    }
	    message += this.rl.line;
	    if (error) {
	      bottomContent = chalk$3.red('>> ') + error;
	    }
	    if (hint) {
	      bottomContent = chalk$3.cyan('>> ') + hint;
	    }
	    this.screen.render(message, bottomContent);
	  }
	  getCurrentValue(input) {
	    input ||= this.rawDefault;
	    const selected = this.opt.choices.where({
	      key: input.toLowerCase().trim()
	    })[0];
	    if (!selected) {
	      return null;
	    }
	    return selected.value;
	  }

	  /**
	   * Generate the prompt choices string
	   * @return {String}  Choices string
	   */

	  getChoices() {
	    let output = '';
	    this.opt.choices.forEach(choice => {
	      output += '\n  ';
	      if (choice.type === 'separator') {
	        output += ' ' + choice;
	        return;
	      }
	      let choiceStr = choice.key + ') ' + choice.name;
	      if (this.selectedKey === choice.key) {
	        choiceStr = chalk$3.cyan(choiceStr);
	      }
	      output += choiceStr;
	    });
	    return output;
	  }
	  onError(state) {
	    if (state.value === 'help') {
	      this.selectedKey = '';
	      this.status = 'expanded';
	      this.render();
	      return;
	    }
	    this.render(state.isValid);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onSubmit(state) {
	    this.status = 'answered';
	    const choice = this.opt.choices.where({
	      value: state.value
	    })[0];
	    this.answer = choice.short || choice.name;

	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(state.value);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.selectedKey = this.rl.line.toLowerCase();
	    const selected = this.opt.choices.where({
	      key: this.selectedKey
	    })[0];
	    if (this.status === 'expanded') {
	      this.render();
	    } else {
	      this.render(null, selected ? selected.name : null);
	    }
	  }

	  /**
	   * Validate the choices
	   * @param {Array} choices
	   */

	  validateChoices(choices) {
	    let formatError;
	    const errors = [];
	    const keymap = {};
	    choices.filter(Separator.exclude).forEach(choice => {
	      if (!choice.key || choice.key.length !== 1) {
	        formatError = true;
	      }
	      choice.key = String(choice.key).toLowerCase();
	      if (keymap[choice.key]) {
	        errors.push(choice.key);
	      }
	      keymap[choice.key] = true;
	    });
	    if (formatError) {
	      throw new Error('Format error: `key` param must be a single letter and is required.');
	    }
	    if (keymap.h) {
	      throw new Error('Reserved key error: `key` param cannot be `h` - this value is reserved.');
	    }
	    if (errors.length > 0) {
	      throw new Error('Duplicate key error: `key` param must be unique. Duplicates: ' + [...new Set(errors)].join(','));
	    }
	  }

	  /**
	   * Generate a string out of the choices keys
	   * @param  {Array}  choices
	   * @param  {Number|String} default - the choice index or name to capitalize
	   * @return {String} The rendered choices key string
	   */
	  generateChoicesString(choices, defaultChoice) {
	    let defIndex = choices.realLength - 1;
	    if (typeof defaultChoice === 'number' && this.opt.choices.getChoice(defaultChoice)) {
	      defIndex = defaultChoice;
	    } else if (typeof defaultChoice === 'string') {
	      const index = choices.realChoices.findIndex(({
	        value
	      }) => value === defaultChoice);
	      defIndex = index === -1 ? defIndex : index;
	    }
	    const defStr = this.opt.choices.pluck('key');
	    this.rawDefault = defStr[defIndex];
	    defStr[defIndex] = String(defStr[defIndex]).toUpperCase();
	    return defStr.join('');
	  }
	}

	/**
	 * Function for rendering checkbox choices
	 * @param  {String} pointer Selected key
	 * @return {String}         Rendered content
	 */

	function renderChoices$1(choices, pointer) {
	  let output = '';
	  choices.forEach(choice => {
	    output += '\n  ';
	    if (choice.type === 'separator') {
	      output += ' ' + choice;
	      return;
	    }
	    let choiceStr = choice.key + ') ' + choice.name;
	    if (pointer === choice.key) {
	      choiceStr = chalk$3.cyan(choiceStr);
	    }
	    output += choiceStr;
	  });
	  return output;
	}

	/**
	 * `list` type prompt
	 */

	class CheckboxPrompt extends Prompt {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);
	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }
	    if (Array.isArray(this.opt.default)) {
	      for (const choice of this.opt.choices) {
	        if (this.opt.default.includes(choice.value)) {
	          choice.checked = true;
	        }
	      }
	    }
	    this.pointer = 0;

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;
	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(this.screen, {
	      isInfinite: shouldLoop
	    });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;
	    const events = observe(this.rl);
	    const validation = this.handleSubmitEvents(events.line.pipe(map$2(this.getCurrentValue.bind(this))));
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    events.normalizedUpKey.pipe(takeUntil(validation.success)).forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey.pipe(takeUntil(validation.success)).forEach(this.onDownKey.bind(this));
	    events.numberKey.pipe(takeUntil(validation.success)).forEach(this.onNumberKey.bind(this));
	    events.spaceKey.pipe(takeUntil(validation.success)).forEach(this.onSpaceKey.bind(this));
	    events.aKey.pipe(takeUntil(validation.success)).forEach(this.onAllKey.bind(this));
	    events.iKey.pipe(takeUntil(validation.success)).forEach(this.onInverseKey.bind(this));

	    // Init the prompt
	    cliCursor$1.hide();
	    this.render();
	    this.firstRender = false;
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {CheckboxPrompt} self
	   */

	  render(error) {
	    // Render question
	    let message = this.getQuestion();
	    let bottomContent = '';
	    if (!this.dontShowHints) {
	      message += '(Press ' + chalk$3.cyan.bold('<space>') + ' to select, ' + chalk$3.cyan.bold('<a>') + ' to toggle all, ' + chalk$3.cyan.bold('<i>') + ' to invert selection, and ' + chalk$3.cyan.bold('<enter>') + ' to proceed)';
	    }

	    // Render choices or answer depending on the state
	    if (this.status === 'answered') {
	      message += chalk$3.cyan(this.selection.join(', '));
	    } else {
	      const choicesStr = renderChoices(this.opt.choices, this.pointer);
	      const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.pointer));
	      const realIndexPosition = this.opt.choices.reduce((acc, value, i) => {
	        // Dont count lines past the choice we are looking at
	        if (i > indexPosition) {
	          return acc;
	        }
	        // Add line if it's a separator
	        if (value.type === 'separator') {
	          return acc + 1;
	        }
	        let l = value.name;
	        // Non-strings take up one line
	        if (typeof l !== 'string') {
	          return acc + 1;
	        }

	        // Calculate lines taken up by string
	        l = l.split('\n');
	        return acc + l.length;
	      }, 0) - 1;
	      message += '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
	    }
	    if (error) {
	      bottomContent = chalk$3.red('>> ') + error;
	    }
	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onEnd(state) {
	    this.status = 'answered';
	    this.dontShowHints = true;
	    // Rerender prompt (and clean subline error)
	    this.render();
	    this.screen.done();
	    cliCursor$1.show();
	    this.done(state.value);
	  }
	  onError(state) {
	    this.render(state.isValid);
	  }
	  getCurrentValue() {
	    const choices = this.opt.choices.filter(choice => Boolean(choice.checked) && !choice.disabled);
	    this.selection = choices.map(choice => choice.short);
	    return choices.map(choice => choice.value);
	  }
	  onUpKey() {
	    this.pointer = incrementListIndex(this.pointer, 'up', this.opt);
	    this.render();
	  }
	  onDownKey() {
	    this.pointer = incrementListIndex(this.pointer, 'down', this.opt);
	    this.render();
	  }
	  onNumberKey(input) {
	    if (input <= this.opt.choices.realLength) {
	      this.pointer = input - 1;
	      this.toggleChoice(this.pointer);
	    }
	    this.render();
	  }
	  onSpaceKey() {
	    this.toggleChoice(this.pointer);
	    this.render();
	  }
	  onAllKey() {
	    const shouldBeChecked = this.opt.choices.some(choice => choice.type !== 'separator' && !choice.checked);
	    this.opt.choices.forEach(choice => {
	      if (choice.type !== 'separator') {
	        choice.checked = shouldBeChecked;
	      }
	    });
	    this.render();
	  }
	  onInverseKey() {
	    this.opt.choices.forEach(choice => {
	      if (choice.type !== 'separator') {
	        choice.checked = !choice.checked;
	      }
	    });
	    this.render();
	  }
	  toggleChoice(index) {
	    const item = this.opt.choices.getChoice(index);
	    if (item !== undefined) {
	      this.opt.choices.getChoice(index).checked = !item.checked;
	    }
	  }
	}

	/**
	 * Function for rendering checkbox choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */

	function renderChoices(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;
	  choices.forEach((choice, i) => {
	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += ' ' + choice + '\n';
	      return;
	    }
	    if (choice.disabled) {
	      separatorOffset++;
	      output += ' - ' + choice.name;
	      output += ` (${typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'})`;
	    } else {
	      const line = getCheckbox(choice.checked) + ' ' + choice.name;
	      output += i - separatorOffset === pointer ? chalk$3.cyan(figures.pointer + line) : ' ' + line;
	    }
	    output += '\n';
	  });
	  return output.replaceAll(/\n$/g, '');
	}

	/**
	 * Get the checkbox
	 * @param  {Boolean} checked - add a X or not to the checkbox
	 * @return {String} Composited checkbox string
	 */

	function getCheckbox(checked) {
	  return checked ? chalk$3.green(figures.radioOn) : figures.radioOff;
	}

	/**
	 * `password` type prompt
	 */

	function mask(input, maskChar) {
	  input = String(input);
	  maskChar = typeof maskChar === 'string' ? maskChar : '*';
	  if (input.length === 0) {
	    return '';
	  }
	  return Array.from({
	    length: input.length + 1
	  }).join(maskChar);
	}
	class PasswordPrompt extends Prompt {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;
	    const events = observe(this.rl);

	    // Once user confirm (enter key)
	    const submit = events.line.pipe(map$2(this.filterInput.bind(this)));
	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

	    // Init
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {PasswordPrompt} self
	   */

	  render(error) {
	    let message = this.getQuestion();
	    let bottomContent = '';
	    message += this.status === 'answered' ? this.getMaskedValue(this.answer) : this.getMaskedValue(this.rl.line || '');
	    if (error) {
	      bottomContent = '\n' + chalk$3.red('>> ') + error;
	    }
	    this.screen.render(message, bottomContent);
	  }
	  getMaskedValue(value) {
	    if (this.status === 'answered') {
	      return this.opt.mask ? chalk$3.cyan(mask(value, this.opt.mask)) : chalk$3.italic.dim('[hidden]');
	    }
	    return this.opt.mask ? mask(value, this.opt.mask) : chalk$3.italic.dim('[input is hidden] ');
	  }

	  /**
	   * Mask value during async filter/validation.
	   */
	  getSpinningValue(value) {
	    return this.getMaskedValue(value);
	  }

	  /**
	   * When user press `enter` key
	   */

	  filterInput(input) {
	    if (!input) {
	      return this.opt.default == null ? '' : this.opt.default;
	    }
	    return input;
	  }
	  onEnd(state) {
	    this.status = 'answered';
	    this.answer = state.value;

	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(state.value);
	  }
	  onError(state) {
	    this.render(state.isValid);
	  }
	  onKeypress() {
	    // If user press a key, just clear the default value
	    this.opt.default &&= undefined;
	    this.render();
	  }
	}

	var main = {};

	var chardet = {};

	var match = function (det, rec, confidence, name, lang) {
	  this.confidence = confidence;
	  this.name = name || rec.name(det);
	  this.lang = lang;
	};

	var Match = match;

	/**
	 * Charset recognizer for UTF-8
	 */
	var utf8$1 = function () {
	  this.name = function () {
	    return 'UTF-8';
	  };
	  this.match = function (det) {
	    var hasBOM = false,
	      numValid = 0,
	      numInvalid = 0,
	      input = det.fRawInput,
	      trailBytes = 0,
	      confidence;
	    if (det.fRawLength >= 3 && (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {
	      hasBOM = true;
	    }

	    // Scan for multi-byte sequences
	    for (var i = 0; i < det.fRawLength; i++) {
	      var b = input[i];
	      if ((b & 0x80) == 0) continue; // ASCII

	      // Hi bit on char found.  Figure out how long the sequence should be
	      if ((b & 0x0e0) == 0x0c0) {
	        trailBytes = 1;
	      } else if ((b & 0x0f0) == 0x0e0) {
	        trailBytes = 2;
	      } else if ((b & 0x0f8) == 0xf0) {
	        trailBytes = 3;
	      } else {
	        numInvalid++;
	        if (numInvalid > 5) break;
	        trailBytes = 0;
	      }

	      // Verify that we've got the right number of trail bytes in the sequence
	      for (;;) {
	        i++;
	        if (i >= det.fRawLength) break;
	        if ((input[i] & 0xc0) != 0x080) {
	          numInvalid++;
	          break;
	        }
	        if (--trailBytes == 0) {
	          numValid++;
	          break;
	        }
	      }
	    }

	    // Cook up some sort of confidence score, based on presense of a BOM
	    //    and the existence of valid and/or invalid multi-byte sequences.
	    confidence = 0;
	    if (hasBOM && numInvalid == 0) confidence = 100;else if (hasBOM && numValid > numInvalid * 10) confidence = 80;else if (numValid > 3 && numInvalid == 0) confidence = 100;else if (numValid > 0 && numInvalid == 0) confidence = 80;else if (numValid == 0 && numInvalid == 0)
	      // Plain ASCII.
	      confidence = 10;else if (numValid > numInvalid * 10)
	      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.
	      confidence = 25;else return null;
	    return new Match(det, this, confidence);
	  };
	};

	var unicode$1 = {exports: {}};

	(function (module) {

	  var util = require$$0$4,
	    Match = match;

	  /**
	   * This class matches UTF-16 and UTF-32, both big- and little-endian. The
	   * BOM will be used if it is present.
	   */
	  module.exports.UTF_16BE = function () {
	    this.name = function () {
	      return 'UTF-16BE';
	    };
	    this.match = function (det) {
	      var input = det.fRawInput;
	      if (input.length >= 2 && (input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff) {
	        return new Match(det, this, 100); // confidence = 100
	      }

	      // TODO: Do some statistics to check for unsigned UTF-16BE
	      return null;
	    };
	  };
	  module.exports.UTF_16LE = function () {
	    this.name = function () {
	      return 'UTF-16LE';
	    };
	    this.match = function (det) {
	      var input = det.fRawInput;
	      if (input.length >= 2 && (input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe) {
	        // LE BOM is present.
	        if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
	          // It is probably UTF-32 LE, not UTF-16
	          return null;
	        }
	        return new Match(det, this, 100); // confidence = 100
	      }

	      // TODO: Do some statistics to check for unsigned UTF-16LE
	      return null;
	    };
	  };
	  function UTF_32() {}
	  UTF_32.prototype.match = function (det) {
	    var input = det.fRawInput,
	      limit = det.fRawLength / 4 * 4,
	      numValid = 0,
	      numInvalid = 0,
	      hasBOM = false,
	      confidence = 0;
	    if (limit == 0) {
	      return null;
	    }
	    if (this.getChar(input, 0) == 0x0000FEFF) {
	      hasBOM = true;
	    }
	    for (var i = 0; i < limit; i += 4) {
	      var ch = this.getChar(input, i);
	      if (ch < 0 || ch >= 0x10FFFF || ch >= 0xD800 && ch <= 0xDFFF) {
	        numInvalid += 1;
	      } else {
	        numValid += 1;
	      }
	    }

	    // Cook up some sort of confidence score, based on presence of a BOM
	    //    and the existence of valid and/or invalid multi-byte sequences.
	    if (hasBOM && numInvalid == 0) {
	      confidence = 100;
	    } else if (hasBOM && numValid > numInvalid * 10) {
	      confidence = 80;
	    } else if (numValid > 3 && numInvalid == 0) {
	      confidence = 100;
	    } else if (numValid > 0 && numInvalid == 0) {
	      confidence = 80;
	    } else if (numValid > numInvalid * 10) {
	      // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
	      confidence = 25;
	    }

	    // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
	    return confidence == 0 ? null : new Match(det, this, confidence);
	  };
	  module.exports.UTF_32BE = function () {
	    this.name = function () {
	      return 'UTF-32BE';
	    };
	    this.getChar = function (input, index) {
	      return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 | (input[index + 2] & 0xff) << 8 | input[index + 3] & 0xff;
	    };
	  };
	  util.inherits(module.exports.UTF_32BE, UTF_32);
	  module.exports.UTF_32LE = function () {
	    this.name = function () {
	      return 'UTF-32LE';
	    };
	    this.getChar = function (input, index) {
	      return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 | (input[index + 1] & 0xff) << 8 | input[index + 0] & 0xff;
	    };
	  };
	  util.inherits(module.exports.UTF_32LE, UTF_32);
	})(unicode$1);
	var unicodeExports = unicode$1.exports;

	var mbcs$1 = {exports: {}};

	(function (module) {
	  var util = require$$0$4,
	    Match = match;

	  /**
	   * Binary search implementation (recursive)
	   */
	  function binarySearch(arr, searchValue) {
	    function find(arr, searchValue, left, right) {
	      if (right < left) return -1;

	      /*
	      int mid = mid = (left + right) / 2;
	      There is a bug in the above line;
	      Joshua Bloch suggests the following replacement:
	      */
	      var mid = Math.floor(left + right >>> 1);
	      if (searchValue > arr[mid]) return find(arr, searchValue, mid + 1, right);
	      if (searchValue < arr[mid]) return find(arr, searchValue, left, mid - 1);
	      return mid;
	    }
	    return find(arr, searchValue, 0, arr.length - 1);
	  }

	  // 'Character'  iterated character class.
	  //    Recognizers for specific mbcs encodings make their 'characters' available
	  //    by providing a nextChar() function that fills in an instance of iteratedChar
	  //    with the next char from the input.
	  //    The returned characters are not converted to Unicode, but remain as the raw
	  //    bytes (concatenated into an int) from the codepage data.
	  //
	  //  For Asian charsets, use the raw input rather than the input that has been
	  //   stripped of markup.  Detection only considers multi-byte chars, effectively
	  //   stripping markup anyway, and double byte chars do occur in markup too.
	  //
	  function IteratedChar() {
	    this.charValue = 0; // 1-4 bytes from the raw input data
	    this.index = 0;
	    this.nextIndex = 0;
	    this.error = false;
	    this.done = false;
	    this.reset = function () {
	      this.charValue = 0;
	      this.index = -1;
	      this.nextIndex = 0;
	      this.error = false;
	      this.done = false;
	    };
	    this.nextByte = function (det) {
	      if (this.nextIndex >= det.fRawLength) {
	        this.done = true;
	        return -1;
	      }
	      var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;
	      return byteValue;
	    };
	  }

	  /**
	   * Asian double or multi-byte - charsets.
	   * Match is determined mostly by the input data adhering to the
	   * encoding scheme for the charset, and, optionally,
	   * frequency-of-occurence of characters.
	   */

	  function mbcs() {}

	  /**
	   * Test the match of this charset with the input text data
	   *      which is obtained via the CharsetDetector object.
	   *
	   * @param det  The CharsetDetector, which contains the input text
	   *             to be checked for being in this charset.
	   * @return     Two values packed into one int  (Damn java, anyhow)
	   *             bits 0-7:  the match confidence, ranging from 0-100
	   *             bits 8-15: The match reason, an enum-like value.
	   */
	  mbcs.prototype.match = function (det) {
	    var //TODO Do we really need this?
	      doubleByteCharCount = 0,
	      commonCharCount = 0,
	      badCharCount = 0,
	      totalCharCount = 0,
	      confidence = 0;
	    var iter = new IteratedChar();
	    detectBlock: {
	      for (iter.reset(); this.nextChar(iter, det);) {
	        totalCharCount++;
	        if (iter.error) {
	          badCharCount++;
	        } else {
	          var cv = iter.charValue & 0xFFFFFFFF;
	          if (cv <= 0xff) ; else {
	            doubleByteCharCount++;
	            if (this.commonChars != null) {
	              // NOTE: This assumes that there are no 4-byte common chars.
	              if (binarySearch(this.commonChars, cv) >= 0) {
	                commonCharCount++;
	              }
	            }
	          }
	        }
	        if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
	          // console.log('its here!')
	          // Bail out early if the byte data is not matching the encoding scheme.
	          break detectBlock;
	        }
	      }
	      if (doubleByteCharCount <= 10 && badCharCount == 0) {
	        // Not many multi-byte chars.
	        if (doubleByteCharCount == 0 && totalCharCount < 10) {
	          // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.
	          // We don't have enough data to have any confidence.
	          // Statistical analysis of single byte non-ASCII charcters would probably help here.
	          confidence = 0;
	        } else {
	          //   ASCII or ISO file?  It's probably not our encoding,
	          //   but is not incompatible with our encoding, so don't give it a zero.
	          confidence = 10;
	        }
	        break detectBlock;
	      }

	      //
	      //  No match if there are too many characters that don't fit the encoding scheme.
	      //    (should we have zero tolerance for these?)
	      //
	      if (doubleByteCharCount < 20 * badCharCount) {
	        confidence = 0;
	        break detectBlock;
	      }
	      if (this.commonChars == null) {
	        // We have no statistics on frequently occuring characters.
	        //  Assess confidence purely on having a reasonable number of
	        //  multi-byte characters (the more the better
	        confidence = 30 + doubleByteCharCount - 20 * badCharCount;
	        if (confidence > 100) {
	          confidence = 100;
	        }
	      } else {
	        //
	        // Frequency of occurence statistics exist.
	        //
	        var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);
	        var scaleFactor = 90.0 / maxVal;
	        confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
	        confidence = Math.min(confidence, 100);
	      }
	    } // end of detectBlock:

	    return confidence == 0 ? null : new Match(det, this, confidence);
	  };

	  /**
	   * Get the next character (however many bytes it is) from the input data
	   *    Subclasses for specific charset encodings must implement this function
	   *    to get characters according to the rules of their encoding scheme.
	   *
	   *  This function is not a method of class iteratedChar only because
	   *   that would require a lot of extra derived classes, which is awkward.
	   * @param it  The iteratedChar 'struct' into which the returned char is placed.
	   * @param det The charset detector, which is needed to get at the input byte data
	   *            being iterated over.
	   * @return    True if a character was returned, false at end of input.
	   */

	  mbcs.prototype.nextChar = function (iter, det) {};

	  /**
	   * Shift-JIS charset recognizer.
	   */
	  module.exports.sjis = function () {
	    this.name = function () {
	      return 'Shift-JIS';
	    };
	    this.language = function () {
	      return 'ja';
	    };

	    // TODO:  This set of data comes from the character frequency-
	    //        of-occurence analysis tool.  The data needs to be moved
	    //        into a resource and loaded from there.
	    this.commonChars = [0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0, 0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc, 0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341, 0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa];
	    this.nextChar = function (iter, det) {
	      iter.index = iter.nextIndex;
	      iter.error = false;
	      var firstByte;
	      firstByte = iter.charValue = iter.nextByte(det);
	      if (firstByte < 0) return false;
	      if (firstByte <= 0x7f || firstByte > 0xa0 && firstByte <= 0xdf) return true;
	      var secondByte = iter.nextByte(det);
	      if (secondByte < 0) return false;
	      iter.charValue = firstByte << 8 | secondByte;
	      if (!(secondByte >= 0x40 && secondByte <= 0x7f || secondByte >= 0x80 && secondByte <= 0xff)) {
	        // Illegal second byte value.
	        iter.error = true;
	      }
	      return true;
	    };
	  };
	  util.inherits(module.exports.sjis, mbcs);

	  /**
	   *   Big5 charset recognizer.
	   */
	  module.exports.big5 = function () {
	    this.name = function () {
	      return 'Big5';
	    };
	    this.language = function () {
	      return 'zh';
	    };
	    // TODO:  This set of data comes from the character frequency-
	    //        of-occurence analysis tool.  The data needs to be moved
	    //        into a resource and loaded from there.
	    this.commonChars = [0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446, 0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3, 0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548, 0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8, 0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59, 0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44, 0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f];
	    this.nextChar = function (iter, det) {
	      iter.index = iter.nextIndex;
	      iter.error = false;
	      var firstByte = iter.charValue = iter.nextByte(det);
	      if (firstByte < 0) return false;

	      // single byte character.
	      if (firstByte <= 0x7f || firstByte == 0xff) return true;
	      var secondByte = iter.nextByte(det);
	      if (secondByte < 0) return false;
	      iter.charValue = iter.charValue << 8 | secondByte;
	      if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff) iter.error = true;
	      return true;
	    };
	  };
	  util.inherits(module.exports.big5, mbcs);

	  /**
	   *  EUC charset recognizers.  One abstract class that provides the common function
	   *  for getting the next character according to the EUC encoding scheme,
	   *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.
	   *
	   *  Get the next character value for EUC based encodings.
	   *  Character 'value' is simply the raw bytes that make up the character
	   *     packed into an int.
	   */
	  function eucNextChar(iter, det) {
	    iter.index = iter.nextIndex;
	    iter.error = false;
	    var firstByte = 0;
	    var secondByte = 0;
	    var thirdByte = 0;
	    //int fourthByte = 0;
	    buildChar: {
	      firstByte = iter.charValue = iter.nextByte(det);
	      if (firstByte < 0) {
	        // Ran off the end of the input data
	        iter.done = true;
	        break buildChar;
	      }
	      if (firstByte <= 0x8d) {
	        // single byte char
	        break buildChar;
	      }
	      secondByte = iter.nextByte(det);
	      iter.charValue = iter.charValue << 8 | secondByte;
	      if (firstByte >= 0xA1 && firstByte <= 0xfe) {
	        // Two byte Char
	        if (secondByte < 0xa1) {
	          iter.error = true;
	        }
	        break buildChar;
	      }
	      if (firstByte == 0x8e) {
	        // Code Set 2.
	        //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.
	        //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
	        // We don't know which we've got.
	        // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
	        //   bytes will look like a well formed 2 byte char.
	        if (secondByte < 0xa1) {
	          iter.error = true;
	        }
	        break buildChar;
	      }
	      if (firstByte == 0x8f) {
	        // Code set 3.
	        // Three byte total char size, two bytes of actual char value.
	        thirdByte = iter.nextByte(det);
	        iter.charValue = iter.charValue << 8 | thirdByte;
	        if (thirdByte < 0xa1) {
	          iter.error = true;
	        }
	      }
	    }
	    return iter.done == false;
	  }

	  /**
	   * The charset recognize for EUC-JP.  A singleton instance of this class
	   *    is created and kept by the public CharsetDetector class
	   */
	  module.exports.euc_jp = function () {
	    this.name = function () {
	      return 'EUC-JP';
	    };
	    this.language = function () {
	      return 'ja';
	    };

	    // TODO:  This set of data comes from the character frequency-
	    //        of-occurence analysis tool.  The data needs to be moved
	    //        into a resource and loaded from there.
	    this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2, 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3, 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7, 0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee, 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1];
	    this.nextChar = eucNextChar;
	  };
	  util.inherits(module.exports.euc_jp, mbcs);

	  /**
	   * The charset recognize for EUC-KR.  A singleton instance of this class
	   *    is created and kept by the public CharsetDetector class
	   */
	  module.exports.euc_kr = function () {
	    this.name = function () {
	      return 'EUC-KR';
	    };
	    this.language = function () {
	      return 'ko';
	    };

	    // TODO:  This set of data comes from the character frequency-
	    //        of-occurence analysis tool.  The data needs to be moved
	    //        into a resource and loaded from there.
	    this.commonChars = [0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc, 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9, 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce, 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee, 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7, 0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6, 0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad];
	    this.nextChar = eucNextChar;
	  };
	  util.inherits(module.exports.euc_kr, mbcs);

	  /**
	   *   GB-18030 recognizer. Uses simplified Chinese statistics.
	   */
	  module.exports.gb_18030 = function () {
	    this.name = function () {
	      return 'GB18030';
	    };
	    this.language = function () {
	      return 'zh';
	    };

	    /*
	     *  Get the next character value for EUC based encodings.
	     *  Character 'value' is simply the raw bytes that make up the character
	     *     packed into an int.
	     */
	    this.nextChar = function (iter, det) {
	      iter.index = iter.nextIndex;
	      iter.error = false;
	      var firstByte = 0;
	      var secondByte = 0;
	      var thirdByte = 0;
	      var fourthByte = 0;
	      buildChar: {
	        firstByte = iter.charValue = iter.nextByte(det);
	        if (firstByte < 0) {
	          // Ran off the end of the input data
	          iter.done = true;
	          break buildChar;
	        }
	        if (firstByte <= 0x80) {
	          // single byte char
	          break buildChar;
	        }
	        secondByte = iter.nextByte(det);
	        iter.charValue = iter.charValue << 8 | secondByte;
	        if (firstByte >= 0x81 && firstByte <= 0xFE) {
	          // Two byte Char
	          if (secondByte >= 0x40 && secondByte <= 0x7E || secondByte >= 80 && secondByte <= 0xFE) {
	            break buildChar;
	          }
	          // Four byte char
	          if (secondByte >= 0x30 && secondByte <= 0x39) {
	            thirdByte = iter.nextByte(det);
	            if (thirdByte >= 0x81 && thirdByte <= 0xFE) {
	              fourthByte = iter.nextByte(det);
	              if (fourthByte >= 0x30 && fourthByte <= 0x39) {
	                iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;
	                break buildChar;
	              }
	            }
	          }
	          iter.error = true;
	          break buildChar;
	        }
	      }
	      return iter.done == false;
	    };

	    // TODO:  This set of data comes from the character frequency-
	    //        of-occurence analysis tool.  The data needs to be moved
	    //        into a resource and loaded from there.
	    this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac, 0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4, 0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4, 0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7, 0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2, 0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0];
	  };
	  util.inherits(module.exports.gb_18030, mbcs);
	})(mbcs$1);
	var mbcsExports = mbcs$1.exports;

	var sbcs$1 = {exports: {}};

	(function (module) {
	  var util = require$$0$4,
	    Match = match;

	  /**
	   * This class recognizes single-byte encodings. Because the encoding scheme is so
	   * simple, language statistics are used to do the matching.
	   */

	  function NGramParser(theNgramList, theByteMap) {
	    var N_GRAM_MASK = 0xFFFFFF;
	    this.byteIndex = 0;
	    this.ngram = 0;
	    this.ngramList = theNgramList;
	    this.byteMap = theByteMap;
	    this.ngramCount = 0;
	    this.hitCount = 0;
	    this.spaceChar;

	    /*
	     * Binary search for value in table, which must have exactly 64 entries.
	     */
	    this.search = function (table, value) {
	      var index = 0;
	      if (table[index + 32] <= value) index += 32;
	      if (table[index + 16] <= value) index += 16;
	      if (table[index + 8] <= value) index += 8;
	      if (table[index + 4] <= value) index += 4;
	      if (table[index + 2] <= value) index += 2;
	      if (table[index + 1] <= value) index += 1;
	      if (table[index] > value) index -= 1;
	      if (index < 0 || table[index] != value) return -1;
	      return index;
	    };
	    this.lookup = function (thisNgram) {
	      this.ngramCount += 1;
	      if (this.search(this.ngramList, thisNgram) >= 0) {
	        this.hitCount += 1;
	      }
	    };
	    this.addByte = function (b) {
	      this.ngram = (this.ngram << 8) + (b & 0xFF) & N_GRAM_MASK;
	      this.lookup(this.ngram);
	    };
	    this.nextByte = function (det) {
	      if (this.byteIndex >= det.fInputLen) return -1;
	      return det.fInputBytes[this.byteIndex++] & 0xFF;
	    };
	    this.parse = function (det, spaceCh) {
	      var b,
	        ignoreSpace = false;
	      this.spaceChar = spaceCh;
	      while ((b = this.nextByte(det)) >= 0) {
	        var mb = this.byteMap[b];

	        // TODO: 0x20 might not be a space in all character sets...
	        if (mb != 0) {
	          if (!(mb == this.spaceChar && ignoreSpace)) {
	            this.addByte(mb);
	          }
	          ignoreSpace = mb == this.spaceChar;
	        }
	      }

	      // TODO: Is this OK? The buffer could have ended in the middle of a word...
	      this.addByte(this.spaceChar);
	      var rawPercent = this.hitCount / this.ngramCount;

	      // TODO - This is a bit of a hack to take care of a case
	      // were we were getting a confidence of 135...
	      if (rawPercent > 0.33) return 98;
	      return Math.floor(rawPercent * 300.0);
	    };
	  }
	  function NGramsPlusLang(la, ng) {
	    this.fLang = la;
	    this.fNGrams = ng;
	  }
	  function sbcs() {}
	  sbcs.prototype.spaceChar = 0x20;
	  sbcs.prototype.ngrams = function () {};
	  sbcs.prototype.byteMap = function () {};
	  sbcs.prototype.match = function (det) {
	    var ngrams = this.ngrams();
	    var multiple = Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang;
	    if (!multiple) {
	      var parser = new NGramParser(ngrams, this.byteMap());
	      var confidence = parser.parse(det, this.spaceChar);
	      return confidence <= 0 ? null : new Match(det, this, confidence);
	    }
	    var bestConfidenceSoFar = -1;
	    var lang = null;
	    for (var i = ngrams.length - 1; i >= 0; i--) {
	      var ngl = ngrams[i];
	      var parser = new NGramParser(ngl.fNGrams, this.byteMap());
	      var confidence = parser.parse(det, this.spaceChar);
	      if (confidence > bestConfidenceSoFar) {
	        bestConfidenceSoFar = confidence;
	        lang = ngl.fLang;
	      }
	    }
	    var name = this.name(det);
	    return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
	  };
	  module.exports.ISO_8859_1 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF];
	    };
	    this.ngrams = function () {
	      return [new NGramsPlusLang('da', [0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320, 0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520, 0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065, 0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572]), new NGramsPlusLang('de', [0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765, 0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F, 0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E, 0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220, 0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65, 0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572]), new NGramsPlusLang('en', [0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E, 0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F, 0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74, 0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20, 0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420, 0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169, 0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320]), new NGramsPlusLang('es', [0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E, 0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369, 0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C, 0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320, 0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064, 0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20]), new NGramsPlusLang('fr', [0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61, 0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E, 0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20, 0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420, 0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420, 0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064, 0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220]), new NGramsPlusLang('it', [0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E, 0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073, 0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064, 0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220, 0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20, 0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20, 0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572, 0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F]), new NGramsPlusLang('nl', [0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765, 0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665, 0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E, 0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520, 0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F, 0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F]), new NGramsPlusLang('no', [0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469, 0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574, 0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474, 0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520, 0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465, 0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572]), new NGramsPlusLang('pt', [0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61, 0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20, 0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20, 0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065, 0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064, 0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F]), new NGramsPlusLang('sv', [0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E, 0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469, 0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474, 0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220, 0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564, 0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20, 0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073, 0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220])];
	    };
	    this.name = function (det) {
	      return det && det.fC1Bytes ? 'windows-1252' : 'ISO-8859-1';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_1, sbcs);
	  module.exports.ISO_8859_2 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20, 0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF, 0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7, 0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20];
	    };
	    this.ngrams = function () {
	      return [new NGramsPlusLang('cs', [0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64, 0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F, 0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073, 0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465, 0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E, 0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865, 0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20, 0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564]), new NGramsPlusLang('hu', [0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F, 0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69, 0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073, 0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20, 0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061, 0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74, 0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320]), new NGramsPlusLang('pl', [0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61, 0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779, 0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79, 0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20, 0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920, 0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769, 0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69, 0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720]), new NGramsPlusLang('ro', [0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469, 0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69, 0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172, 0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070, 0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72, 0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520, 0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20])];
	    };
	    this.name = function (det) {
	      return det && det.fC1Bytes ? 'windows-1250' : 'ISO-8859-2';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_2, sbcs);
	  module.exports.ISO_8859_5 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF];
	    };
	    this.ngrams = function () {
	      return [0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0, 0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE, 0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2, 0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD, 0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF, 0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2, 0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2, 0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520];
	    };
	    this.name = function (det) {
	      return 'ISO-8859-5';
	    };
	    this.language = function () {
	      return 'ru';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_5, sbcs);
	  module.exports.ISO_8859_6 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20];
	    };
	    this.ngrams = function () {
	      return [0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8, 0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5, 0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1, 0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20, 0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4, 0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620];
	    };
	    this.name = function (det) {
	      return 'ISO-8859-6';
	    };
	    this.language = function () {
	      return 'ar';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_6, sbcs);
	  module.exports.ISO_8859_7 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20, 0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE, 0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20];
	    };
	    this.ngrams = function () {
	      return [0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5, 0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7, 0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220, 0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120, 0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0, 0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5, 0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9, 0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20];
	    };
	    this.name = function (det) {
	      return det && det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
	    };
	    this.language = function () {
	      return 'el';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_7, sbcs);
	  module.exports.ISO_8859_8 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20];
	    };
	    this.ngrams = function () {
	      return [new NGramsPlusLang('he', [0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5, 0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0, 0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE, 0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4, 0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0, 0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE, 0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4, 0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9]), new NGramsPlusLang('he', [0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2, 0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0, 0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4, 0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC, 0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020, 0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920, 0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420, 0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9])];
	    };
	    this.name = function (det) {
	      return det && det.fC1Bytes ? 'windows-1255' : 'ISO-8859-8';
	    };
	    this.language = function () {
	      return 'he';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_8, sbcs);
	  module.exports.ISO_8859_9 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF];
	    };
	    this.ngrams = function () {
	      return [0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C, 0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961, 0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261, 0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062, 0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20, 0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062, 0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E, 0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD];
	    };
	    this.name = function (det) {
	      return det && det.fC1Bytes ? 'windows-1254' : 'ISO-8859-9';
	    };
	    this.language = function () {
	      return 'tr';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_9, sbcs);
	  module.exports.windows_1251 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F, 0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F, 0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20, 0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF, 0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20, 0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF];
	    };
	    this.ngrams = function () {
	      return [0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0, 0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE, 0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2, 0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED, 0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF, 0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2, 0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2, 0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520];
	    };
	    this.name = function (det) {
	      return 'windows-1251';
	    };
	    this.language = function () {
	      return 'ru';
	    };
	  };
	  util.inherits(module.exports.windows_1251, sbcs);
	  module.exports.windows_1256 = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20, 0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F, 0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20, 0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF];
	    };
	    this.ngrams = function () {
	      return [0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8, 0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3, 0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD, 0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20, 0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1, 0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420];
	    };
	    this.name = function (det) {
	      return 'windows-1256';
	    };
	    this.language = function () {
	      return 'ar';
	    };
	  };
	  util.inherits(module.exports.windows_1256, sbcs);
	  module.exports.KOI8_R = function () {
	    this.byteMap = function () {
	      return [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF];
	    };
	    this.ngrams = function () {
	      return [0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF, 0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1, 0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420, 0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE, 0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3, 0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1, 0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1, 0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF];
	    };
	    this.name = function (det) {
	      return 'KOI8-R';
	    };
	    this.language = function () {
	      return 'ru';
	    };
	  };
	  util.inherits(module.exports.KOI8_R, sbcs);

	  /*
	  module.exports.ISO_8859_7 = function() {
	    this.byteMap = function() {
	      return [
	  	    ];
	    };
	  	  this.ngrams = function() {
	      return [
	  	    ];
	    };
	  	  this.name = function(det) {
	      if (typeof det == 'undefined')
	        return 'ISO-8859-7';
	      return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
	    };
	  	  this.language = function() {
	      return 'el';
	    };
	  };
	  util.inherits(module.exports.ISO_8859_7, sbcs);
	  */
	})(sbcs$1);
	var sbcsExports = sbcs$1.exports;

	var iso2022$1 = {exports: {}};

	(function (module) {
	  var util = require$$0$4,
	    Match = match;

	  /**
	   * This is a superclass for the individual detectors for
	   * each of the detectable members of the ISO 2022 family
	   * of encodings.
	   */

	  function ISO_2022() {}
	  ISO_2022.prototype.match = function (det) {
	    /**
	     * Matching function shared among the 2022 detectors JP, CN and KR
	     * Counts up the number of legal an unrecognized escape sequences in
	     * the sample of text, and computes a score based on the total number &
	     * the proportion that fit the encoding.
	     *
	     *
	     * @param text the byte buffer containing text to analyse
	     * @param textLen  the size of the text in the byte.
	     * @param escapeSequences the byte escape sequences to test for.
	     * @return match quality, in the range of 0-100.
	     */

	    var i, j;
	    var escN;
	    var hits = 0;
	    var misses = 0;
	    var shifts = 0;
	    var quality;

	    // TODO: refactor me
	    var text = det.fInputBytes;
	    var textLen = det.fInputLen;
	    scanInput: for (i = 0; i < textLen; i++) {
	      if (text[i] == 0x1b) {
	        checkEscapes: for (escN = 0; escN < this.escapeSequences.length; escN++) {
	          var seq = this.escapeSequences[escN];
	          if (textLen - i < seq.length) continue checkEscapes;
	          for (j = 1; j < seq.length; j++) if (seq[j] != text[i + j]) continue checkEscapes;
	          hits++;
	          i += seq.length - 1;
	          continue scanInput;
	        }
	        misses++;
	      }

	      // Shift in/out
	      if (text[i] == 0x0e || text[i] == 0x0f) shifts++;
	    }
	    if (hits == 0) return null;

	    //
	    // Initial quality is based on relative proportion of recongized vs.
	    //   unrecognized escape sequences.
	    //   All good:  quality = 100;
	    //   half or less good: quality = 0;
	    //   linear inbetween.
	    quality = (100 * hits - 100 * misses) / (hits + misses);

	    // Back off quality if there were too few escape sequences seen.
	    //   Include shifts in this computation, so that KR does not get penalized
	    //   for having only a single Escape sequence, but many shifts.
	    if (hits + shifts < 5) quality -= (5 - (hits + shifts)) * 10;
	    return quality <= 0 ? null : new Match(det, this, quality);
	  };
	  module.exports.ISO_2022_JP = function () {
	    this.name = function () {
	      return 'ISO-2022-JP';
	    };
	    this.escapeSequences = [[0x1b, 0x24, 0x28, 0x43],
	    // KS X 1001:1992
	    [0x1b, 0x24, 0x28, 0x44],
	    // JIS X 212-1990
	    [0x1b, 0x24, 0x40],
	    // JIS C 6226-1978
	    [0x1b, 0x24, 0x41],
	    // GB 2312-80
	    [0x1b, 0x24, 0x42],
	    // JIS X 208-1983
	    [0x1b, 0x26, 0x40],
	    // JIS X 208 1990, 1997
	    [0x1b, 0x28, 0x42],
	    // ASCII
	    [0x1b, 0x28, 0x48],
	    // JIS-Roman
	    [0x1b, 0x28, 0x49],
	    // Half-width katakana
	    [0x1b, 0x28, 0x4a],
	    // JIS-Roman
	    [0x1b, 0x2e, 0x41],
	    // ISO 8859-1
	    [0x1b, 0x2e, 0x46] // ISO 8859-7
	    ];
	  };
	  util.inherits(module.exports.ISO_2022_JP, ISO_2022);
	  module.exports.ISO_2022_KR = function () {
	    this.name = function () {
	      return 'ISO-2022-KR';
	    };
	    this.escapeSequences = [[0x1b, 0x24, 0x29, 0x43]];
	  };
	  util.inherits(module.exports.ISO_2022_KR, ISO_2022);
	  module.exports.ISO_2022_CN = function () {
	    this.name = function () {
	      return 'ISO-2022-CN';
	    };
	    this.escapeSequences = [[0x1b, 0x24, 0x29, 0x41],
	    // GB 2312-80
	    [0x1b, 0x24, 0x29, 0x47],
	    // CNS 11643-1992 Plane 1
	    [0x1b, 0x24, 0x2A, 0x48],
	    // CNS 11643-1992 Plane 2
	    [0x1b, 0x24, 0x29, 0x45],
	    // ISO-IR-165
	    [0x1b, 0x24, 0x2B, 0x49],
	    // CNS 11643-1992 Plane 3
	    [0x1b, 0x24, 0x2B, 0x4A],
	    // CNS 11643-1992 Plane 4
	    [0x1b, 0x24, 0x2B, 0x4B],
	    // CNS 11643-1992 Plane 5
	    [0x1b, 0x24, 0x2B, 0x4C],
	    // CNS 11643-1992 Plane 6
	    [0x1b, 0x24, 0x2B, 0x4D],
	    // CNS 11643-1992 Plane 7
	    [0x1b, 0x4e],
	    // SS2
	    [0x1b, 0x4f] // SS3
	    ];
	  };
	  util.inherits(module.exports.ISO_2022_CN, ISO_2022);
	})(iso2022$1);
	var iso2022Exports = iso2022$1.exports;

	var fs$1 = require$$2$2;
	var utf8 = utf8$1,
	  unicode = unicodeExports,
	  mbcs = mbcsExports,
	  sbcs = sbcsExports,
	  iso2022 = iso2022Exports;
	var self$1 = commonjsGlobal;
	var recognisers = [new utf8(), new unicode.UTF_16BE(), new unicode.UTF_16LE(), new unicode.UTF_32BE(), new unicode.UTF_32LE(), new mbcs.sjis(), new mbcs.big5(), new mbcs.euc_jp(), new mbcs.euc_kr(), new mbcs.gb_18030(), new iso2022.ISO_2022_JP(), new iso2022.ISO_2022_KR(), new iso2022.ISO_2022_CN(), new sbcs.ISO_8859_1(), new sbcs.ISO_8859_2(), new sbcs.ISO_8859_5(), new sbcs.ISO_8859_6(), new sbcs.ISO_8859_7(), new sbcs.ISO_8859_8(), new sbcs.ISO_8859_9(), new sbcs.windows_1251(), new sbcs.windows_1256(), new sbcs.KOI8_R()];
	chardet.detect = function (buffer, opts) {
	  // Tally up the byte occurence statistics.
	  var fByteStats = [];
	  for (var i = 0; i < 256; i++) fByteStats[i] = 0;
	  for (var i = buffer.length - 1; i >= 0; i--) fByteStats[buffer[i] & 0x00ff]++;
	  var fC1Bytes = false;
	  for (var i = 0x80; i <= 0x9F; i += 1) {
	    if (fByteStats[i] != 0) {
	      fC1Bytes = true;
	      break;
	    }
	  }
	  var context = {
	    fByteStats: fByteStats,
	    fC1Bytes: fC1Bytes,
	    fRawInput: buffer,
	    fRawLength: buffer.length,
	    fInputBytes: buffer,
	    fInputLen: buffer.length
	  };
	  var matches = recognisers.map(function (rec) {
	    return rec.match(context);
	  }).filter(function (match) {
	    return !!match;
	  }).sort(function (a, b) {
	    return b.confidence - a.confidence;
	  });
	  if (opts && opts.returnAllMatches === true) {
	    return matches;
	  } else {
	    return matches.length > 0 ? matches[0].name : null;
	  }
	};
	chardet.detectFile = function (filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }
	  var fd;
	  var handler = function (err, buffer) {
	    if (fd) {
	      fs$1.closeSync(fd);
	    }
	    if (err) return cb(err, null);
	    cb(null, self$1.detect(buffer, opts));
	  };
	  if (opts && opts.sampleSize) {
	    fd = fs$1.openSync(filepath, 'r'), sample = Buffer.allocUnsafe(opts.sampleSize);
	    fs$1.read(fd, sample, 0, opts.sampleSize, null, function (err) {
	      handler(err, sample);
	    });
	    return;
	  }
	  fs$1.readFile(filepath, handler);
	};
	chardet.detectFileSync = function (filepath, opts) {
	  if (opts && opts.sampleSize) {
	    var fd = fs$1.openSync(filepath, 'r'),
	      sample = Buffer.allocUnsafe(opts.sampleSize);
	    fs$1.readSync(fd, sample, 0, opts.sampleSize);
	    fs$1.closeSync(fd);
	    return self$1.detect(sample, opts);
	  }
	  return self$1.detect(fs$1.readFileSync(filepath), opts);
	};

	// Wrappers for the previous functions to return all encodings
	chardet.detectAll = function (buffer, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self$1.detect(buffer, opts);
	};
	chardet.detectFileAll = function (filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  self$1.detectFile(filepath, opts, cb);
	};
	chardet.detectFileAllSync = function (filepath, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self$1.detectFileSync(filepath, opts);
	};

	var lib$1 = {exports: {}};

	/* eslint-disable node/no-deprecated-api */
	var buffer = require$$0$1;
	var Buffer$1 = buffer.Buffer;
	var safer = {};
	var key;
	for (key in buffer) {
	  if (!buffer.hasOwnProperty(key)) continue;
	  if (key === 'SlowBuffer' || key === 'Buffer') continue;
	  safer[key] = buffer[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer$1) {
	  if (!Buffer$1.hasOwnProperty(key)) continue;
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
	  Safer[key] = Buffer$1[key];
	}
	safer.Buffer.prototype = Buffer$1.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
	    }
	    return Buffer$1(value, encodingOrOffset, length);
	  };
	}
	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"');
	    }
	    var buf = Buffer$1(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf;
	  };
	}
	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}
	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}
	var safer_1 = safer;

	var bomHandling = {};

	var BOMChar = '\uFEFF';
	bomHandling.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
	  this.encoder = encoder;
	  this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function (str) {
	  if (this.addBOM) {
	    str = BOMChar + str;
	    this.addBOM = false;
	  }
	  return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function () {
	  return this.encoder.end();
	};

	//------------------------------------------------------------------------------

	bomHandling.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	  this.decoder = decoder;
	  this.pass = false;
	  this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function (buf) {
	  var res = this.decoder.write(buf);
	  if (this.pass || !res) return res;
	  if (res[0] === BOMChar) {
	    res = res.slice(1);
	    if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
	  }
	  this.pass = true;
	  return res;
	};
	StripBOMWrapper.prototype.end = function () {
	  return this.decoder.end();
	};

	var encodings = {};

	var internal;
	var hasRequiredInternal;
	function requireInternal() {
	  if (hasRequiredInternal) return internal;
	  hasRequiredInternal = 1;
	  var Buffer = safer_1.Buffer;

	  // Export Node.js internal encodings.

	  internal = {
	    // Encodings
	    utf8: {
	      type: "_internal",
	      bomAware: true
	    },
	    cesu8: {
	      type: "_internal",
	      bomAware: true
	    },
	    unicode11utf8: "utf8",
	    ucs2: {
	      type: "_internal",
	      bomAware: true
	    },
	    utf16le: "ucs2",
	    binary: {
	      type: "_internal"
	    },
	    base64: {
	      type: "_internal"
	    },
	    hex: {
	      type: "_internal"
	    },
	    // Codec.
	    _internal: InternalCodec
	  };

	  //------------------------------------------------------------------------------

	  function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;
	    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
	      this.enc = "utf8"; // Use utf8 for decoding.
	      this.encoder = InternalEncoderCesu8;

	      // Add decoder for versions of Node not supporting CESU-8
	      if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
	        this.decoder = InternalDecoderCesu8;
	        this.defaultCharUnicode = iconv.defaultCharUnicode;
	      }
	    }
	  }
	  InternalCodec.prototype.encoder = InternalEncoder;
	  InternalCodec.prototype.decoder = InternalDecoder;

	  //------------------------------------------------------------------------------

	  // We use node.js internal decoder. Its signature is the same as ours.
	  var StringDecoder = require$$1$1.StringDecoder;
	  if (!StringDecoder.prototype.end)
	    // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function () {};
	  function InternalDecoder(options, codec) {
	    StringDecoder.call(this, codec.enc);
	  }
	  InternalDecoder.prototype = StringDecoder.prototype;

	  //------------------------------------------------------------------------------
	  // Encoder is mostly trivial

	  function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	  }
	  InternalEncoder.prototype.write = function (str) {
	    return Buffer.from(str, this.enc);
	  };
	  InternalEncoder.prototype.end = function () {};

	  //------------------------------------------------------------------------------
	  // Except base64 encoder, which must keep its state.

	  function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	  }
	  InternalEncoderBase64.prototype.write = function (str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - str.length % 4;
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);
	    return Buffer.from(str, "base64");
	  };
	  InternalEncoderBase64.prototype.end = function () {
	    return Buffer.from(this.prevStr, "base64");
	  };

	  //------------------------------------------------------------------------------
	  // CESU-8 encoder is also special.

	  function InternalEncoderCesu8(options, codec) {}
	  InternalEncoderCesu8.prototype.write = function (str) {
	    var buf = Buffer.alloc(str.length * 3),
	      bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	      var charCode = str.charCodeAt(i);
	      // Naive implementation, but it works because CESU-8 is especially easy
	      // to convert from UTF-16 (which all JS strings are encoded in).
	      if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
	        buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	      } else {
	        // charCode will always be < 0x10000 in javascript.
	        buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	        buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
	        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	      }
	    }
	    return buf.slice(0, bufIdx);
	  };
	  InternalEncoderCesu8.prototype.end = function () {};

	  //------------------------------------------------------------------------------
	  // CESU-8 decoder is not implemented in Node v4.0+

	  function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	  }
	  InternalDecoderCesu8.prototype.write = function (buf) {
	    var acc = this.acc,
	      contBytes = this.contBytes,
	      accBytes = this.accBytes,
	      res = '';
	    for (var i = 0; i < buf.length; i++) {
	      var curByte = buf[i];
	      if ((curByte & 0xC0) !== 0x80) {
	        // Leading byte
	        if (contBytes > 0) {
	          // Previous code is invalid
	          res += this.defaultCharUnicode;
	          contBytes = 0;
	        }
	        if (curByte < 0x80) {
	          // Single-byte code
	          res += String.fromCharCode(curByte);
	        } else if (curByte < 0xE0) {
	          // Two-byte code
	          acc = curByte & 0x1F;
	          contBytes = 1;
	          accBytes = 1;
	        } else if (curByte < 0xF0) {
	          // Three-byte code
	          acc = curByte & 0x0F;
	          contBytes = 2;
	          accBytes = 1;
	        } else {
	          // Four or more are not supported for CESU-8.
	          res += this.defaultCharUnicode;
	        }
	      } else {
	        // Continuation byte
	        if (contBytes > 0) {
	          // We're waiting for it.
	          acc = acc << 6 | curByte & 0x3f;
	          contBytes--;
	          accBytes++;
	          if (contBytes === 0) {
	            // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	            if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
	              // Actually add character.
	              res += String.fromCharCode(acc);
	          }
	        } else {
	          // Unexpected continuation byte
	          res += this.defaultCharUnicode;
	        }
	      }
	    }
	    this.acc = acc;
	    this.contBytes = contBytes;
	    this.accBytes = accBytes;
	    return res;
	  };
	  InternalDecoderCesu8.prototype.end = function () {
	    var res = 0;
	    if (this.contBytes > 0) res += this.defaultCharUnicode;
	    return res;
	  };
	  return internal;
	}

	var utf16 = {};

	var hasRequiredUtf16;
	function requireUtf16() {
	  if (hasRequiredUtf16) return utf16;
	  hasRequiredUtf16 = 1;
	  var Buffer = safer_1.Buffer;

	  // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

	  // == UTF16-BE codec. ==========================================================

	  utf16.utf16be = Utf16BECodec;
	  function Utf16BECodec() {}
	  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	  Utf16BECodec.prototype.bomAware = true;

	  // -- Encoding

	  function Utf16BEEncoder() {}
	  Utf16BEEncoder.prototype.write = function (str) {
	    var buf = Buffer.from(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	      var tmp = buf[i];
	      buf[i] = buf[i + 1];
	      buf[i + 1] = tmp;
	    }
	    return buf;
	  };
	  Utf16BEEncoder.prototype.end = function () {};

	  // -- Decoding

	  function Utf16BEDecoder() {
	    this.overflowByte = -1;
	  }
	  Utf16BEDecoder.prototype.write = function (buf) {
	    if (buf.length == 0) return '';
	    var buf2 = Buffer.alloc(buf.length + 1),
	      i = 0,
	      j = 0;
	    if (this.overflowByte !== -1) {
	      buf2[0] = buf[0];
	      buf2[1] = this.overflowByte;
	      i = 1;
	      j = 2;
	    }
	    for (; i < buf.length - 1; i += 2, j += 2) {
	      buf2[j] = buf[i + 1];
	      buf2[j + 1] = buf[i];
	    }
	    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
	    return buf2.slice(0, j).toString('ucs2');
	  };
	  Utf16BEDecoder.prototype.end = function () {};

	  // == UTF-16 codec =============================================================
	  // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	  // Defaults to UTF-16LE, as it's prevalent and default in Node.
	  // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	  // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	  // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	  utf16.utf16 = Utf16Codec;
	  function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	  }
	  Utf16Codec.prototype.encoder = Utf16Encoder;
	  Utf16Codec.prototype.decoder = Utf16Decoder;

	  // -- Encoding (pass-through)

	  function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined) options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	  }
	  Utf16Encoder.prototype.write = function (str) {
	    return this.encoder.write(str);
	  };
	  Utf16Encoder.prototype.end = function () {
	    return this.encoder.end();
	  };

	  // -- Decoding

	  function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBytes = [];
	    this.initialBytesLen = 0;
	    this.options = options || {};
	    this.iconv = codec.iconv;
	  }
	  Utf16Decoder.prototype.write = function (buf) {
	    if (!this.decoder) {
	      // Codec is not chosen yet. Accumulate initial bytes.
	      this.initialBytes.push(buf);
	      this.initialBytesLen += buf.length;
	      if (this.initialBytesLen < 16)
	        // We need more bytes to use space heuristic (see below)
	        return '';

	      // We have enough bytes -> detect endianness.
	      var buf = Buffer.concat(this.initialBytes),
	        encoding = detectEncoding(buf, this.options.defaultEncoding);
	      this.decoder = this.iconv.getDecoder(encoding, this.options);
	      this.initialBytes.length = this.initialBytesLen = 0;
	    }
	    return this.decoder.write(buf);
	  };
	  Utf16Decoder.prototype.end = function () {
	    if (!this.decoder) {
	      var buf = Buffer.concat(this.initialBytes),
	        encoding = detectEncoding(buf, this.options.defaultEncoding);
	      this.decoder = this.iconv.getDecoder(encoding, this.options);
	      var res = this.decoder.write(buf),
	        trail = this.decoder.end();
	      return trail ? res + trail : res;
	    }
	    return this.decoder.end();
	  };
	  function detectEncoding(buf, defaultEncoding) {
	    var enc = defaultEncoding || 'utf-16le';
	    if (buf.length >= 2) {
	      // Check BOM.
	      if (buf[0] == 0xFE && buf[1] == 0xFF)
	        // UTF-16BE BOM
	        enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE)
	        // UTF-16LE BOM
	        enc = 'utf-16le';else {
	        // No BOM found. Try to deduce encoding from initial content.
	        // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	        // So, we count ASCII as if it was LE or BE, and decide from that.
	        var asciiCharsLE = 0,
	          asciiCharsBE = 0,
	          // Counts of chars in both positions
	          _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

	        for (var i = 0; i < _len; i += 2) {
	          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
	          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
	        }
	        if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
	      }
	    }
	    return enc;
	  }
	  return utf16;
	}

	var utf7 = {};

	var hasRequiredUtf7;
	function requireUtf7() {
	  if (hasRequiredUtf7) return utf7;
	  hasRequiredUtf7 = 1;
	  var Buffer = safer_1.Buffer;

	  // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	  // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	  utf7.utf7 = Utf7Codec;
	  utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	  function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	  }
	  Utf7Codec.prototype.encoder = Utf7Encoder;
	  Utf7Codec.prototype.decoder = Utf7Decoder;
	  Utf7Codec.prototype.bomAware = true;

	  // -- Encoding

	  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	  function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	  }
	  Utf7Encoder.prototype.write = function (str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return Buffer.from(str.replace(nonDirectChars, function (chunk) {
	      return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
	    }.bind(this)));
	  };
	  Utf7Encoder.prototype.end = function () {};

	  // -- Decoding

	  function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	  }
	  var base64Regex = /[A-Za-z0-9\/+]/;
	  var base64Chars = [];
	  for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	  var plusChar = '+'.charCodeAt(0),
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);
	  Utf7Decoder.prototype.write = function (buf) {
	    var res = "",
	      lastI = 0,
	      inBase64 = this.inBase64,
	      base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.

	    for (var i = 0; i < buf.length; i++) {
	      if (!inBase64) {
	        // We're in direct mode.
	        // Write direct chars until '+'
	        if (buf[i] == plusChar) {
	          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	          lastI = i + 1;
	          inBase64 = true;
	        }
	      } else {
	        // We decode base64.
	        if (!base64Chars[buf[i]]) {
	          // Base64 ended.
	          if (i == lastI && buf[i] == minusChar) {
	            // "+-" -> "+"
	            res += "+";
	          } else {
	            var b64str = base64Accum + buf.slice(lastI, i).toString();
	            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	          }
	          if (buf[i] != minusChar)
	            // Minus is absorbed after base64.
	            i--;
	          lastI = i + 1;
	          inBase64 = false;
	          base64Accum = '';
	        }
	      }
	    }
	    if (!inBase64) {
	      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	      var b64str = base64Accum + buf.slice(lastI).toString();
	      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	      b64str = b64str.slice(0, canBeDecoded);
	      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }
	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;
	    return res;
	  };
	  Utf7Decoder.prototype.end = function () {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	  };

	  // UTF-7-IMAP codec.
	  // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	  // Differences:
	  //  * Base64 part is started by "&" instead of "+"
	  //  * Direct characters are 0x20-0x7E, except "&" (0x26)
	  //  * In Base64, "," is used instead of "/"
	  //  * Base64 must not be used to represent direct characters.
	  //  * No implicit shift back from Base64 (should always end with '-')
	  //  * String must end in non-shifted position.
	  //  * "-&" while in base64 is not allowed.

	  utf7.utf7imap = Utf7IMAPCodec;
	  function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	  }
	  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	  Utf7IMAPCodec.prototype.bomAware = true;

	  // -- Encoding

	  function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = Buffer.alloc(6);
	    this.base64AccumIdx = 0;
	  }
	  Utf7IMAPEncoder.prototype.write = function (str) {
	    var inBase64 = this.inBase64,
	      base64Accum = this.base64Accum,
	      base64AccumIdx = this.base64AccumIdx,
	      buf = Buffer.alloc(str.length * 5 + 10),
	      bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	      var uChar = str.charCodeAt(i);
	      if (0x20 <= uChar && uChar <= 0x7E) {
	        // Direct character or '&'.
	        if (inBase64) {
	          if (base64AccumIdx > 0) {
	            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            base64AccumIdx = 0;
	          }
	          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	          inBase64 = false;
	        }
	        if (!inBase64) {
	          buf[bufIdx++] = uChar; // Write direct character

	          if (uChar === andChar)
	            // Ampersand -> '&-'
	            buf[bufIdx++] = minusChar;
	        }
	      } else {
	        // Non-direct character
	        if (!inBase64) {
	          buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	          inBase64 = true;
	        }
	        if (inBase64) {
	          base64Accum[base64AccumIdx++] = uChar >> 8;
	          base64Accum[base64AccumIdx++] = uChar & 0xFF;
	          if (base64AccumIdx == base64Accum.length) {
	            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	            base64AccumIdx = 0;
	          }
	        }
	      }
	    }
	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;
	    return buf.slice(0, bufIdx);
	  };
	  Utf7IMAPEncoder.prototype.end = function () {
	    var buf = Buffer.alloc(10),
	      bufIdx = 0;
	    if (this.inBase64) {
	      if (this.base64AccumIdx > 0) {
	        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	        this.base64AccumIdx = 0;
	      }
	      buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	      this.inBase64 = false;
	    }
	    return buf.slice(0, bufIdx);
	  };

	  // -- Decoding

	  function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	  }
	  var base64IMAPChars = base64Chars.slice();
	  base64IMAPChars[','.charCodeAt(0)] = true;
	  Utf7IMAPDecoder.prototype.write = function (buf) {
	    var res = "",
	      lastI = 0,
	      inBase64 = this.inBase64,
	      base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	    for (var i = 0; i < buf.length; i++) {
	      if (!inBase64) {
	        // We're in direct mode.
	        // Write direct chars until '&'
	        if (buf[i] == andChar) {
	          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	          lastI = i + 1;
	          inBase64 = true;
	        }
	      } else {
	        // We decode base64.
	        if (!base64IMAPChars[buf[i]]) {
	          // Base64 ended.
	          if (i == lastI && buf[i] == minusChar) {
	            // "&-" -> "&"
	            res += "&";
	          } else {
	            var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
	            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	          }
	          if (buf[i] != minusChar)
	            // Minus may be absorbed after base64.
	            i--;
	          lastI = i + 1;
	          inBase64 = false;
	          base64Accum = '';
	        }
	      }
	    }
	    if (!inBase64) {
	      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
	      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	      b64str = b64str.slice(0, canBeDecoded);
	      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }
	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;
	    return res;
	  };
	  Utf7IMAPDecoder.prototype.end = function () {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	  };
	  return utf7;
	}

	var sbcsCodec = {};

	var hasRequiredSbcsCodec;
	function requireSbcsCodec() {
	  if (hasRequiredSbcsCodec) return sbcsCodec;
	  hasRequiredSbcsCodec = 1;
	  var Buffer = safer_1.Buffer;

	  // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	  // correspond to encoded bytes (if 128 - then lower half is ASCII). 

	  sbcsCodec._sbcs = SBCSCodec;
	  function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
	    if (codecOptions.chars.length === 128) {
	      var asciiString = "";
	      for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
	      codecOptions.chars = asciiString + codecOptions.chars;
	    }
	    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

	    // Encoding buffer.
	    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
	    for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
	    this.encodeBuf = encodeBuf;
	  }
	  SBCSCodec.prototype.encoder = SBCSEncoder;
	  SBCSCodec.prototype.decoder = SBCSDecoder;
	  function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	  }
	  SBCSEncoder.prototype.write = function (str) {
	    var buf = Buffer.alloc(str.length);
	    for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    return buf;
	  };
	  SBCSEncoder.prototype.end = function () {};
	  function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	  }
	  SBCSDecoder.prototype.write = function (buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = Buffer.alloc(buf.length * 2);
	    var idx1 = 0,
	      idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	      idx1 = buf[i] * 2;
	      idx2 = i * 2;
	      newBuf[idx2] = decodeBuf[idx1];
	      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
	    }
	    return newBuf.toString('ucs2');
	  };
	  SBCSDecoder.prototype.end = function () {};
	  return sbcsCodec;
	}

	var sbcsData;
	var hasRequiredSbcsData;
	function requireSbcsData() {
	  if (hasRequiredSbcsData) return sbcsData;
	  hasRequiredSbcsData = 1;

	  // Manually added data to be used by sbcs codec in addition to generated one.

	  sbcsData = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "mik": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",
	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",
	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek": "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",
	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",
	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",
	    "cp819": "iso88591",
	    "ibm819": "iso88591",
	    "cyrillic": "iso88595",
	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",
	    "greek": "iso88597",
	    "greek8": "iso88597",
	    "ecma118": "iso88597",
	    "elot928": "iso88597",
	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",
	    "turkish": "iso88599",
	    "turkish8": "iso88599",
	    "thai": "iso885911",
	    "thai8": "iso885911",
	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",
	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",
	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",
	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",
	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",
	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",
	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",
	    "strk10482002": "rk1048",
	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",
	    "gb198880": "iso646cn",
	    "cn": "iso646cn",
	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",
	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",
	    "mac": "macintosh",
	    "csmacintosh": "macintosh"
	  };
	  return sbcsData;
	}

	var sbcsDataGenerated;
	var hasRequiredSbcsDataGenerated;
	function requireSbcsDataGenerated() {
	  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	  hasRequiredSbcsDataGenerated = 1;

	  // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	  sbcsDataGenerated = {
	    "437": "cp437",
	    "737": "cp737",
	    "775": "cp775",
	    "850": "cp850",
	    "852": "cp852",
	    "855": "cp855",
	    "856": "cp856",
	    "857": "cp857",
	    "858": "cp858",
	    "860": "cp860",
	    "861": "cp861",
	    "862": "cp862",
	    "863": "cp863",
	    "864": "cp864",
	    "865": "cp865",
	    "866": "cp866",
	    "869": "cp869",
	    "874": "windows874",
	    "922": "cp922",
	    "1046": "cp1046",
	    "1124": "cp1124",
	    "1125": "cp1125",
	    "1129": "cp1129",
	    "1133": "cp1133",
	    "1161": "cp1161",
	    "1162": "cp1162",
	    "1163": "cp1163",
	    "1250": "windows1250",
	    "1251": "windows1251",
	    "1252": "windows1252",
	    "1253": "windows1253",
	    "1254": "windows1254",
	    "1255": "windows1255",
	    "1256": "windows1256",
	    "1257": "windows1257",
	    "1258": "windows1258",
	    "28591": "iso88591",
	    "28592": "iso88592",
	    "28593": "iso88593",
	    "28594": "iso88594",
	    "28595": "iso88595",
	    "28596": "iso88596",
	    "28597": "iso88597",
	    "28598": "iso88598",
	    "28599": "iso88599",
	    "28600": "iso885910",
	    "28601": "iso885911",
	    "28603": "iso885913",
	    "28604": "iso885914",
	    "28605": "iso885915",
	    "28606": "iso885916",
	    "windows874": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win874": "windows874",
	    "cp874": "windows874",
	    "windows1250": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1250": "windows1250",
	    "cp1250": "windows1250",
	    "windows1251": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1251": "windows1251",
	    "cp1251": "windows1251",
	    "windows1252": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1252": "windows1252",
	    "cp1252": "windows1252",
	    "windows1253": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1253": "windows1253",
	    "cp1253": "windows1253",
	    "windows1254": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1254": "windows1254",
	    "cp1254": "windows1254",
	    "windows1255": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1255": "windows1255",
	    "cp1255": "windows1255",
	    "windows1256": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1256": "windows1256",
	    "cp1256": "windows1256",
	    "windows1257": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1257": "windows1257",
	    "cp1257": "windows1257",
	    "windows1258": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "win1258": "windows1258",
	    "cp1258": "windows1258",
	    "iso88591": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28591": "iso88591",
	    "iso88592": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28592": "iso88592",
	    "iso88593": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28593": "iso88593",
	    "iso88594": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28594": "iso88594",
	    "iso88595": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28595": "iso88595",
	    "iso88596": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28596": "iso88596",
	    "iso88597": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28597": "iso88597",
	    "iso88598": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28598": "iso88598",
	    "iso88599": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28599": "iso88599",
	    "iso885910": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28600": "iso885910",
	    "iso885911": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28601": "iso885911",
	    "iso885913": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28603": "iso885913",
	    "iso885914": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28604": "iso885914",
	    "iso885915": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28605": "iso885915",
	    "iso885916": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "cp28606": "iso885916",
	    "cp437": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm437": "cp437",
	    "csibm437": "cp437",
	    "cp737": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm737": "cp737",
	    "csibm737": "cp737",
	    "cp775": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm775": "cp775",
	    "csibm775": "cp775",
	    "cp850": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm850": "cp850",
	    "csibm850": "cp850",
	    "cp852": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm852": "cp852",
	    "csibm852": "cp852",
	    "cp855": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm855": "cp855",
	    "csibm855": "cp855",
	    "cp856": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm856": "cp856",
	    "csibm856": "cp856",
	    "cp857": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm857": "cp857",
	    "csibm857": "cp857",
	    "cp858": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm858": "cp858",
	    "csibm858": "cp858",
	    "cp860": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm860": "cp860",
	    "csibm860": "cp860",
	    "cp861": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm861": "cp861",
	    "csibm861": "cp861",
	    "cp862": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm862": "cp862",
	    "csibm862": "cp862",
	    "cp863": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm863": "cp863",
	    "csibm863": "cp863",
	    "cp864": {
	      "type": "_sbcs",
	      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	    },
	    "ibm864": "cp864",
	    "csibm864": "cp864",
	    "cp865": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm865": "cp865",
	    "csibm865": "cp865",
	    "cp866": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm866": "cp866",
	    "csibm866": "cp866",
	    "cp869": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm869": "cp869",
	    "csibm869": "cp869",
	    "cp922": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm922": "cp922",
	    "csibm922": "cp922",
	    "cp1046": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1046": "cp1046",
	    "csibm1046": "cp1046",
	    "cp1124": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1124": "cp1124",
	    "csibm1124": "cp1124",
	    "cp1125": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1125": "cp1125",
	    "csibm1125": "cp1125",
	    "cp1129": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1129": "cp1129",
	    "csibm1129": "cp1129",
	    "cp1133": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1133": "cp1133",
	    "csibm1133": "cp1133",
	    "cp1161": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1161": "cp1161",
	    "csibm1161": "cp1161",
	    "cp1162": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1162": "cp1162",
	    "csibm1162": "cp1162",
	    "cp1163": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ibm1163": "cp1163",
	    "csibm1163": "cp1163",
	    "maccroatian": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "maccyrillic": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macgreek": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "maciceland": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macroman": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macromania": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macthai": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macturkish": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macukraine": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "koi8r": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "koi8u": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "koi8ru": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "koi8t": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "armscii8": {
	      "type": "_sbcs",
	      "chars": ")(.,-"
	    },
	    "rk1048": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "tcvn": {
	      "type": "_sbcs",
	      "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	    },
	    "georgianacademy": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "georgianps": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "pt154": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "viscii": {
	      "type": "_sbcs",
	      "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	    },
	    "iso646cn": {
	      "type": "_sbcs",
	      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	    },
	    "iso646jp": {
	      "type": "_sbcs",
	      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	    },
	    "hproman8": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "macintosh": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "ascii": {
	      "type": "_sbcs",
	      "chars": ""
	    },
	    "tis620": {
	      "type": "_sbcs",
	      "chars": ""
	    }
	  };
	  return sbcsDataGenerated;
	}

	var dbcsCodec = {};

	var hasRequiredDbcsCodec;
	function requireDbcsCodec() {
	  if (hasRequiredDbcsCodec) return dbcsCodec;
	  hasRequiredDbcsCodec = 1;
	  var Buffer = safer_1.Buffer;

	  // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	  // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	  // To save memory and loading time, we read table files only when requested.

	  dbcsCodec._dbcs = DBCSCodec;
	  var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START = -10,
	    NODE_START = -1000,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;
	  for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

	  // Class DBCSCodec reads and initializes mapping tables.
	  function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
	    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

	    // Load tables.
	    var mappingTable = codecOptions.table();

	    // Decode tables: MBCS -> Unicode.

	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];

	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
	    this.defaultCharUnicode = iconv.defaultCharUnicode;

	    // Encode tables: Unicode -> DBCS.

	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];

	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];

	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	      var val = codecOptions.encodeSkipVals[i];
	      if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
	    }

	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);

	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	      for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	    }
	    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	      this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	      // Add GB18030 decode tables.
	      var thirdByteNodeIdx = this.decodeTables.length;
	      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
	      var fourthByteNodeIdx = this.decodeTables.length;
	      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
	      for (var i = 0x81; i <= 0xFE; i++) {
	        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
	        var secondByteNode = this.decodeTables[secondByteNodeIdx];
	        for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
	      }
	      for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
	      for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;
	    }
	  }
	  DBCSCodec.prototype.encoder = DBCSEncoder;
	  DBCSCodec.prototype.decoder = DBCSDecoder;

	  // Decoder helpers
	  DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);
	    if (bytes.length == 0) bytes.push(0);
	    var node = this.decodeTables[0];
	    for (var i = bytes.length - 1; i > 0; i--) {
	      // Traverse nodes deeper into the trie.
	      var val = node[bytes[i]];
	      if (val == UNASSIGNED) {
	        // Create new node.
	        node[bytes[i]] = NODE_START - this.decodeTables.length;
	        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	      } else if (val <= NODE_START) {
	        // Existing node.
	        node = this.decodeTables[NODE_START - val];
	      } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	  };
	  DBCSCodec.prototype._addDecodeChunk = function (chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);

	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;

	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	      var part = chunk[k];
	      if (typeof part === "string") {
	        // String, write as-is.
	        for (var l = 0; l < part.length;) {
	          var code = part.charCodeAt(l++);
	          if (0xD800 <= code && code < 0xDC00) {
	            // Decode surrogate
	            var codeTrail = part.charCodeAt(l++);
	            if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
	          } else if (0x0FF0 < code && code <= 0x0FFF) {
	            // Character sequence (our own encoding used)
	            var len = 0xFFF - code + 2;
	            var seq = [];
	            for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

	            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	            this.decodeTableSeq.push(seq);
	          } else writeTable[curAddr++] = code; // Basic char
	        }
	      } else if (typeof part === "number") {
	        // Integer, meaning increasing sequence starting with prev character.
	        var charCode = writeTable[curAddr - 1] + 1;
	        for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
	      } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	  };

	  // Encoder helpers
	  DBCSCodec.prototype._getEncodeBucket = function (uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	  };
	  DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	  };
	  DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    var node;
	    if (bucket[low] <= SEQ_START) {
	      // There's already a sequence with  - use it.
	      node = this.encodeTableSeq[SEQ_START - bucket[low]];
	    } else {
	      // There was no sequence object - allocate a new one.
	      node = {};
	      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	      bucket[low] = SEQ_START - this.encodeTableSeq.length;
	      this.encodeTableSeq.push(node);
	    }

	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length - 1; j++) {
	      var oldVal = node[uCode];
	      if (typeof oldVal === 'object') node = oldVal;else {
	        node = node[uCode] = {};
	        if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
	      }
	    }

	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length - 1];
	    node[uCode] = dbcsCode;
	  };
	  DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    for (var i = 0; i < 0x100; i++) {
	      var uCode = node[i];
	      var mbCode = prefix + i;
	      if (skipEncodeChars[mbCode]) continue;
	      if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	    }
	  };

	  // == Encoder ==================================================================

	  function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;

	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	  }
	  DBCSEncoder.prototype.write = function (str) {
	    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
	      leadSurrogate = this.leadSurrogate,
	      seqObj = this.seqObj,
	      nextChar = -1,
	      i = 0,
	      j = 0;
	    while (true) {
	      // 0. Get next character.
	      if (nextChar === -1) {
	        if (i == str.length) break;
	        var uCode = str.charCodeAt(i++);
	      } else {
	        var uCode = nextChar;
	        nextChar = -1;
	      }

	      // 1. Handle surrogates.
	      if (0xD800 <= uCode && uCode < 0xE000) {
	        // Char is one of surrogates.
	        if (uCode < 0xDC00) {
	          // We've got lead surrogate.
	          if (leadSurrogate === -1) {
	            leadSurrogate = uCode;
	            continue;
	          } else {
	            leadSurrogate = uCode;
	            // Double lead surrogate found.
	            uCode = UNASSIGNED;
	          }
	        } else {
	          // We've got trail surrogate.
	          if (leadSurrogate !== -1) {
	            uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	            leadSurrogate = -1;
	          } else {
	            // Incomplete surrogate pair - only trail surrogate found.
	            uCode = UNASSIGNED;
	          }
	        }
	      } else if (leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        nextChar = uCode;
	        uCode = UNASSIGNED; // Write an error, then current char.
	        leadSurrogate = -1;
	      }

	      // 2. Convert uCode character.
	      var dbcsCode = UNASSIGNED;
	      if (seqObj !== undefined && uCode != UNASSIGNED) {
	        // We are in the middle of the sequence
	        var resCode = seqObj[uCode];
	        if (typeof resCode === 'object') {
	          // Sequence continues.
	          seqObj = resCode;
	          continue;
	        } else if (typeof resCode == 'number') {
	          // Sequence finished. Write it.
	          dbcsCode = resCode;
	        } else if (resCode == undefined) {
	          // Current character is not part of the sequence.

	          // Try default character for this sequence
	          resCode = seqObj[DEF_CHAR];
	          if (resCode !== undefined) {
	            dbcsCode = resCode; // Found. Write it.
	            nextChar = uCode; // Current character will be written too in the next iteration.
	          }
	        }
	        seqObj = undefined;
	      } else if (uCode >= 0) {
	        // Regular character
	        var subtable = this.encodeTable[uCode >> 8];
	        if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
	        if (dbcsCode <= SEQ_START) {
	          // Sequence start
	          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
	          continue;
	        }
	        if (dbcsCode == UNASSIGNED && this.gb18030) {
	          // Use GB18030 algorithm to find character(s) to write.
	          var idx = findIdx(this.gb18030.uChars, uCode);
	          if (idx != -1) {
	            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
	            dbcsCode = dbcsCode % 12600;
	            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
	            dbcsCode = dbcsCode % 1260;
	            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
	            dbcsCode = dbcsCode % 10;
	            newBuf[j++] = 0x30 + dbcsCode;
	            continue;
	          }
	        }
	      }

	      // 3. Write dbcsCode character.
	      if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
	      if (dbcsCode < 0x100) {
	        newBuf[j++] = dbcsCode;
	      } else if (dbcsCode < 0x10000) {
	        newBuf[j++] = dbcsCode >> 8; // high byte
	        newBuf[j++] = dbcsCode & 0xFF; // low byte
	      } else {
	        newBuf[j++] = dbcsCode >> 16;
	        newBuf[j++] = dbcsCode >> 8 & 0xFF;
	        newBuf[j++] = dbcsCode & 0xFF;
	      }
	    }
	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	  };
	  DBCSEncoder.prototype.end = function () {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

	    var newBuf = Buffer.alloc(10),
	      j = 0;
	    if (this.seqObj) {
	      // We're in the sequence.
	      var dbcsCode = this.seqObj[DEF_CHAR];
	      if (dbcsCode !== undefined) {
	        // Write beginning of the sequence.
	        if (dbcsCode < 0x100) {
	          newBuf[j++] = dbcsCode;
	        } else {
	          newBuf[j++] = dbcsCode >> 8; // high byte
	          newBuf[j++] = dbcsCode & 0xFF; // low byte
	        }
	      }
	      this.seqObj = undefined;
	    }
	    if (this.leadSurrogate !== -1) {
	      // Incomplete surrogate pair - only lead surrogate found.
	      newBuf[j++] = this.defaultCharSingleByte;
	      this.leadSurrogate = -1;
	    }
	    return newBuf.slice(0, j);
	  };

	  // Export for testing
	  DBCSEncoder.prototype.findIdx = findIdx;

	  // == Decoder ==================================================================

	  function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBuf = Buffer.alloc(0);

	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	  }
	  DBCSDecoder.prototype.write = function (buf) {
	    var newBuf = Buffer.alloc(buf.length * 2),
	      nodeIdx = this.nodeIdx,
	      prevBuf = this.prevBuf,
	      prevBufOffset = this.prevBuf.length,
	      seqStart = -this.prevBuf.length,
	      // idx of the start of current parsed sequence.
	      uCode;
	    if (prevBufOffset > 0)
	      // Make prev buf overlap a little to make it easier to slice later.
	      prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
	    for (var i = 0, j = 0; i < buf.length; i++) {
	      var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

	      // Lookup in current trie node.
	      var uCode = this.decodeTables[nodeIdx][curByte];
	      if (uCode >= 0) ; else if (uCode === UNASSIGNED) {
	        // Unknown char.
	        // TODO: Callback with seq.
	        //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	        i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
	        uCode = this.defaultCharUnicode.charCodeAt(0);
	      } else if (uCode === GB18030_CODE) {
	        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
	        var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
	        var idx = findIdx(this.gb18030.gbChars, ptr);
	        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	      } else if (uCode <= NODE_START) {
	        // Go to next trie node.
	        nodeIdx = NODE_START - uCode;
	        continue;
	      } else if (uCode <= SEQ_START) {
	        // Output a sequence of chars.
	        var seq = this.decodeTableSeq[SEQ_START - uCode];
	        for (var k = 0; k < seq.length - 1; k++) {
	          uCode = seq[k];
	          newBuf[j++] = uCode & 0xFF;
	          newBuf[j++] = uCode >> 8;
	        }
	        uCode = seq[seq.length - 1];
	      } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

	      // Write the character to buffer, handling higher planes using surrogate pair.
	      if (uCode > 0xFFFF) {
	        uCode -= 0x10000;
	        var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
	        newBuf[j++] = uCodeLead & 0xFF;
	        newBuf[j++] = uCodeLead >> 8;
	        uCode = 0xDC00 + uCode % 0x400;
	      }
	      newBuf[j++] = uCode & 0xFF;
	      newBuf[j++] = uCode >> 8;

	      // Reset trie node.
	      nodeIdx = 0;
	      seqStart = i + 1;
	    }
	    this.nodeIdx = nodeIdx;
	    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
	    return newBuf.slice(0, j).toString('ucs2');
	  };
	  DBCSDecoder.prototype.end = function () {
	    var ret = '';

	    // Try to parse all remaining chars.
	    while (this.prevBuf.length > 0) {
	      // Skip 1 character in the buffer.
	      ret += this.defaultCharUnicode;
	      var buf = this.prevBuf.slice(1);

	      // Parse remaining as usual.
	      this.prevBuf = Buffer.alloc(0);
	      this.nodeIdx = 0;
	      if (buf.length > 0) ret += this.write(buf);
	    }
	    this.nodeIdx = 0;
	    return ret;
	  };

	  // Binary search for GB18030. Returns largest i such that table[i] <= val.
	  function findIdx(table, val) {
	    if (table[0] > val) return -1;
	    var l = 0,
	      r = table.length;
	    while (l < r - 1) {
	      // always table[l] <= val < table[r]
	      var mid = l + Math.floor((r - l + 1) / 2);
	      if (table[mid] <= val) l = mid;else r = mid;
	    }
	    return l;
	  }
	  return dbcsCodec;
	}

	var require$$0 = [
		[
			"0",
			"\u0000",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		[
			"8180",
			""
		],
		[
			"81b8",
			""
		],
		[
			"81c8",
			""
		],
		[
			"81da",
			""
		],
		[
			"81f0",
			""
		],
		[
			"81fc",
			""
		],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		[
			"849f",
			""
		],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		[
			"875f",
			""
		],
		[
			"877e",
			""
		],
		[
			"8780",
			"",
			4,
			""
		],
		[
			"889f",
			""
		],
		[
			"8940",
			""
		],
		[
			"8980",
			""
		],
		[
			"8a40",
			""
		],
		[
			"8a80",
			""
		],
		[
			"8b40",
			""
		],
		[
			"8b80",
			""
		],
		[
			"8c40",
			""
		],
		[
			"8c80",
			""
		],
		[
			"8d40",
			""
		],
		[
			"8d80",
			""
		],
		[
			"8e40",
			""
		],
		[
			"8e80",
			""
		],
		[
			"8f40",
			""
		],
		[
			"8f80",
			""
		],
		[
			"9040",
			""
		],
		[
			"9080",
			""
		],
		[
			"9140",
			""
		],
		[
			"9180",
			""
		],
		[
			"9240",
			""
		],
		[
			"9280",
			""
		],
		[
			"9340",
			""
		],
		[
			"9380",
			""
		],
		[
			"9440",
			""
		],
		[
			"9480",
			""
		],
		[
			"9540",
			""
		],
		[
			"9580",
			""
		],
		[
			"9640",
			""
		],
		[
			"9680",
			""
		],
		[
			"9740",
			""
		],
		[
			"9780",
			""
		],
		[
			"9840",
			""
		],
		[
			"989f",
			""
		],
		[
			"9940",
			""
		],
		[
			"9980",
			""
		],
		[
			"9a40",
			""
		],
		[
			"9a80",
			""
		],
		[
			"9b40",
			""
		],
		[
			"9b80",
			""
		],
		[
			"9c40",
			""
		],
		[
			"9c80",
			""
		],
		[
			"9d40",
			""
		],
		[
			"9d80",
			""
		],
		[
			"9e40",
			""
		],
		[
			"9e80",
			""
		],
		[
			"9f40",
			""
		],
		[
			"9f80",
			""
		],
		[
			"e040",
			""
		],
		[
			"e080",
			""
		],
		[
			"e140",
			""
		],
		[
			"e180",
			""
		],
		[
			"e240",
			""
		],
		[
			"e280",
			""
		],
		[
			"e340",
			""
		],
		[
			"e380",
			""
		],
		[
			"e440",
			""
		],
		[
			"e480",
			""
		],
		[
			"e540",
			""
		],
		[
			"e580",
			""
		],
		[
			"e640",
			""
		],
		[
			"e680",
			""
		],
		[
			"e740",
			""
		],
		[
			"e780",
			""
		],
		[
			"e840",
			""
		],
		[
			"e880",
			""
		],
		[
			"e940",
			""
		],
		[
			"e980",
			""
		],
		[
			"ea40",
			""
		],
		[
			"ea80",
			""
		],
		[
			"ed40",
			""
		],
		[
			"ed80",
			""
		],
		[
			"ee40",
			""
		],
		[
			"ee80",
			""
		],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		[
			"f940",
			""
		],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		[
			"fa80",
			""
		],
		[
			"fb40",
			""
		],
		[
			"fb80",
			""
		],
		[
			"fc40",
			""
		]
	];

	var require$$1 = [
		[
			"0",
			"\u0000",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		[
			"a2a1",
			""
		],
		[
			"a2ba",
			""
		],
		[
			"a2ca",
			""
		],
		[
			"a2dc",
			""
		],
		[
			"a2f2",
			""
		],
		[
			"a2fe",
			""
		],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a8a1",
			""
		],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		[
			"adc0",
			""
		],
		[
			"addf",
			"",
			4,
			""
		],
		[
			"b0a1",
			""
		],
		[
			"b1a1",
			""
		],
		[
			"b2a1",
			""
		],
		[
			"b3a1",
			""
		],
		[
			"b4a1",
			""
		],
		[
			"b5a1",
			""
		],
		[
			"b6a1",
			""
		],
		[
			"b7a1",
			""
		],
		[
			"b8a1",
			""
		],
		[
			"b9a1",
			""
		],
		[
			"baa1",
			""
		],
		[
			"bba1",
			""
		],
		[
			"bca1",
			""
		],
		[
			"bda1",
			""
		],
		[
			"bea1",
			""
		],
		[
			"bfa1",
			""
		],
		[
			"c0a1",
			""
		],
		[
			"c1a1",
			""
		],
		[
			"c2a1",
			""
		],
		[
			"c3a1",
			""
		],
		[
			"c4a1",
			""
		],
		[
			"c5a1",
			""
		],
		[
			"c6a1",
			""
		],
		[
			"c7a1",
			""
		],
		[
			"c8a1",
			""
		],
		[
			"c9a1",
			""
		],
		[
			"caa1",
			""
		],
		[
			"cba1",
			""
		],
		[
			"cca1",
			""
		],
		[
			"cda1",
			""
		],
		[
			"cea1",
			""
		],
		[
			"cfa1",
			""
		],
		[
			"d0a1",
			""
		],
		[
			"d1a1",
			""
		],
		[
			"d2a1",
			""
		],
		[
			"d3a1",
			""
		],
		[
			"d4a1",
			""
		],
		[
			"d5a1",
			""
		],
		[
			"d6a1",
			""
		],
		[
			"d7a1",
			""
		],
		[
			"d8a1",
			""
		],
		[
			"d9a1",
			""
		],
		[
			"daa1",
			""
		],
		[
			"dba1",
			""
		],
		[
			"dca1",
			""
		],
		[
			"dda1",
			""
		],
		[
			"dea1",
			""
		],
		[
			"dfa1",
			""
		],
		[
			"e0a1",
			""
		],
		[
			"e1a1",
			""
		],
		[
			"e2a1",
			""
		],
		[
			"e3a1",
			""
		],
		[
			"e4a1",
			""
		],
		[
			"e5a1",
			""
		],
		[
			"e6a1",
			""
		],
		[
			"e7a1",
			""
		],
		[
			"e8a1",
			""
		],
		[
			"e9a1",
			""
		],
		[
			"eaa1",
			""
		],
		[
			"eba1",
			""
		],
		[
			"eca1",
			""
		],
		[
			"eda1",
			""
		],
		[
			"eea1",
			""
		],
		[
			"efa1",
			""
		],
		[
			"f0a1",
			""
		],
		[
			"f1a1",
			""
		],
		[
			"f2a1",
			""
		],
		[
			"f3a1",
			""
		],
		[
			"f4a1",
			""
		],
		[
			"f9a1",
			""
		],
		[
			"faa1",
			""
		],
		[
			"fba1",
			""
		],
		[
			"fca1",
			""
		],
		[
			"fcf1",
			"",
			9,
			""
		],
		[
			"8fa2af",
			""
		],
		[
			"8fa2c2",
			""
		],
		[
			"8fa2eb",
			""
		],
		[
			"8fa6e1",
			""
		],
		[
			"8fa6e7",
			""
		],
		[
			"8fa6e9",
			""
		],
		[
			"8fa6ec",
			""
		],
		[
			"8fa6f1",
			""
		],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		[
			"8fa9a1",
			""
		],
		[
			"8fa9a4",
			""
		],
		[
			"8fa9a6",
			""
		],
		[
			"8fa9a8",
			""
		],
		[
			"8fa9ab",
			""
		],
		[
			"8fa9af",
			""
		],
		[
			"8fa9c1",
			""
		],
		[
			"8faaa1",
			""
		],
		[
			"8faaba",
			""
		],
		[
			"8faba1",
			""
		],
		[
			"8fabbd",
			""
		],
		[
			"8fabc5",
			""
		],
		[
			"8fb0a1",
			""
		],
		[
			"8fb1a1",
			""
		],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		[
			"8fb3a1",
			""
		],
		[
			"8fb4a1",
			""
		],
		[
			"8fb5a1",
			""
		],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		[
			"8fb8a1",
			""
		],
		[
			"8fb9a1",
			""
		],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		[
			"8fbba1",
			""
		],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		[
			"8fbfa1",
			""
		],
		[
			"8fc0a1",
			""
		],
		[
			"8fc1a1",
			""
		],
		[
			"8fc2a1",
			""
		],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		[
			"8fc4a1",
			""
		],
		[
			"8fc5a1",
			""
		],
		[
			"8fc6a1",
			""
		],
		[
			"8fc7a1",
			""
		],
		[
			"8fc8a1",
			""
		],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		[
			"8fcaa1",
			""
		],
		[
			"8fcba1",
			""
		],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		[
			"8fcfa1",
			""
		],
		[
			"8fd0a1",
			""
		],
		[
			"8fd1a1",
			""
		],
		[
			"8fd2a1",
			"",
			5
		],
		[
			"8fd3a1",
			""
		],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		[
			"8fd5a1",
			""
		],
		[
			"8fd6a1",
			""
		],
		[
			"8fd7a1",
			""
		],
		[
			"8fd8a1",
			""
		],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		[
			"8fdfa1",
			""
		],
		[
			"8fe0a1",
			""
		],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		[
			"8fe2a1",
			""
		],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		[
			"8fe6a1",
			""
		],
		[
			"8fe7a1",
			""
		],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		[
			"8feca1",
			""
		],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];

	var require$$2$1 = [
		[
			"0",
			"\u0000",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a6e0",
			""
		],
		[
			"a6ee",
			""
		],
		[
			"a6f4",
			""
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		[
			"a8a1",
			""
		],
		[
			"a8bd",
			""
		],
		[
			"a8c0",
			""
		],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		[
			"a959",
			""
		],
		[
			"a95c",
			""
		],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		[
			"a996",
			""
		],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		[
			"af80",
			""
		],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c640",
			""
		],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"c780",
			""
		],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		[
			"cd80",
			""
		],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		[
			"fe40",
			""
		]
	];

	var require$$3 = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		[
			"a2e3",
			""
		],
		[
			"a2ef",
			""
		],
		[
			"a2fd",
			""
		],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		[
			"a6ec",
			""
		],
		[
			"a6f3",
			""
		],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		[
			"a8bc",
			""
		],
		[
			"a8bf",
			""
		],
		[
			"a8c1",
			""
		],
		[
			"a8ea",
			"",
			20
		],
		[
			"a958",
			""
		],
		[
			"a95b",
			""
		],
		[
			"a95d",
			""
		],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		[
			"fe50",
			""
		],
		[
			"fe80",
			"",
			6,
			"",
			93
		]
	];

	var uChars = [
		128,
		165,
		169,
		178,
		184,
		216,
		226,
		235,
		238,
		244,
		248,
		251,
		253,
		258,
		276,
		284,
		300,
		325,
		329,
		334,
		364,
		463,
		465,
		467,
		469,
		471,
		473,
		475,
		477,
		506,
		594,
		610,
		712,
		716,
		730,
		930,
		938,
		962,
		970,
		1026,
		1104,
		1106,
		8209,
		8215,
		8218,
		8222,
		8231,
		8241,
		8244,
		8246,
		8252,
		8365,
		8452,
		8454,
		8458,
		8471,
		8482,
		8556,
		8570,
		8596,
		8602,
		8713,
		8720,
		8722,
		8726,
		8731,
		8737,
		8740,
		8742,
		8748,
		8751,
		8760,
		8766,
		8777,
		8781,
		8787,
		8802,
		8808,
		8816,
		8854,
		8858,
		8870,
		8896,
		8979,
		9322,
		9372,
		9548,
		9588,
		9616,
		9622,
		9634,
		9652,
		9662,
		9672,
		9676,
		9680,
		9702,
		9735,
		9738,
		9793,
		9795,
		11906,
		11909,
		11913,
		11917,
		11928,
		11944,
		11947,
		11951,
		11956,
		11960,
		11964,
		11979,
		12284,
		12292,
		12312,
		12319,
		12330,
		12351,
		12436,
		12447,
		12535,
		12543,
		12586,
		12842,
		12850,
		12964,
		13200,
		13215,
		13218,
		13253,
		13263,
		13267,
		13270,
		13384,
		13428,
		13727,
		13839,
		13851,
		14617,
		14703,
		14801,
		14816,
		14964,
		15183,
		15471,
		15585,
		16471,
		16736,
		17208,
		17325,
		17330,
		17374,
		17623,
		17997,
		18018,
		18212,
		18218,
		18301,
		18318,
		18760,
		18811,
		18814,
		18820,
		18823,
		18844,
		18848,
		18872,
		19576,
		19620,
		19738,
		19887,
		40870,
		59244,
		59336,
		59367,
		59413,
		59417,
		59423,
		59431,
		59437,
		59443,
		59452,
		59460,
		59478,
		59493,
		63789,
		63866,
		63894,
		63976,
		63986,
		64016,
		64018,
		64021,
		64025,
		64034,
		64037,
		64042,
		65074,
		65093,
		65107,
		65112,
		65127,
		65132,
		65375,
		65510,
		65536
	];
	var gbChars = [
		0,
		36,
		38,
		45,
		50,
		81,
		89,
		95,
		96,
		100,
		103,
		104,
		105,
		109,
		126,
		133,
		148,
		172,
		175,
		179,
		208,
		306,
		307,
		308,
		309,
		310,
		311,
		312,
		313,
		341,
		428,
		443,
		544,
		545,
		558,
		741,
		742,
		749,
		750,
		805,
		819,
		820,
		7922,
		7924,
		7925,
		7927,
		7934,
		7943,
		7944,
		7945,
		7950,
		8062,
		8148,
		8149,
		8152,
		8164,
		8174,
		8236,
		8240,
		8262,
		8264,
		8374,
		8380,
		8381,
		8384,
		8388,
		8390,
		8392,
		8393,
		8394,
		8396,
		8401,
		8406,
		8416,
		8419,
		8424,
		8437,
		8439,
		8445,
		8482,
		8485,
		8496,
		8521,
		8603,
		8936,
		8946,
		9046,
		9050,
		9063,
		9066,
		9076,
		9092,
		9100,
		9108,
		9111,
		9113,
		9131,
		9162,
		9164,
		9218,
		9219,
		11329,
		11331,
		11334,
		11336,
		11346,
		11361,
		11363,
		11366,
		11370,
		11372,
		11375,
		11389,
		11682,
		11686,
		11687,
		11692,
		11694,
		11714,
		11716,
		11723,
		11725,
		11730,
		11736,
		11982,
		11989,
		12102,
		12336,
		12348,
		12350,
		12384,
		12393,
		12395,
		12397,
		12510,
		12553,
		12851,
		12962,
		12973,
		13738,
		13823,
		13919,
		13933,
		14080,
		14298,
		14585,
		14698,
		15583,
		15847,
		16318,
		16434,
		16438,
		16481,
		16729,
		17102,
		17122,
		17315,
		17320,
		17402,
		17418,
		17859,
		17909,
		17911,
		17915,
		17916,
		17936,
		17939,
		17961,
		18664,
		18703,
		18814,
		18962,
		19043,
		33469,
		33470,
		33471,
		33484,
		33485,
		33490,
		33497,
		33501,
		33505,
		33513,
		33520,
		33536,
		33550,
		37845,
		37921,
		37948,
		38029,
		38038,
		38064,
		38065,
		38066,
		38069,
		38075,
		38076,
		38078,
		39108,
		39109,
		39113,
		39114,
		39115,
		39116,
		39265,
		39394,
		189000
	];
	var require$$4 = {
		uChars: uChars,
		gbChars: gbChars
	};

	var require$$5 = [
		[
			"0",
			"\u0000",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		[
			"a8a6",
			""
		],
		[
			"a8a8",
			""
		],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		[
			"c6a1",
			""
		],
		[
			"c7a1",
			""
		],
		[
			"c8a1",
			""
		],
		[
			"caa1",
			""
		],
		[
			"cba1",
			""
		],
		[
			"cca1",
			""
		],
		[
			"cda1",
			""
		],
		[
			"cea1",
			""
		],
		[
			"cfa1",
			""
		],
		[
			"d0a1",
			""
		],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		[
			"d3a1",
			""
		],
		[
			"d4a1",
			""
		],
		[
			"d5a1",
			""
		],
		[
			"d6a1",
			""
		],
		[
			"d7a1",
			""
		],
		[
			"d8a1",
			""
		],
		[
			"d9a1",
			""
		],
		[
			"daa1",
			""
		],
		[
			"dba1",
			""
		],
		[
			"dca1",
			""
		],
		[
			"dda1",
			""
		],
		[
			"dea1",
			""
		],
		[
			"dfa1",
			""
		],
		[
			"e0a1",
			""
		],
		[
			"e1a1",
			""
		],
		[
			"e2a1",
			""
		],
		[
			"e3a1",
			""
		],
		[
			"e4a1",
			""
		],
		[
			"e5a1",
			""
		],
		[
			"e6a1",
			""
		],
		[
			"e7a1",
			""
		],
		[
			"e8a1",
			""
		],
		[
			"e9a1",
			""
		],
		[
			"eaa1",
			""
		],
		[
			"eba1",
			""
		],
		[
			"eca1",
			""
		],
		[
			"eda1",
			""
		],
		[
			"eea1",
			""
		],
		[
			"efa1",
			""
		],
		[
			"f0a1",
			""
		],
		[
			"f1a1",
			""
		],
		[
			"f2a1",
			""
		],
		[
			"f3a1",
			""
		],
		[
			"f4a1",
			""
		],
		[
			"f5a1",
			""
		],
		[
			"f6a1",
			""
		],
		[
			"f7a1",
			""
		],
		[
			"f8a1",
			""
		],
		[
			"f9a1",
			""
		],
		[
			"faa1",
			""
		],
		[
			"fba1",
			""
		],
		[
			"fca1",
			""
		],
		[
			"fda1",
			""
		]
	];

	var require$$6 = [
		[
			"0",
			"\u0000",
			127
		],
		[
			"a140",
			""
		],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		[
			"a3e1",
			""
		],
		[
			"a440",
			""
		],
		[
			"a4a1",
			""
		],
		[
			"a540",
			""
		],
		[
			"a5a1",
			""
		],
		[
			"a640",
			""
		],
		[
			"a6a1",
			""
		],
		[
			"a740",
			""
		],
		[
			"a7a1",
			""
		],
		[
			"a840",
			""
		],
		[
			"a8a1",
			""
		],
		[
			"a940",
			""
		],
		[
			"a9a1",
			""
		],
		[
			"aa40",
			""
		],
		[
			"aaa1",
			""
		],
		[
			"ab40",
			""
		],
		[
			"aba1",
			""
		],
		[
			"ac40",
			""
		],
		[
			"aca1",
			""
		],
		[
			"ad40",
			""
		],
		[
			"ada1",
			""
		],
		[
			"ae40",
			""
		],
		[
			"aea1",
			""
		],
		[
			"af40",
			""
		],
		[
			"afa1",
			""
		],
		[
			"b040",
			""
		],
		[
			"b0a1",
			""
		],
		[
			"b140",
			""
		],
		[
			"b1a1",
			""
		],
		[
			"b240",
			""
		],
		[
			"b2a1",
			""
		],
		[
			"b340",
			""
		],
		[
			"b3a1",
			""
		],
		[
			"b440",
			""
		],
		[
			"b4a1",
			""
		],
		[
			"b540",
			""
		],
		[
			"b5a1",
			""
		],
		[
			"b640",
			""
		],
		[
			"b6a1",
			""
		],
		[
			"b740",
			""
		],
		[
			"b7a1",
			""
		],
		[
			"b840",
			""
		],
		[
			"b8a1",
			""
		],
		[
			"b940",
			""
		],
		[
			"b9a1",
			""
		],
		[
			"ba40",
			""
		],
		[
			"baa1",
			""
		],
		[
			"bb40",
			""
		],
		[
			"bba1",
			""
		],
		[
			"bc40",
			""
		],
		[
			"bca1",
			""
		],
		[
			"bd40",
			""
		],
		[
			"bda1",
			""
		],
		[
			"be40",
			""
		],
		[
			"bea1",
			""
		],
		[
			"bf40",
			""
		],
		[
			"bfa1",
			""
		],
		[
			"c040",
			""
		],
		[
			"c0a1",
			""
		],
		[
			"c140",
			""
		],
		[
			"c1a1",
			""
		],
		[
			"c240",
			""
		],
		[
			"c2a1",
			""
		],
		[
			"c340",
			""
		],
		[
			"c3a1",
			""
		],
		[
			"c440",
			""
		],
		[
			"c4a1",
			""
		],
		[
			"c540",
			""
		],
		[
			"c5a1",
			""
		],
		[
			"c640",
			""
		],
		[
			"c940",
			""
		],
		[
			"c9a1",
			""
		],
		[
			"ca40",
			""
		],
		[
			"caa1",
			""
		],
		[
			"cb40",
			""
		],
		[
			"cba1",
			""
		],
		[
			"cc40",
			""
		],
		[
			"cca1",
			""
		],
		[
			"cd40",
			""
		],
		[
			"cda1",
			""
		],
		[
			"ce40",
			""
		],
		[
			"cea1",
			""
		],
		[
			"cf40",
			""
		],
		[
			"cfa1",
			""
		],
		[
			"d040",
			""
		],
		[
			"d0a1",
			""
		],
		[
			"d140",
			""
		],
		[
			"d1a1",
			""
		],
		[
			"d240",
			""
		],
		[
			"d2a1",
			""
		],
		[
			"d340",
			""
		],
		[
			"d3a1",
			""
		],
		[
			"d440",
			""
		],
		[
			"d4a1",
			""
		],
		[
			"d540",
			""
		],
		[
			"d5a1",
			""
		],
		[
			"d640",
			""
		],
		[
			"d6a1",
			""
		],
		[
			"d740",
			""
		],
		[
			"d7a1",
			""
		],
		[
			"d840",
			""
		],
		[
			"d8a1",
			""
		],
		[
			"d940",
			""
		],
		[
			"d9a1",
			""
		],
		[
			"da40",
			""
		],
		[
			"daa1",
			""
		],
		[
			"db40",
			""
		],
		[
			"dba1",
			""
		],
		[
			"dc40",
			""
		],
		[
			"dca1",
			""
		],
		[
			"dd40",
			""
		],
		[
			"dda1",
			""
		],
		[
			"de40",
			""
		],
		[
			"dea1",
			""
		],
		[
			"df40",
			""
		],
		[
			"dfa1",
			""
		],
		[
			"e040",
			""
		],
		[
			"e0a1",
			""
		],
		[
			"e140",
			""
		],
		[
			"e1a1",
			""
		],
		[
			"e240",
			""
		],
		[
			"e2a1",
			""
		],
		[
			"e340",
			""
		],
		[
			"e3a1",
			""
		],
		[
			"e440",
			""
		],
		[
			"e4a1",
			""
		],
		[
			"e540",
			""
		],
		[
			"e5a1",
			""
		],
		[
			"e640",
			""
		],
		[
			"e6a1",
			""
		],
		[
			"e740",
			""
		],
		[
			"e7a1",
			""
		],
		[
			"e840",
			""
		],
		[
			"e8a1",
			""
		],
		[
			"e940",
			""
		],
		[
			"e9a1",
			""
		],
		[
			"ea40",
			""
		],
		[
			"eaa1",
			""
		],
		[
			"eb40",
			""
		],
		[
			"eba1",
			""
		],
		[
			"ec40",
			""
		],
		[
			"eca1",
			""
		],
		[
			"ed40",
			""
		],
		[
			"eda1",
			""
		],
		[
			"ee40",
			""
		],
		[
			"eea1",
			""
		],
		[
			"ef40",
			""
		],
		[
			"efa1",
			""
		],
		[
			"f040",
			""
		],
		[
			"f0a1",
			""
		],
		[
			"f140",
			""
		],
		[
			"f1a1",
			""
		],
		[
			"f240",
			""
		],
		[
			"f2a1",
			""
		],
		[
			"f340",
			""
		],
		[
			"f3a1",
			""
		],
		[
			"f440",
			""
		],
		[
			"f4a1",
			""
		],
		[
			"f540",
			""
		],
		[
			"f5a1",
			""
		],
		[
			"f640",
			""
		],
		[
			"f6a1",
			""
		],
		[
			"f740",
			""
		],
		[
			"f7a1",
			""
		],
		[
			"f840",
			""
		],
		[
			"f8a1",
			""
		],
		[
			"f940",
			""
		],
		[
			"f9a1",
			""
		]
	];

	var require$$7 = [
		[
			"8740",
			""
		],
		[
			"8767",
			""
		],
		[
			"87a1",
			""
		],
		[
			"8840",
			"",
			4,
			""
		],
		[
			"88a1",
			""
		],
		[
			"8940",
			""
		],
		[
			"8943",
			""
		],
		[
			"8946",
			""
		],
		[
			"894c",
			""
		],
		[
			"89a1",
			""
		],
		[
			"89ab",
			""
		],
		[
			"89b0",
			""
		],
		[
			"89b5",
			""
		],
		[
			"89c1",
			""
		],
		[
			"89c5",
			""
		],
		[
			"8a40",
			""
		],
		[
			"8a43",
			""
		],
		[
			"8a64",
			""
		],
		[
			"8a76",
			""
		],
		[
			"8aa1",
			""
		],
		[
			"8aac",
			""
		],
		[
			"8ab2",
			""
		],
		[
			"8abb",
			""
		],
		[
			"8ac9",
			""
		],
		[
			"8ace",
			""
		],
		[
			"8adf",
			""
		],
		[
			"8af6",
			""
		],
		[
			"8b40",
			""
		],
		[
			"8b55",
			""
		],
		[
			"8ba1",
			""
		],
		[
			"8bde",
			""
		],
		[
			"8c40",
			""
		],
		[
			"8ca1",
			""
		],
		[
			"8ca7",
			""
		],
		[
			"8cc9",
			""
		],
		[
			"8cce",
			""
		],
		[
			"8ce6",
			""
		],
		[
			"8d40",
			""
		],
		[
			"8d42",
			""
		],
		[
			"8da1",
			""
		],
		[
			"8e40",
			""
		],
		[
			"8ea1",
			""
		],
		[
			"8f40",
			""
		],
		[
			"8fa1",
			""
		],
		[
			"9040",
			""
		],
		[
			"90a1",
			""
		],
		[
			"9140",
			""
		],
		[
			"91a1",
			""
		],
		[
			"9240",
			""
		],
		[
			"92a1",
			""
		],
		[
			"9340",
			""
		],
		[
			"93a1",
			""
		],
		[
			"9440",
			""
		],
		[
			"94a1",
			""
		],
		[
			"9540",
			""
		],
		[
			"95a1",
			""
		],
		[
			"9640",
			""
		],
		[
			"96a1",
			""
		],
		[
			"9740",
			""
		],
		[
			"97a1",
			""
		],
		[
			"9840",
			""
		],
		[
			"98a1",
			""
		],
		[
			"9940",
			""
		],
		[
			"99a1",
			""
		],
		[
			"9a40",
			""
		],
		[
			"9aa1",
			""
		],
		[
			"9b40",
			""
		],
		[
			"9b62",
			""
		],
		[
			"9ba1",
			""
		],
		[
			"9c40",
			""
		],
		[
			"9ca1",
			""
		],
		[
			"9d40",
			""
		],
		[
			"9da1",
			""
		],
		[
			"9e40",
			""
		],
		[
			"9ea1",
			""
		],
		[
			"9ead",
			""
		],
		[
			"9ec5",
			""
		],
		[
			"9ef5",
			""
		],
		[
			"9f40",
			""
		],
		[
			"9f4f",
			""
		],
		[
			"9fa1",
			""
		],
		[
			"9fae",
			""
		],
		[
			"9fb2",
			""
		],
		[
			"9fc1",
			""
		],
		[
			"9fc9",
			""
		],
		[
			"9fdb",
			""
		],
		[
			"9fe7",
			""
		],
		[
			"9feb",
			""
		],
		[
			"9ff0",
			""
		],
		[
			"a040",
			""
		],
		[
			"a055",
			""
		],
		[
			"a058",
			""
		],
		[
			"a05b",
			""
		],
		[
			"a063",
			""
		],
		[
			"a073",
			""
		],
		[
			"a0a1",
			""
		],
		[
			"a0a6",
			""
		],
		[
			"a0ae",
			""
		],
		[
			"a0b0",
			""
		],
		[
			"a0d4",
			""
		],
		[
			"a0e2",
			""
		],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		[
			"c8a1",
			""
		],
		[
			"c8cd",
			""
		],
		[
			"c8f5",
			""
		],
		[
			"f9fe",
			""
		],
		[
			"fa40",
			""
		],
		[
			"faa1",
			""
		],
		[
			"fb40",
			""
		],
		[
			"fba1",
			""
		],
		[
			"fc40",
			""
		],
		[
			"fca1",
			""
		],
		[
			"fd40",
			""
		],
		[
			"fda1",
			""
		],
		[
			"fe40",
			""
		],
		[
			"fea1",
			""
		]
	];

	var dbcsData;
	var hasRequiredDbcsData;
	function requireDbcsData() {
	  if (hasRequiredDbcsData) return dbcsData;
	  hasRequiredDbcsData = 1;

	  // Description of supported double byte encodings and aliases.
	  // Tables are not require()-d until they are needed to speed up library load.
	  // require()-s are direct to support Browserify.

	  dbcsData = {
	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

	    'shiftjis': {
	      type: '_dbcs',
	      table: function () {
	        return require$$0;
	      },
	      encodeAdd: {
	        '\u00a5': 0x5C,
	        '\u203E': 0x7E
	      },
	      encodeSkipVals: [{
	        from: 0xED40,
	        to: 0xF940
	      }]
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'ms31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    'ms932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',
	    'eucjp': {
	      type: '_dbcs',
	      table: function () {
	        return require$$1;
	      },
	      encodeAdd: {
	        '\u00a5': 0x5C,
	        '\u203E': 0x7E
	      }
	    },
	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK
	    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',
	    // Microsoft's CP936 is a subset and approximation of GBK.
	    'windows936': 'cp936',
	    'ms936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	      type: '_dbcs',
	      table: function () {
	        return require$$2$1;
	      }
	    },
	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	      type: '_dbcs',
	      table: function () {
	        return require$$2$1.concat(require$$3);
	      }
	    },
	    'xgbk': 'gbk',
	    'isoir58': 'gbk',
	    // GB18030 is an algorithmic extension of GBK.
	    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	    'gb18030': {
	      type: '_dbcs',
	      table: function () {
	        return require$$2$1.concat(require$$3);
	      },
	      gb18030: function () {
	        return require$$4;
	      },
	      encodeSkipVals: [0x80],
	      encodeAdd: {
	        '': 0xA2E3
	      }
	    },
	    'chinese': 'gb18030',
	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    'ms949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	      type: '_dbcs',
	      table: function () {
	        return require$$5;
	      }
	    },
	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',
	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	    'windows950': 'cp950',
	    'ms950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	      type: '_dbcs',
	      table: function () {
	        return require$$6;
	      }
	    },
	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	      type: '_dbcs',
	      table: function () {
	        return require$$6.concat(require$$7);
	      },
	      encodeSkipVals: [0xa2cc]
	    },
	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs'
	  };
	  return dbcsData;
	}

	var hasRequiredEncodings;
	function requireEncodings() {
	  if (hasRequiredEncodings) return encodings;
	  hasRequiredEncodings = 1;
	  (function (exports) {

	    // Update this array if you add/rename/remove files in this directory.
	    // We support Browserify by skipping automatic module discovery and requiring modules directly.
	    var modules = [requireInternal(), requireUtf16(), requireUtf7(), requireSbcsCodec(), requireSbcsData(), requireSbcsDataGenerated(), requireDbcsCodec(), requireDbcsData()];

	    // Put all encoding/alias/codec definitions to single object and export it. 
	    for (var i = 0; i < modules.length; i++) {
	      var module = modules[i];
	      for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
	    }
	  })(encodings);
	  return encodings;
	}

	var streams;
	var hasRequiredStreams;
	function requireStreams() {
	  if (hasRequiredStreams) return streams;
	  hasRequiredStreams = 1;
	  var Buffer = require$$0$1.Buffer,
	    Transform = require$$0$5.Transform;

	  // == Exports ==================================================================
	  streams = function (iconv) {
	    // Additional Public API.
	    iconv.encodeStream = function encodeStream(encoding, options) {
	      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
	    };
	    iconv.decodeStream = function decodeStream(encoding, options) {
	      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
	    };
	    iconv.supportsStreams = true;

	    // Not published yet.
	    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
	    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
	    iconv._collect = IconvLiteDecoderStream.prototype.collect;
	  };

	  // == Encoder stream =======================================================
	  function IconvLiteEncoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	  }
	  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: {
	      value: IconvLiteEncoderStream
	    }
	  });
	  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
	    try {
	      var res = this.conv.write(chunk);
	      if (res && res.length) this.push(res);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };
	  IconvLiteEncoderStream.prototype._flush = function (done) {
	    try {
	      var res = this.conv.end();
	      if (res && res.length) this.push(res);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };
	  IconvLiteEncoderStream.prototype.collect = function (cb) {
	    var chunks = [];
	    this.on('error', cb);
	    this.on('data', function (chunk) {
	      chunks.push(chunk);
	    });
	    this.on('end', function () {
	      cb(null, Buffer.concat(chunks));
	    });
	    return this;
	  };

	  // == Decoder stream =======================================================
	  function IconvLiteDecoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = 'utf8'; // We output strings.
	    Transform.call(this, options);
	  }
	  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: {
	      value: IconvLiteDecoderStream
	    }
	  });
	  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
	    try {
	      var res = this.conv.write(chunk);
	      if (res && res.length) this.push(res, this.encoding);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };
	  IconvLiteDecoderStream.prototype._flush = function (done) {
	    try {
	      var res = this.conv.end();
	      if (res && res.length) this.push(res, this.encoding);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };
	  IconvLiteDecoderStream.prototype.collect = function (cb) {
	    var res = '';
	    this.on('error', cb);
	    this.on('data', function (chunk) {
	      res += chunk;
	    });
	    this.on('end', function () {
	      cb(null, res);
	    });
	    return this;
	  };
	  return streams;
	}

	var extendNode;
	var hasRequiredExtendNode;
	function requireExtendNode() {
	  if (hasRequiredExtendNode) return extendNode;
	  hasRequiredExtendNode = 1;
	  var Buffer = require$$0$1.Buffer;
	  // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

	  // == Extend Node primitives to use iconv-lite =================================

	  extendNode = function (iconv) {
	    var original = undefined; // Place to keep original methods.

	    // Node authors rewrote Buffer internals to make it compatible with
	    // Uint8Array and we cannot patch key functions since then.
	    // Note: this does use older Buffer API on a purpose
	    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);
	    iconv.extendNodeEncodings = function extendNodeEncodings() {
	      if (original) return;
	      original = {};
	      if (!iconv.supportsNodeEncodingsExtension) {
	        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
	        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
	        return;
	      }
	      var nodeNativeEncodings = {
	        'hex': true,
	        'utf8': true,
	        'utf-8': true,
	        'ascii': true,
	        'binary': true,
	        'base64': true,
	        'ucs2': true,
	        'ucs-2': true,
	        'utf16le': true,
	        'utf-16le': true
	      };
	      Buffer.isNativeEncoding = function (enc) {
	        return enc && nodeNativeEncodings[enc.toLowerCase()];
	      };

	      // -- SlowBuffer -----------------------------------------------------------
	      var SlowBuffer = require$$0$1.SlowBuffer;
	      original.SlowBufferToString = SlowBuffer.prototype.toString;
	      SlowBuffer.prototype.toString = function (encoding, start, end) {
	        encoding = String(encoding || 'utf8').toLowerCase();

	        // Use native conversion when possible
	        if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

	        // Otherwise, use our decoding method.
	        if (typeof start == 'undefined') start = 0;
	        if (typeof end == 'undefined') end = this.length;
	        return iconv.decode(this.slice(start, end), encoding);
	      };
	      original.SlowBufferWrite = SlowBuffer.prototype.write;
	      SlowBuffer.prototype.write = function (string, offset, length, encoding) {
	        // Support both (string, offset, length, encoding)
	        // and the legacy (string, encoding, offset, length)
	        if (isFinite(offset)) {
	          if (!isFinite(length)) {
	            encoding = length;
	            length = undefined;
	          }
	        } else {
	          // legacy
	          var swap = encoding;
	          encoding = offset;
	          offset = length;
	          length = swap;
	        }
	        offset = +offset || 0;
	        var remaining = this.length - offset;
	        if (!length) {
	          length = remaining;
	        } else {
	          length = +length;
	          if (length > remaining) {
	            length = remaining;
	          }
	        }
	        encoding = String(encoding || 'utf8').toLowerCase();

	        // Use native conversion when possible
	        if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
	        if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

	        // Otherwise, use our encoding method.
	        var buf = iconv.encode(string, encoding);
	        if (buf.length < length) length = buf.length;
	        buf.copy(this, offset, 0, length);
	        return length;
	      };

	      // -- Buffer ---------------------------------------------------------------

	      original.BufferIsEncoding = Buffer.isEncoding;
	      Buffer.isEncoding = function (encoding) {
	        return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
	      };
	      original.BufferByteLength = Buffer.byteLength;
	      Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {
	        encoding = String(encoding || 'utf8').toLowerCase();

	        // Use native conversion when possible
	        if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);

	        // Slow, I know, but we don't have a better way yet.
	        return iconv.encode(str, encoding).length;
	      };
	      original.BufferToString = Buffer.prototype.toString;
	      Buffer.prototype.toString = function (encoding, start, end) {
	        encoding = String(encoding || 'utf8').toLowerCase();

	        // Use native conversion when possible
	        if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

	        // Otherwise, use our decoding method.
	        if (typeof start == 'undefined') start = 0;
	        if (typeof end == 'undefined') end = this.length;
	        return iconv.decode(this.slice(start, end), encoding);
	      };
	      original.BufferWrite = Buffer.prototype.write;
	      Buffer.prototype.write = function (string, offset, length, encoding) {
	        var _offset = offset,
	          _length = length,
	          _encoding = encoding;
	        // Support both (string, offset, length, encoding)
	        // and the legacy (string, encoding, offset, length)
	        if (isFinite(offset)) {
	          if (!isFinite(length)) {
	            encoding = length;
	            length = undefined;
	          }
	        } else {
	          // legacy
	          var swap = encoding;
	          encoding = offset;
	          offset = length;
	          length = swap;
	        }
	        encoding = String(encoding || 'utf8').toLowerCase();

	        // Use native conversion when possible
	        if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
	        offset = +offset || 0;
	        var remaining = this.length - offset;
	        if (!length) {
	          length = remaining;
	        } else {
	          length = +length;
	          if (length > remaining) {
	            length = remaining;
	          }
	        }
	        if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

	        // Otherwise, use our encoding method.
	        var buf = iconv.encode(string, encoding);
	        if (buf.length < length) length = buf.length;
	        buf.copy(this, offset, 0, length);
	        return length;

	        // TODO: Set _charsWritten.
	      };

	      // -- Readable -------------------------------------------------------------
	      if (iconv.supportsStreams) {
	        var Readable = require$$0$5.Readable;
	        original.ReadableSetEncoding = Readable.prototype.setEncoding;
	        Readable.prototype.setEncoding = function setEncoding(enc, options) {
	          // Use our own decoder, it has the same interface.
	          // We cannot use original function as it doesn't handle BOM-s.
	          this._readableState.decoder = iconv.getDecoder(enc, options);
	          this._readableState.encoding = enc;
	        };
	        Readable.prototype.collect = iconv._collect;
	      }
	    };

	    // Remove iconv-lite Node primitive extensions.
	    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
	      if (!iconv.supportsNodeEncodingsExtension) return;
	      if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
	      delete Buffer.isNativeEncoding;
	      var SlowBuffer = require$$0$1.SlowBuffer;
	      SlowBuffer.prototype.toString = original.SlowBufferToString;
	      SlowBuffer.prototype.write = original.SlowBufferWrite;
	      Buffer.isEncoding = original.BufferIsEncoding;
	      Buffer.byteLength = original.BufferByteLength;
	      Buffer.prototype.toString = original.BufferToString;
	      Buffer.prototype.write = original.BufferWrite;
	      if (iconv.supportsStreams) {
	        var Readable = require$$0$5.Readable;
	        Readable.prototype.setEncoding = original.ReadableSetEncoding;
	        delete Readable.prototype.collect;
	      }
	      original = undefined;
	    };
	  };
	  return extendNode;
	}

	(function (module) {

	  // Some environments don't have global Buffer (e.g. React Native).
	  // Solution would be installing npm modules "buffer" and "stream" explicitly.
	  var Buffer = safer_1.Buffer;
	  var bomHandling$1 = bomHandling,
	    iconv = module.exports;

	  // All codecs and aliases are kept here, keyed by encoding name/alias.
	  // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
	  iconv.encodings = null;

	  // Characters emitted in case of error.
	  iconv.defaultCharUnicode = '';
	  iconv.defaultCharSingleByte = '?';

	  // Public API.
	  iconv.encode = function encode(str, encoding, options) {
	    str = "" + (str || ""); // Ensure string.

	    var encoder = iconv.getEncoder(encoding, options);
	    var res = encoder.write(str);
	    var trail = encoder.end();
	    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
	  };
	  iconv.decode = function decode(buf, encoding, options) {
	    if (typeof buf === 'string') {
	      if (!iconv.skipDecodeWarning) {
	        console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
	        iconv.skipDecodeWarning = true;
	      }
	      buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
	    }
	    var decoder = iconv.getDecoder(encoding, options);
	    var res = decoder.write(buf);
	    var trail = decoder.end();
	    return trail ? res + trail : res;
	  };
	  iconv.encodingExists = function encodingExists(enc) {
	    try {
	      iconv.getCodec(enc);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  };

	  // Legacy aliases to convert functions
	  iconv.toEncoding = iconv.encode;
	  iconv.fromEncoding = iconv.decode;

	  // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
	  iconv._codecDataCache = {};
	  iconv.getCodec = function getCodec(encoding) {
	    if (!iconv.encodings) iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.

	    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	    var enc = iconv._canonicalizeEncoding(encoding);

	    // Traverse iconv.encodings to find actual codec.
	    var codecOptions = {};
	    while (true) {
	      var codec = iconv._codecDataCache[enc];
	      if (codec) return codec;
	      var codecDef = iconv.encodings[enc];
	      switch (typeof codecDef) {
	        case "string":
	          // Direct alias to other encoding.
	          enc = codecDef;
	          break;
	        case "object":
	          // Alias with options. Can be layered.
	          for (var key in codecDef) codecOptions[key] = codecDef[key];
	          if (!codecOptions.encodingName) codecOptions.encodingName = enc;
	          enc = codecDef.type;
	          break;
	        case "function":
	          // Codec itself.
	          if (!codecOptions.encodingName) codecOptions.encodingName = enc;

	          // The codec function must load all tables and return object with .encoder and .decoder methods.
	          // It'll be called only once (for each different options object).
	          codec = new codecDef(codecOptions, iconv);
	          iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
	          return codec;
	        default:
	          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
	      }
	    }
	  };
	  iconv._canonicalizeEncoding = function (encoding) {
	    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	    return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	  };
	  iconv.getEncoder = function getEncoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	      encoder = new codec.encoder(options, codec);
	    if (codec.bomAware && options && options.addBOM) encoder = new bomHandling$1.PrependBOM(encoder, options);
	    return encoder;
	  };
	  iconv.getDecoder = function getDecoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	      decoder = new codec.decoder(options, codec);
	    if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling$1.StripBOM(decoder, options);
	    return decoder;
	  };

	  // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
	  var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
	  if (nodeVer) {
	    // Load streaming support in Node v0.10+
	    var nodeVerArr = nodeVer.split(".").map(Number);
	    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
	      requireStreams()(iconv);
	    }

	    // Load Node primitive extensions.
	    requireExtendNode()(iconv);
	  }
	})(lib$1);
	var libExports = lib$1.exports;

	var tmp = {};

	var _polyfillNode_crypto = {};

	var _polyfillNode_crypto$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _polyfillNode_crypto
	});

	var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_crypto$1);

	var isWindows = process.platform === 'win32';
	var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;

	// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
	var osTmpdir = function () {
	  var path;
	  if (isWindows) {
	    path = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + '\\temp';
	  } else {
	    path = process.env.TMPDIR || process.env.TMP || process.env.TEMP || '/tmp';
	  }
	  if (trailingSlashRe.test(path)) {
	    path = path.slice(0, -1);
	  }
	  return path;
	};

	/*!
	 * Tmp
	 *
	 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
	 *
	 * MIT Licensed
	 */

	/*
	 * Module dependencies.
	 */
	const fs = require$$2$2;
	const path = require$$1$4;
	const crypto = require$$2;
	const osTmpDir = osTmpdir;
	const _c = process.binding('constants');

	/*
	 * The working inner variables.
	 */
	const
	  /**
	   * The temporary directory.
	   * @type {string}
	   */
	  tmpDir = osTmpDir(),
	  // the random characters to choose from
	  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	  TEMPLATE_PATTERN = /XXXXXX/,
	  DEFAULT_TRIES = 3,
	  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),
	  EBADF = _c.EBADF || _c.os.errno.EBADF,
	  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
	  DIR_MODE = 448 /* 0o700 */,
	  FILE_MODE = 384 /* 0o600 */,
	  // this will hold the objects need to be removed on exit
	  _removeObjects = [];
	var _gracefulCleanup = false,
	  _uncaughtException = false;

	/**
	 * Random name generator based on crypto.
	 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
	 *
	 * @param {number} howMany
	 * @returns {string} the generated random name
	 * @private
	 */
	function _randomChars(howMany) {
	  var value = [],
	    rnd = null;

	  // make sure that we do not fail because we ran out of entropy
	  try {
	    rnd = crypto.randomBytes(howMany);
	  } catch (e) {
	    rnd = crypto.pseudoRandomBytes(howMany);
	  }
	  for (var i = 0; i < howMany; i++) {
	    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
	  }
	  return value.join('');
	}

	/**
	 * Checks whether the `obj` parameter is defined or not.
	 *
	 * @param {Object} obj
	 * @returns {boolean} true if the object is undefined
	 * @private
	 */
	function _isUndefined(obj) {
	  return typeof obj === 'undefined';
	}

	/**
	 * Parses the function arguments.
	 *
	 * This function helps to have optional arguments.
	 *
	 * @param {(Options|Function)} options
	 * @param {Function} callback
	 * @returns {Array} parsed arguments
	 * @private
	 */
	function _parseArguments(options, callback) {
	  if (typeof options == 'function') {
	    return [callback || {}, options];
	  }
	  if (_isUndefined(options)) {
	    return [{}, callback];
	  }
	  return [options, callback];
	}

	/**
	 * Generates a new temporary name.
	 *
	 * @param {Object} opts
	 * @returns {string} the new random name according to opts
	 * @private
	 */
	function _generateTmpName(opts) {
	  if (opts.name) {
	    return path.join(opts.dir || tmpDir, opts.name);
	  }

	  // mkstemps like template
	  if (opts.template) {
	    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
	  }

	  // prefix and postfix
	  const name = [opts.prefix || 'tmp-', process.pid, _randomChars(12), opts.postfix || ''].join('');
	  return path.join(opts.dir || tmpDir, name);
	}

	/**
	 * Gets a temporary file name.
	 *
	 * @param {(Options|tmpNameCallback)} options options or callback
	 * @param {?tmpNameCallback} callback the callback function
	 */
	function tmpName(options, callback) {
	  var args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1],
	    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
	  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));
	  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error('Invalid template provided'));
	  (function _getUniqueName() {
	    const name = _generateTmpName(opts);

	    // check whether the path exists then retry if needed
	    fs.stat(name, function (err) {
	      if (!err) {
	        if (tries-- > 0) return _getUniqueName();
	        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
	      }
	      cb(null, name);
	    });
	  })();
	}

	/**
	 * Synchronous version of tmpName.
	 *
	 * @param {Object} options
	 * @returns {string} the generated random name
	 * @throws {Error} if the options are invalid or could not generate a filename
	 */
	function tmpNameSync(options) {
	  var args = _parseArguments(options),
	    opts = args[0],
	    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
	  if (isNaN(tries) || tries < 0) throw new Error('Invalid tries');
	  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error('Invalid template provided');
	  do {
	    const name = _generateTmpName(opts);
	    try {
	      fs.statSync(name);
	    } catch (e) {
	      return name;
	    }
	  } while (tries-- > 0);
	  throw new Error('Could not get a unique tmp filename, max tries reached');
	}

	/**
	 * Creates and opens a temporary file.
	 *
	 * @param {(Options|fileCallback)} options the config options or the callback function
	 * @param {?fileCallback} callback
	 */
	function file(options, callback) {
	  var args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1];
	  opts.postfix = _isUndefined(opts.postfix) ? '.tmp' : opts.postfix;

	  // gets a temporary filename
	  tmpName(opts, function _tmpNameCreated(err, name) {
	    if (err) return cb(err);

	    // create and open the file
	    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
	      if (err) return cb(err);
	      if (opts.discardDescriptor) {
	        return fs.close(fd, function _discardCallback(err) {
	          if (err) {
	            // Low probability, and the file exists, so this could be
	            // ignored.  If it isn't we certainly need to unlink the
	            // file, and if that fails too its error is more
	            // important.
	            try {
	              fs.unlinkSync(name);
	            } catch (e) {
	              if (!isENOENT(e)) {
	                err = e;
	              }
	            }
	            return cb(err);
	          }
	          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
	        });
	      }
	      if (opts.detachDescriptor) {
	        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
	      }
	      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
	    });
	  });
	}

	/**
	 * Synchronous version of file.
	 *
	 * @param {Options} options
	 * @returns {FileSyncObject} object consists of name, fd and removeCallback
	 * @throws {Error} if cannot create a file
	 */
	function fileSync(options) {
	  var args = _parseArguments(options),
	    opts = args[0];
	  opts.postfix = opts.postfix || '.tmp';
	  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
	  const name = tmpNameSync(opts);
	  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
	  if (opts.discardDescriptor) {
	    fs.closeSync(fd);
	    fd = undefined;
	  }
	  return {
	    name: name,
	    fd: fd,
	    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
	  };
	}

	/**
	 * Removes files and folders in a directory recursively.
	 *
	 * @param {string} root
	 * @private
	 */
	function _rmdirRecursiveSync(root) {
	  const dirs = [root];
	  do {
	    var dir = dirs.pop(),
	      deferred = false,
	      files = fs.readdirSync(dir);
	    for (var i = 0, length = files.length; i < length; i++) {
	      var file = path.join(dir, files[i]),
	        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories

	      if (stat.isDirectory()) {
	        if (!deferred) {
	          deferred = true;
	          dirs.push(dir);
	        }
	        dirs.push(file);
	      } else {
	        fs.unlinkSync(file);
	      }
	    }
	    if (!deferred) {
	      fs.rmdirSync(dir);
	    }
	  } while (dirs.length !== 0);
	}

	/**
	 * Creates a temporary directory.
	 *
	 * @param {(Options|dirCallback)} options the options or the callback function
	 * @param {?dirCallback} callback
	 */
	function dir(options, callback) {
	  var args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1];

	  // gets a temporary filename
	  tmpName(opts, function _tmpNameCreated(err, name) {
	    if (err) return cb(err);

	    // create the directory
	    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
	      if (err) return cb(err);
	      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
	    });
	  });
	}

	/**
	 * Synchronous version of dir.
	 *
	 * @param {Options} options
	 * @returns {DirSyncObject} object consists of name and removeCallback
	 * @throws {Error} if it cannot create a directory
	 */
	function dirSync(options) {
	  var args = _parseArguments(options),
	    opts = args[0];
	  const name = tmpNameSync(opts);
	  fs.mkdirSync(name, opts.mode || DIR_MODE);
	  return {
	    name: name,
	    removeCallback: _prepareTmpDirRemoveCallback(name, opts)
	  };
	}

	/**
	 * Prepares the callback for removal of the temporary file.
	 *
	 * @param {string} name the path of the file
	 * @param {number} fd file descriptor
	 * @param {Object} opts
	 * @returns {fileCallback}
	 * @private
	 */
	function _prepareTmpFileRemoveCallback(name, fd, opts) {
	  const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {
	    try {
	      if (0 <= fdPath[0]) {
	        fs.closeSync(fdPath[0]);
	      }
	    } catch (e) {
	      // under some node/windows related circumstances, a temporary file
	      // may have not be created as expected or the file was already closed
	      // by the user, in which case we will simply ignore the error
	      if (!isEBADF(e) && !isENOENT(e)) {
	        // reraise any unanticipated error
	        throw e;
	      }
	    }
	    try {
	      fs.unlinkSync(fdPath[1]);
	    } catch (e) {
	      if (!isENOENT(e)) {
	        // reraise any unanticipated error
	        throw e;
	      }
	    }
	  }, [fd, name]);
	  if (!opts.keep) {
	    _removeObjects.unshift(removeCallback);
	  }
	  return removeCallback;
	}

	/**
	 * Prepares the callback for removal of the temporary directory.
	 *
	 * @param {string} name
	 * @param {Object} opts
	 * @returns {Function} the callback
	 * @private
	 */
	function _prepareTmpDirRemoveCallback(name, opts) {
	  const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);
	  const removeCallback = _prepareRemoveCallback(removeFunction, name);
	  if (!opts.keep) {
	    _removeObjects.unshift(removeCallback);
	  }
	  return removeCallback;
	}

	/**
	 * Creates a guarded function wrapping the removeFunction call.
	 *
	 * @param {Function} removeFunction
	 * @param {Object} arg
	 * @returns {Function}
	 * @private
	 */
	function _prepareRemoveCallback(removeFunction, arg) {
	  var called = false;
	  return function _cleanupCallback(next) {
	    if (!called) {
	      const index = _removeObjects.indexOf(_cleanupCallback);
	      if (index >= 0) {
	        _removeObjects.splice(index, 1);
	      }
	      called = true;
	      removeFunction(arg);
	    }
	    if (next) next(null);
	  };
	}

	/**
	 * The garbage collector.
	 *
	 * @private
	 */
	function _garbageCollector() {
	  if (_uncaughtException && !_gracefulCleanup) {
	    return;
	  }

	  // the function being called removes itself from _removeObjects,
	  // loop until _removeObjects is empty
	  while (_removeObjects.length) {
	    try {
	      _removeObjects[0].call(null);
	    } catch (e) {
	      // already removed?
	    }
	  }
	}

	/**
	 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
	 */
	function isEBADF(error) {
	  return isExpectedError(error, -EBADF, 'EBADF');
	}

	/**
	 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
	 */
	function isENOENT(error) {
	  return isExpectedError(error, -ENOENT, 'ENOENT');
	}

	/**
	 * Helper to determine whether the expected error code matches the actual code and errno,
	 * which will differ between the supported node versions.
	 *
	 * - Node >= 7.0:
	 *   error.code {String}
	 *   error.errno {String|Number} any numerical value will be negated
	 *
	 * - Node >= 6.0 < 7.0:
	 *   error.code {String}
	 *   error.errno {Number} negated
	 *
	 * - Node >= 4.0 < 6.0: introduces SystemError
	 *   error.code {String}
	 *   error.errno {Number} negated
	 *
	 * - Node >= 0.10 < 4.0:
	 *   error.code {Number} negated
	 *   error.errno n/a
	 */
	function isExpectedError(error, code, errno) {
	  return error.code == code || error.code == errno;
	}

	/**
	 * Sets the graceful cleanup.
	 *
	 * Also removes the created files and directories when an uncaught exception occurs.
	 */
	function setGracefulCleanup() {
	  _gracefulCleanup = true;
	}
	const version = process.versions.node.split('.').map(function (value) {
	  return parseInt(value, 10);
	});
	if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
	  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
	    _uncaughtException = true;
	    _garbageCollector();
	    throw err;
	  });
	}
	process.addListener('exit', function _exit(code) {
	  if (code) _uncaughtException = true;
	  _garbageCollector();
	});

	/**
	 * Configuration options.
	 *
	 * @typedef {Object} Options
	 * @property {?number} tries the number of tries before give up the name generation
	 * @property {?string} template the "mkstemp" like filename template
	 * @property {?string} name fix name
	 * @property {?string} dir the tmp directory to use
	 * @property {?string} prefix prefix for the generated name
	 * @property {?string} postfix postfix for the generated name
	 */

	/**
	 * @typedef {Object} FileSyncObject
	 * @property {string} name the name of the file
	 * @property {string} fd the file descriptor
	 * @property {fileCallback} removeCallback the callback function to remove the file
	 */

	/**
	 * @typedef {Object} DirSyncObject
	 * @property {string} name the name of the directory
	 * @property {fileCallback} removeCallback the callback function to remove the directory
	 */

	/**
	 * @callback tmpNameCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 */

	/**
	 * @callback fileCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 * @param {number} fd the file descriptor
	 * @param {cleanupCallback} fn the cleanup callback function
	 */

	/**
	 * @callback dirCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 * @param {cleanupCallback} fn the cleanup callback function
	 */

	/**
	 * Removes the temporary created file or directory.
	 *
	 * @callback cleanupCallback
	 * @param {simpleCallback} [next] function to call after entry was removed
	 */

	/**
	 * Callback function for function composition.
	 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
	 *
	 * @callback simpleCallback
	 */

	// exporting all the needed methods
	tmp.tmpdir = tmpDir;
	tmp.dir = dir;
	tmp.dirSync = dirSync;
	tmp.file = file;
	tmp.fileSync = fileSync;
	tmp.tmpName = tmpName;
	tmp.tmpNameSync = tmpNameSync;
	tmp.setGracefulCleanup = setGracefulCleanup;

	var CreateFileError$1 = {};

	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(CreateFileError$1, "__esModule", {
	  value: true
	});
	var CreateFileError = /** @class */function (_super) {
	  __extends$3(CreateFileError, _super);
	  function CreateFileError(originalError) {
	    var _newTarget = this.constructor;
	    var _this = _super.call(this, "Failed to create temporary file for editor") || this;
	    _this.originalError = originalError;
	    var proto = _newTarget.prototype;
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(_this, proto);
	    } else {
	      _this.__proto__ = _newTarget.prototype;
	    }
	    return _this;
	  }
	  return CreateFileError;
	}(Error);
	CreateFileError$1.CreateFileError = CreateFileError;

	var LaunchEditorError$1 = {};

	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(LaunchEditorError$1, "__esModule", {
	  value: true
	});
	var LaunchEditorError = /** @class */function (_super) {
	  __extends$2(LaunchEditorError, _super);
	  function LaunchEditorError(originalError) {
	    var _newTarget = this.constructor;
	    var _this = _super.call(this, "Failed launch editor") || this;
	    _this.originalError = originalError;
	    var proto = _newTarget.prototype;
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(_this, proto);
	    } else {
	      _this.__proto__ = _newTarget.prototype;
	    }
	    return _this;
	  }
	  return LaunchEditorError;
	}(Error);
	LaunchEditorError$1.LaunchEditorError = LaunchEditorError;

	var ReadFileError$1 = {};

	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(ReadFileError$1, "__esModule", {
	  value: true
	});
	var ReadFileError = /** @class */function (_super) {
	  __extends$1(ReadFileError, _super);
	  function ReadFileError(originalError) {
	    var _newTarget = this.constructor;
	    var _this = _super.call(this, "Failed to read temporary file") || this;
	    _this.originalError = originalError;
	    var proto = _newTarget.prototype;
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(_this, proto);
	    } else {
	      _this.__proto__ = _newTarget.prototype;
	    }
	    return _this;
	  }
	  return ReadFileError;
	}(Error);
	ReadFileError$1.ReadFileError = ReadFileError;

	var RemoveFileError$1 = {};

	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(RemoveFileError$1, "__esModule", {
	  value: true
	});
	var RemoveFileError = /** @class */function (_super) {
	  __extends(RemoveFileError, _super);
	  function RemoveFileError(originalError) {
	    var _newTarget = this.constructor;
	    var _this = _super.call(this, "Failed to cleanup temporary file") || this;
	    _this.originalError = originalError;
	    var proto = _newTarget.prototype;
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(_this, proto);
	    } else {
	      _this.__proto__ = _newTarget.prototype;
	    }
	    return _this;
	  }
	  return RemoveFileError;
	}(Error);
	RemoveFileError$1.RemoveFileError = RemoveFileError;

	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2019
	 */
	Object.defineProperty(main, "__esModule", {
	  value: true
	});
	var chardet_1 = chardet;
	var child_process_1 = require$$1$5;
	var fs_1 = require$$2$2;
	var iconv_lite_1 = libExports;
	var tmp_1 = tmp;
	var CreateFileError_1 = CreateFileError$1;
	main.CreateFileError = CreateFileError_1.CreateFileError;
	var LaunchEditorError_1 = LaunchEditorError$1;
	main.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
	var ReadFileError_1 = ReadFileError$1;
	main.ReadFileError = ReadFileError_1.ReadFileError;
	var RemoveFileError_1 = RemoveFileError$1;
	main.RemoveFileError = RemoveFileError_1.RemoveFileError;
	function edit(text, fileOptions) {
	  if (text === void 0) {
	    text = "";
	  }
	  var editor = new ExternalEditor(text, fileOptions);
	  editor.run();
	  editor.cleanup();
	  return editor.text;
	}
	main.edit = edit;
	function editAsync(text, callback, fileOptions) {
	  if (text === void 0) {
	    text = "";
	  }
	  var editor = new ExternalEditor(text, fileOptions);
	  editor.runAsync(function (err, result) {
	    if (err) {
	      setImmediate(callback, err, null);
	    } else {
	      try {
	        editor.cleanup();
	        setImmediate(callback, null, result);
	      } catch (cleanupError) {
	        setImmediate(callback, cleanupError, null);
	      }
	    }
	  });
	}
	var editAsync_1 = main.editAsync = editAsync;
	var ExternalEditor = /** @class */function () {
	  function ExternalEditor(text, fileOptions) {
	    if (text === void 0) {
	      text = "";
	    }
	    this.text = "";
	    this.fileOptions = {};
	    this.text = text;
	    if (fileOptions) {
	      this.fileOptions = fileOptions;
	    }
	    this.determineEditor();
	    this.createTemporaryFile();
	  }
	  ExternalEditor.splitStringBySpace = function (str) {
	    var pieces = [];
	    var currentString = "";
	    for (var strIndex = 0; strIndex < str.length; strIndex++) {
	      var currentLetter = str[strIndex];
	      if (strIndex > 0 && currentLetter === " " && str[strIndex - 1] !== "\\" && currentString.length > 0) {
	        pieces.push(currentString);
	        currentString = "";
	      } else {
	        currentString += currentLetter;
	      }
	    }
	    if (currentString.length > 0) {
	      pieces.push(currentString);
	    }
	    return pieces;
	  };
	  Object.defineProperty(ExternalEditor.prototype, "temp_file", {
	    get: function () {
	      console.log("DEPRECATED: temp_file. Use tempFile moving forward.");
	      return this.tempFile;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  Object.defineProperty(ExternalEditor.prototype, "last_exit_status", {
	    get: function () {
	      console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward.");
	      return this.lastExitStatus;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  ExternalEditor.prototype.run = function () {
	    this.launchEditor();
	    this.readTemporaryFile();
	    return this.text;
	  };
	  ExternalEditor.prototype.runAsync = function (callback) {
	    var _this = this;
	    try {
	      this.launchEditorAsync(function () {
	        try {
	          _this.readTemporaryFile();
	          setImmediate(callback, null, _this.text);
	        } catch (readError) {
	          setImmediate(callback, readError, null);
	        }
	      });
	    } catch (launchError) {
	      setImmediate(callback, launchError, null);
	    }
	  };
	  ExternalEditor.prototype.cleanup = function () {
	    this.removeTemporaryFile();
	  };
	  ExternalEditor.prototype.determineEditor = function () {
	    var editor = process.env.VISUAL ? process.env.VISUAL : process.env.EDITOR ? process.env.EDITOR : /^win/.test(process.platform) ? "notepad" : "vim";
	    var editorOpts = ExternalEditor.splitStringBySpace(editor).map(function (piece) {
	      return piece.replace("\\ ", " ");
	    });
	    var bin = editorOpts.shift();
	    this.editor = {
	      args: editorOpts,
	      bin: bin
	    };
	  };
	  ExternalEditor.prototype.createTemporaryFile = function () {
	    try {
	      this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
	      var opt = {
	        encoding: "utf8"
	      };
	      if (this.fileOptions.hasOwnProperty("mode")) {
	        opt.mode = this.fileOptions.mode;
	      }
	      fs_1.writeFileSync(this.tempFile, this.text, opt);
	    } catch (createFileError) {
	      throw new CreateFileError_1.CreateFileError(createFileError);
	    }
	  };
	  ExternalEditor.prototype.readTemporaryFile = function () {
	    try {
	      var tempFileBuffer = fs_1.readFileSync(this.tempFile);
	      if (tempFileBuffer.length === 0) {
	        this.text = "";
	      } else {
	        var encoding = chardet_1.detect(tempFileBuffer).toString();
	        if (!iconv_lite_1.encodingExists(encoding)) {
	          // Probably a bad idea, but will at least prevent crashing
	          encoding = "utf8";
	        }
	        this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
	      }
	    } catch (readFileError) {
	      throw new ReadFileError_1.ReadFileError(readFileError);
	    }
	  };
	  ExternalEditor.prototype.removeTemporaryFile = function () {
	    try {
	      fs_1.unlinkSync(this.tempFile);
	    } catch (removeFileError) {
	      throw new RemoveFileError_1.RemoveFileError(removeFileError);
	    }
	  };
	  ExternalEditor.prototype.launchEditor = function () {
	    try {
	      var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), {
	        stdio: "inherit"
	      });
	      this.lastExitStatus = editorProcess.status;
	    } catch (launchError) {
	      throw new LaunchEditorError_1.LaunchEditorError(launchError);
	    }
	  };
	  ExternalEditor.prototype.launchEditorAsync = function (callback) {
	    var _this = this;
	    try {
	      var editorProcess = child_process_1.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), {
	        stdio: "inherit"
	      });
	      editorProcess.on("exit", function (code) {
	        _this.lastExitStatus = code;
	        setImmediate(callback);
	      });
	    } catch (launchError) {
	      throw new LaunchEditorError_1.LaunchEditorError(launchError);
	    }
	  };
	  return ExternalEditor;
	}();
	main.ExternalEditor = ExternalEditor;

	/**
	 * `editor` type prompt
	 */

	class EditorPrompt extends Prompt {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;
	    this.editorResult = new Subject();

	    // Open Editor on "line" (Enter Key)
	    const events = observe(this.rl);
	    this.lineSubscription = events.line.subscribe(this.startExternalEditor.bind(this));
	    const waitUserInput = this.opt.waitUserInput === undefined ? true : this.opt.waitUserInput;
	    if (!waitUserInput) {
	      this.startExternalEditor();
	    }

	    // Trigger Validation when editor closes
	    const validation = this.handleSubmitEvents(this.editorResult);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    // Prevents default from being printed on screen (can look weird with multiple lines)
	    this.currentText = this.opt.default;
	    this.opt.default = null;

	    // Init
	    this.render();
	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {EditorPrompt} self
	   */

	  render(error) {
	    let bottomContent = '';
	    let message = this.getQuestion();
	    message += this.status === 'answered' ? chalk$3.dim('Received') : chalk$3.dim('Press <enter> to launch your preferred editor.');
	    if (error) {
	      bottomContent = chalk$3.red('>> ') + error;
	    }
	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * Launch $EDITOR on user press enter
	   */

	  startExternalEditor() {
	    // Pause Readline to prevent stdin and stdout from being modified while the editor is showing
	    this.rl.pause();
	    editAsync_1(this.currentText, this.endExternalEditor.bind(this), {
	      postfix: this.opt.postfix ?? '.txt'
	    });
	  }
	  endExternalEditor(error, result) {
	    this.rl.resume();
	    if (error) {
	      this.editorResult.error(error);
	    } else {
	      this.editorResult.next(result);
	    }
	  }
	  onEnd(state) {
	    this.editorResult.unsubscribe();
	    this.lineSubscription.unsubscribe();
	    this.answer = state.value;
	    this.status = 'answered';
	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(this.answer);
	  }
	  onError(state) {
	    this.render(state.isValid);
	  }
	}

	var callBind$1 = {exports: {}};

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';
	var concatty = function concatty(a, b) {
	  var arr = [];
	  for (var i = 0; i < a.length; i += 1) {
	    arr[i] = a[i];
	  }
	  for (var j = 0; j < b.length; j += 1) {
	    arr[j + a.length] = b[j];
	  }
	  return arr;
	};
	var slicy = function slicy(arrLike, offset) {
	  var arr = [];
	  for (var i = offset , j = 0; i < arrLike.length; i += 1, j += 1) {
	    arr[j] = arrLike[i];
	  }
	  return arr;
	};
	var joiny = function (arr, joiner) {
	  var str = '';
	  for (var i = 0; i < arr.length; i += 1) {
	    str += arr[i];
	    if (i + 1 < arr.length) {
	      str += joiner;
	    }
	  }
	  return str;
	};
	var implementation$1 = function bind(that) {
	  var target = this;
	  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	    throw new TypeError(ERROR_MESSAGE + target);
	  }
	  var args = slicy(arguments, 1);
	  var bound;
	  var binder = function () {
	    if (this instanceof bound) {
	      var result = target.apply(this, concatty(args, arguments));
	      if (Object(result) === result) {
	        return result;
	      }
	      return this;
	    }
	    return target.apply(that, concatty(args, arguments));
	  };
	  var boundLength = max(0, target.length - args.length);
	  var boundArgs = [];
	  for (var i = 0; i < boundLength; i++) {
	    boundArgs[i] = '$' + i;
	  }
	  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
	  if (target.prototype) {
	    var Empty = function Empty() {};
	    Empty.prototype = target.prototype;
	    bound.prototype = new Empty();
	    Empty.prototype = null;
	  }
	  return bound;
	};

	var implementation = implementation$1;
	var functionBind = Function.prototype.bind || implementation;

	/** @type {import('.')} */
	var esErrors = Error;

	/** @type {import('./eval')} */
	var _eval = EvalError;

	/** @type {import('./range')} */
	var range = RangeError;

	/** @type {import('./ref')} */
	var ref = ReferenceError;

	/** @type {import('./syntax')} */
	var syntax = SyntaxError;

	/** @type {import('./type')} */
	var type = TypeError;

	/** @type {import('./uri')} */
	var uri = URIError;

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	var shams = function hasSymbols() {
	  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
	    return false;
	  }
	  if (typeof Symbol.iterator === 'symbol') {
	    return true;
	  }
	  var obj = {};
	  var sym = Symbol('test');
	  var symObj = Object(sym);
	  if (typeof sym === 'string') {
	    return false;
	  }
	  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
	    return false;
	  }
	  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
	    return false;
	  }

	  // temp disabled per https://github.com/ljharb/object.assign/issues/17
	  // if (sym instanceof Symbol) { return false; }
	  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	  // if (!(symObj instanceof Symbol)) { return false; }

	  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
	  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	  var symVal = 42;
	  obj[sym] = symVal;
	  for (sym in obj) {
	    return false;
	  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
	    return false;
	  }
	  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
	    return false;
	  }
	  var syms = Object.getOwnPropertySymbols(obj);
	  if (syms.length !== 1 || syms[0] !== sym) {
	    return false;
	  }
	  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
	    return false;
	  }
	  if (typeof Object.getOwnPropertyDescriptor === 'function') {
	    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
	    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
	      return false;
	    }
	  }
	  return true;
	};

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = shams;
	var hasSymbols$1 = function hasNativeSymbols() {
	  if (typeof origSymbol !== 'function') {
	    return false;
	  }
	  if (typeof Symbol !== 'function') {
	    return false;
	  }
	  if (typeof origSymbol('foo') !== 'symbol') {
	    return false;
	  }
	  if (typeof Symbol('bar') !== 'symbol') {
	    return false;
	  }
	  return hasSymbolSham();
	};

	var test = {
	  __proto__: null,
	  foo: {}
	};
	var $Object = Object;

	/** @type {import('.')} */
	var hasProto$1 = function hasProto() {
	  // @ts-expect-error: TS errors on an inherited property for some reason
	  return {
	    __proto__: test
	  }.foo === test.foo && !(test instanceof $Object);
	};

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind$1 = functionBind;

	/** @type {import('.')} */
	var hasown = bind$1.call(call, $hasOwn);

	var undefined$1;
	var $Error = esErrors;
	var $EvalError = _eval;
	var $RangeError = range;
	var $ReferenceError = ref;
	var $SyntaxError$1 = syntax;
	var $TypeError$2 = type;
	var $URIError = uri;
	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
	  try {
	    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	  } catch (e) {}
	};
	var $gOPD$1 = Object.getOwnPropertyDescriptor;
	if ($gOPD$1) {
	  try {
	    $gOPD$1({}, '');
	  } catch (e) {
	    $gOPD$1 = null; // this is IE 8, which has a broken gOPD
	  }
	}
	var throwTypeError = function () {
	  throw new $TypeError$2();
	};
	var ThrowTypeError = $gOPD$1 ? function () {
	  try {
	    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
	    arguments.callee; // IE 8 does not throw here
	    return throwTypeError;
	  } catch (calleeThrows) {
	    try {
	      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
	      return $gOPD$1(arguments, 'callee').get;
	    } catch (gOPDthrows) {
	      return throwTypeError;
	    }
	  }
	}() : throwTypeError;
	var hasSymbols = hasSymbols$1();
	var hasProto = hasProto$1();
	var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
	  return x.__proto__;
	} // eslint-disable-line no-proto
	: null);
	var needsEval = {};
	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);
	var INTRINSICS = {
	  __proto__: null,
	  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
	  '%Array%': Array,
	  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
	  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
	  '%AsyncFromSyncIteratorPrototype%': undefined$1,
	  '%AsyncFunction%': needsEval,
	  '%AsyncGenerator%': needsEval,
	  '%AsyncGeneratorFunction%': needsEval,
	  '%AsyncIteratorPrototype%': needsEval,
	  '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
	  '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
	  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
	  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
	  '%Boolean%': Boolean,
	  '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
	  '%Date%': Date,
	  '%decodeURI%': decodeURI,
	  '%decodeURIComponent%': decodeURIComponent,
	  '%encodeURI%': encodeURI,
	  '%encodeURIComponent%': encodeURIComponent,
	  '%Error%': $Error,
	  '%eval%': eval,
	  // eslint-disable-line no-eval
	  '%EvalError%': $EvalError,
	  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
	  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
	  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
	  '%Function%': $Function,
	  '%GeneratorFunction%': needsEval,
	  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
	  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
	  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
	  '%isFinite%': isFinite,
	  '%isNaN%': isNaN,
	  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
	  '%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
	  '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
	  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
	  '%Math%': Math,
	  '%Number%': Number,
	  '%Object%': Object,
	  '%parseFloat%': parseFloat,
	  '%parseInt%': parseInt,
	  '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
	  '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
	  '%RangeError%': $RangeError,
	  '%ReferenceError%': $ReferenceError,
	  '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
	  '%RegExp%': RegExp,
	  '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
	  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
	  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
	  '%String%': String,
	  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
	  '%Symbol%': hasSymbols ? Symbol : undefined$1,
	  '%SyntaxError%': $SyntaxError$1,
	  '%ThrowTypeError%': ThrowTypeError,
	  '%TypedArray%': TypedArray,
	  '%TypeError%': $TypeError$2,
	  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
	  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
	  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
	  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
	  '%URIError%': $URIError,
	  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
	  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
	  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
	};
	if (getProto) {
	  try {
	    null.error; // eslint-disable-line no-unused-expressions
	  } catch (e) {
	    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
	    var errorProto = getProto(getProto(e));
	    INTRINSICS['%Error.prototype%'] = errorProto;
	  }
	}
	var doEval = function doEval(name) {
	  var value;
	  if (name === '%AsyncFunction%') {
	    value = getEvalledConstructor('async function () {}');
	  } else if (name === '%GeneratorFunction%') {
	    value = getEvalledConstructor('function* () {}');
	  } else if (name === '%AsyncGeneratorFunction%') {
	    value = getEvalledConstructor('async function* () {}');
	  } else if (name === '%AsyncGenerator%') {
	    var fn = doEval('%AsyncGeneratorFunction%');
	    if (fn) {
	      value = fn.prototype;
	    }
	  } else if (name === '%AsyncIteratorPrototype%') {
	    var gen = doEval('%AsyncGenerator%');
	    if (gen && getProto) {
	      value = getProto(gen.prototype);
	    }
	  }
	  INTRINSICS[name] = value;
	  return value;
	};
	var LEGACY_ALIASES = {
	  __proto__: null,
	  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	  '%ArrayPrototype%': ['Array', 'prototype'],
	  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
	  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	  '%BooleanPrototype%': ['Boolean', 'prototype'],
	  '%DataViewPrototype%': ['DataView', 'prototype'],
	  '%DatePrototype%': ['Date', 'prototype'],
	  '%ErrorPrototype%': ['Error', 'prototype'],
	  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
	  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	  '%FunctionPrototype%': ['Function', 'prototype'],
	  '%Generator%': ['GeneratorFunction', 'prototype'],
	  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	  '%JSONParse%': ['JSON', 'parse'],
	  '%JSONStringify%': ['JSON', 'stringify'],
	  '%MapPrototype%': ['Map', 'prototype'],
	  '%NumberPrototype%': ['Number', 'prototype'],
	  '%ObjectPrototype%': ['Object', 'prototype'],
	  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	  '%PromisePrototype%': ['Promise', 'prototype'],
	  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	  '%Promise_all%': ['Promise', 'all'],
	  '%Promise_reject%': ['Promise', 'reject'],
	  '%Promise_resolve%': ['Promise', 'resolve'],
	  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
	  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	  '%RegExpPrototype%': ['RegExp', 'prototype'],
	  '%SetPrototype%': ['Set', 'prototype'],
	  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	  '%StringPrototype%': ['String', 'prototype'],
	  '%SymbolPrototype%': ['Symbol', 'prototype'],
	  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
	  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	  '%URIErrorPrototype%': ['URIError', 'prototype'],
	  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
	  '%WeakSetPrototype%': ['WeakSet', 'prototype']
	};
	var bind = functionBind;
	var hasOwn = hasown;
	var $concat = bind.call(Function.call, Array.prototype.concat);
	var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
	var $replace = bind.call(Function.call, String.prototype.replace);
	var $strSlice = bind.call(Function.call, String.prototype.slice);
	var $exec = bind.call(Function.call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
	  var first = $strSlice(string, 0, 1);
	  var last = $strSlice(string, -1);
	  if (first === '%' && last !== '%') {
	    throw new $SyntaxError$1('invalid intrinsic syntax, expected closing `%`');
	  } else if (last === '%' && first !== '%') {
	    throw new $SyntaxError$1('invalid intrinsic syntax, expected opening `%`');
	  }
	  var result = [];
	  $replace(string, rePropName, function (match, number, quote, subString) {
	    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	  });
	  return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	  var intrinsicName = name;
	  var alias;
	  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
	    alias = LEGACY_ALIASES[intrinsicName];
	    intrinsicName = '%' + alias[0] + '%';
	  }
	  if (hasOwn(INTRINSICS, intrinsicName)) {
	    var value = INTRINSICS[intrinsicName];
	    if (value === needsEval) {
	      value = doEval(intrinsicName);
	    }
	    if (typeof value === 'undefined' && !allowMissing) {
	      throw new $TypeError$2('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	    }
	    return {
	      alias: alias,
	      name: intrinsicName,
	      value: value
	    };
	  }
	  throw new $SyntaxError$1('intrinsic ' + name + ' does not exist!');
	};
	var getIntrinsic = function GetIntrinsic(name, allowMissing) {
	  if (typeof name !== 'string' || name.length === 0) {
	    throw new $TypeError$2('intrinsic name must be a non-empty string');
	  }
	  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
	    throw new $TypeError$2('"allowMissing" argument must be a boolean');
	  }
	  if ($exec(/^%?[^%]*%?$/, name) === null) {
	    throw new $SyntaxError$1('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	  }
	  var parts = stringToPath(name);
	  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
	  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	  var intrinsicRealName = intrinsic.name;
	  var value = intrinsic.value;
	  var skipFurtherCaching = false;
	  var alias = intrinsic.alias;
	  if (alias) {
	    intrinsicBaseName = alias[0];
	    $spliceApply(parts, $concat([0, 1], alias));
	  }
	  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
	    var part = parts[i];
	    var first = $strSlice(part, 0, 1);
	    var last = $strSlice(part, -1);
	    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
	      throw new $SyntaxError$1('property names with quotes must have matching quotes');
	    }
	    if (part === 'constructor' || !isOwn) {
	      skipFurtherCaching = true;
	    }
	    intrinsicBaseName += '.' + part;
	    intrinsicRealName = '%' + intrinsicBaseName + '%';
	    if (hasOwn(INTRINSICS, intrinsicRealName)) {
	      value = INTRINSICS[intrinsicRealName];
	    } else if (value != null) {
	      if (!(part in value)) {
	        if (!allowMissing) {
	          throw new $TypeError$2('base intrinsic for ' + name + ' exists, but the property is not available.');
	        }
	        return void undefined$1;
	      }
	      if ($gOPD$1 && i + 1 >= parts.length) {
	        var desc = $gOPD$1(value, part);
	        isOwn = !!desc;

	        // By convention, when a data property is converted to an accessor
	        // property to emulate a data property that does not suffer from
	        // the override mistake, that accessor's getter is marked with
	        // an `originalValue` property. Here, when we detect this, we
	        // uphold the illusion by pretending to see that original data
	        // property, i.e., returning the value rather than the getter
	        // itself.
	        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
	          value = desc.get;
	        } else {
	          value = value[part];
	        }
	      } else {
	        isOwn = hasOwn(value, part);
	        value = value[part];
	      }
	      if (isOwn && !skipFurtherCaching) {
	        INTRINSICS[intrinsicRealName] = value;
	      }
	    }
	  }
	  return value;
	};

	var esDefineProperty;
	var hasRequiredEsDefineProperty;
	function requireEsDefineProperty() {
	  if (hasRequiredEsDefineProperty) return esDefineProperty;
	  hasRequiredEsDefineProperty = 1;
	  var GetIntrinsic = getIntrinsic;

	  /** @type {import('.')} */
	  var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
	  if ($defineProperty) {
	    try {
	      $defineProperty({}, 'a', {
	        value: 1
	      });
	    } catch (e) {
	      // IE 8 has a broken defineProperty
	      $defineProperty = false;
	    }
	  }
	  esDefineProperty = $defineProperty;
	  return esDefineProperty;
	}

	var GetIntrinsic$1 = getIntrinsic;
	var $gOPD = GetIntrinsic$1('%Object.getOwnPropertyDescriptor%', true);
	if ($gOPD) {
	  try {
	    $gOPD([], 'length');
	  } catch (e) {
	    // IE 8 has a broken gOPD
	    $gOPD = null;
	  }
	}
	var gopd$1 = $gOPD;

	var $defineProperty$1 = requireEsDefineProperty();
	var $SyntaxError = syntax;
	var $TypeError$1 = type;
	var gopd = gopd$1;

	/** @type {import('.')} */
	var defineDataProperty = function defineDataProperty(obj, property, value) {
	  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
	    throw new $TypeError$1('`obj` must be an object or a function`');
	  }
	  if (typeof property !== 'string' && typeof property !== 'symbol') {
	    throw new $TypeError$1('`property` must be a string or a symbol`');
	  }
	  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
	    throw new $TypeError$1('`nonEnumerable`, if provided, must be a boolean or null');
	  }
	  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
	    throw new $TypeError$1('`nonWritable`, if provided, must be a boolean or null');
	  }
	  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
	    throw new $TypeError$1('`nonConfigurable`, if provided, must be a boolean or null');
	  }
	  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
	    throw new $TypeError$1('`loose`, if provided, must be a boolean');
	  }
	  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	  var nonWritable = arguments.length > 4 ? arguments[4] : null;
	  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	  var loose = arguments.length > 6 ? arguments[6] : false;

	  /* @type {false | TypedPropertyDescriptor<unknown>} */
	  var desc = !!gopd && gopd(obj, property);
	  if ($defineProperty$1) {
	    $defineProperty$1(obj, property, {
	      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
	      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
	      value: value,
	      writable: nonWritable === null && desc ? desc.writable : !nonWritable
	    });
	  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
	    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
	    obj[property] = value; // eslint-disable-line no-param-reassign
	  } else {
	    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	  }
	};

	var $defineProperty = requireEsDefineProperty();
	var hasPropertyDescriptors = function hasPropertyDescriptors() {
	  return !!$defineProperty;
	};
	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	  // node v0.6 has a bug where array lengths can be Set but not Defined
	  if (!$defineProperty) {
	    return null;
	  }
	  try {
	    return $defineProperty([], 'length', {
	      value: 1
	    }).length !== 1;
	  } catch (e) {
	    // In Firefox 4-22, defining length on an array throws an exception.
	    return true;
	  }
	};
	var hasPropertyDescriptors_1 = hasPropertyDescriptors;

	var GetIntrinsic = getIntrinsic;
	var define = defineDataProperty;
	var hasDescriptors = hasPropertyDescriptors_1();
	var gOPD = gopd$1;
	var $TypeError = type;
	var $floor = GetIntrinsic('%Math.floor%');

	/** @type {import('.')} */
	var setFunctionLength = function setFunctionLength(fn, length) {
	  if (typeof fn !== 'function') {
	    throw new $TypeError('`fn` is not a function');
	  }
	  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
	    throw new $TypeError('`length` must be a positive 32-bit integer');
	  }
	  var loose = arguments.length > 2 && !!arguments[2];
	  var functionLengthIsConfigurable = true;
	  var functionLengthIsWritable = true;
	  if ('length' in fn && gOPD) {
	    var desc = gOPD(fn, 'length');
	    if (desc && !desc.configurable) {
	      functionLengthIsConfigurable = false;
	    }
	    if (desc && !desc.writable) {
	      functionLengthIsWritable = false;
	    }
	  }
	  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
	    if (hasDescriptors) {
	      define( /** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
	    } else {
	      define( /** @type {Parameters<define>[0]} */fn, 'length', length);
	    }
	  }
	  return fn;
	};

	(function (module) {

	  var bind = functionBind;
	  var GetIntrinsic = getIntrinsic;
	  var setFunctionLength$1 = setFunctionLength;
	  var $TypeError = type;
	  var $apply = GetIntrinsic('%Function.prototype.apply%');
	  var $call = GetIntrinsic('%Function.prototype.call%');
	  var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
	  var $defineProperty = requireEsDefineProperty();
	  var $max = GetIntrinsic('%Math.max%');
	  module.exports = function callBind(originalFunction) {
	    if (typeof originalFunction !== 'function') {
	      throw new $TypeError('a function is required');
	    }
	    var func = $reflectApply(bind, $call, arguments);
	    return setFunctionLength$1(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
	  };
	  var applyBind = function applyBind() {
	    return $reflectApply(bind, $apply, arguments);
	  };
	  if ($defineProperty) {
	    $defineProperty(module.exports, 'apply', {
	      value: applyBind
	    });
	  } else {
	    module.exports.apply = applyBind;
	  }
	})(callBind$1);
	var callBindExports = callBind$1.exports;

	var Stream$1 = require$$0$5.Stream;
	var callBind = callBindExports;

	/** @typedef {import('./through').ThroughStream} ThroughStream */

	// create a readable writable stream.

	/** @type {import('./through')} */
	function through(write, end, opts) {
	  var writeBound = callBind(write || function (data) {
	    this.queue(data);
	  });
	  var endBound = callBind(end || function () {
	    this.queue(null);
	  });
	  var ended = false;
	  var destroyed = false;
	  /** @type {unknown[]} */
	  var buffer = [];
	  var _ended = false;
	  // @ts-expect-error
	  /** @type {ThroughStream} */
	  var stream = new Stream$1();
	  stream.readable = true;
	  stream.writable = true;
	  stream.paused = false;

	  // stream.autoPause = !(opts && opts.autoPause === false)
	  stream.autoDestroy = !(opts && opts.autoDestroy === false);
	  stream.write = function (data) {
	    writeBound(this, data);
	    return !stream.paused;
	  };
	  function drain() {
	    while (buffer.length && !stream.paused) {
	      var data = buffer.shift();
	      if (data === null) {
	        return stream.emit('end');
	      }
	      stream.emit('data', data);
	    }
	  }
	  stream.queue = function (data) {
	    // console.error(ended)
	    if (_ended) {
	      return stream;
	    }
	    if (data === null) {
	      _ended = true;
	    }
	    buffer.push(data);
	    drain();
	    return stream;
	  };
	  stream.push = stream.queue;

	  /*
	   * this will be registered as the first 'end' listener must call destroy next tick, to make sure we're after any stream piped from here.
	   * this is only a problem if end is not emitted synchronously.
	   * a nicer way to do this is to make sure this is the last listener for 'end'
	   */

	  stream.on('end', function () {
	    stream.readable = false;
	    if (!stream.writable && stream.autoDestroy) {
	      process.nextTick(function () {
	        stream.destroy();
	      });
	    }
	  });
	  function _end() {
	    stream.writable = false;
	    endBound(stream);
	    if (!stream.readable && stream.autoDestroy) {
	      stream.destroy();
	    }
	  }
	  stream.end = function (data) {
	    if (ended) {
	      return;
	    }
	    ended = true;
	    if (arguments.length) {
	      stream.write(data);
	    }
	    _end(); // will emit or queue
	    return stream;
	  };
	  stream.destroy = function () {
	    if (destroyed) {
	      return;
	    }
	    destroyed = true;
	    ended = true;
	    buffer.length = 0;
	    stream.writable = false;
	    stream.readable = false;
	    stream.emit('close');
	    return stream;
	  };
	  stream.pause = function () {
	    if (stream.paused) {
	      return;
	    }
	    stream.paused = true;
	    return stream;
	  };
	  stream.resume = function () {
	    if (stream.paused) {
	      stream.paused = false;
	      stream.emit('resume');
	    }
	    drain();
	    // may have become paused again, as drain emits 'data'.
	    if (!stream.paused) {
	      stream.emit('drain');
	    }
	    return stream;
	  };
	  return stream;
	}

	/*
	 * through
	 *
	 * a stream that does nothing but re-emit the input.
	 * useful for aggregating a series of changing but not ending streams into one stream)
	 */

	var through_1 = through;
	through.through = through;
	var through$1 = /*@__PURE__*/getDefaultExportFromCjs(through_1);

	const Stream = require$$0$5;
	class MuteStream extends Stream {
	  #isTTY = null;
	  constructor(opts = {}) {
	    super(opts);
	    this.writable = this.readable = true;
	    this.muted = false;
	    this.on('pipe', this._onpipe);
	    this.replace = opts.replace;

	    // For readline-type situations
	    // This much at the start of a line being redrawn after a ctrl char
	    // is seen (such as backspace) won't be redrawn as the replacement
	    this._prompt = opts.prompt || null;
	    this._hadControl = false;
	  }
	  #destSrc(key, def) {
	    if (this._dest) {
	      return this._dest[key];
	    }
	    if (this._src) {
	      return this._src[key];
	    }
	    return def;
	  }
	  #proxy(method, ...args) {
	    if (typeof this._dest?.[method] === 'function') {
	      this._dest[method](...args);
	    }
	    if (typeof this._src?.[method] === 'function') {
	      this._src[method](...args);
	    }
	  }
	  get isTTY() {
	    if (this.#isTTY !== null) {
	      return this.#isTTY;
	    }
	    return this.#destSrc('isTTY', false);
	  }

	  // basically just get replace the getter/setter with a regular value
	  set isTTY(val) {
	    this.#isTTY = val;
	  }
	  get rows() {
	    return this.#destSrc('rows');
	  }
	  get columns() {
	    return this.#destSrc('columns');
	  }
	  mute() {
	    this.muted = true;
	  }
	  unmute() {
	    this.muted = false;
	  }
	  _onpipe(src) {
	    this._src = src;
	  }
	  pipe(dest, options) {
	    this._dest = dest;
	    return super.pipe(dest, options);
	  }
	  pause() {
	    if (this._src) {
	      return this._src.pause();
	    }
	  }
	  resume() {
	    if (this._src) {
	      return this._src.resume();
	    }
	  }
	  write(c) {
	    if (this.muted) {
	      if (!this.replace) {
	        return true;
	      }
	      // eslint-disable-next-line no-control-regex
	      if (c.match(/^\u001b/)) {
	        if (c.indexOf(this._prompt) === 0) {
	          c = c.slice(this._prompt.length);
	          c = c.replace(/./g, this.replace);
	          c = this._prompt + c;
	        }
	        this._hadControl = true;
	        return this.emit('data', c);
	      } else {
	        if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
	          this._hadControl = false;
	          this.emit('data', this._prompt);
	          c = c.slice(this._prompt.length);
	        }
	        c = c.toString().replace(/./g, this.replace);
	      }
	    }
	    this.emit('data', c);
	  }
	  end(c) {
	    if (this.muted) {
	      if (c && this.replace) {
	        c = c.toString().replace(/./g, this.replace);
	      } else {
	        c = null;
	      }
	    }
	    if (c) {
	      this.emit('data', c);
	    }
	    this.emit('end');
	  }
	  destroy(...args) {
	    return this.#proxy('destroy', ...args);
	  }
	  destroySoon(...args) {
	    return this.#proxy('destroySoon', ...args);
	  }
	  close(...args) {
	    return this.#proxy('close', ...args);
	  }
	}
	var lib = MuteStream;
	var MuteStream$1 = /*@__PURE__*/getDefaultExportFromCjs(lib);

	/**
	 * Base interface class other can inherits from
	 */

	class UI {
	  constructor(opt) {
	    // Instantiate the Readline interface
	    // @Note: Don't reassign if already present (allow test to override the Stream)
	    this.rl ||= readline$1.createInterface(setupReadlineOptions(opt));
	    this.rl.resume();
	    this.onForceClose = this.onForceClose.bind(this);

	    // Make sure new prompt start on a newline when closing
	    process.on('exit', this.onForceClose);

	    // Terminate process on SIGINT (which will call process.on('exit') in return)
	    this.rl.on('SIGINT', this.onForceClose);
	  }

	  /**
	   * Handle the ^C exit
	   * @return {null}
	   */

	  onForceClose() {
	    this.close();
	    process.kill(process.pid, 'SIGINT');
	    console.log('');
	  }

	  /**
	   * Close the interface and cleanup listeners
	   */

	  close() {
	    // Remove events listeners
	    this.rl.removeListener('SIGINT', this.onForceClose);
	    process.removeListener('exit', this.onForceClose);
	    this.rl.output.unmute();
	    if (this.activePrompt && typeof this.activePrompt.close === 'function') {
	      this.activePrompt.close();
	    }

	    // Close the readline
	    this.rl.output.end();
	    this.rl.pause();
	    this.rl.close();
	  }
	}
	function setupReadlineOptions(opt = {}) {
	  // Inquirer 8.x:
	  // opt.skipTTYChecks = opt.skipTTYChecks === undefined ? opt.input !== undefined : opt.skipTTYChecks;
	  opt.skipTTYChecks = opt.skipTTYChecks === undefined ? true : opt.skipTTYChecks;

	  // Default `input` to stdin
	  const input = opt.input || process.stdin;

	  // Check if prompt is being called in TTY environment
	  // If it isn't return a failed promise
	  if (!opt.skipTTYChecks && !input.isTTY) {
	    const nonTtyError = new Error('Prompts can not be meaningfully rendered in non-TTY environments');
	    nonTtyError.isTtyError = true;
	    throw nonTtyError;
	  }

	  // Add mute capabilities to the output
	  const ms = new MuteStream$1();
	  ms.pipe(opt.output || process.stdout);
	  const output = ms;
	  return {
	    terminal: true,
	    ...opt,
	    input,
	    output
	  };
	}

	/**
	 * Sticky bottom bar user interface
	 */

	class BottomBar extends UI {
	  constructor(opt = {}) {
	    super(opt);
	    this.log = through$1(this.writeLog.bind(this));
	    this.bottomBar = opt.bottomBar || '';
	    this.render();
	  }

	  /**
	   * Render the prompt to screen
	   * @return {BottomBar} self
	   */

	  render() {
	    this.write(this.bottomBar);
	    return this;
	  }
	  clean() {
	    clearLine(this.rl, this.bottomBar.split('\n').length);
	    return this;
	  }

	  /**
	   * Update the bottom bar content and rerender
	   * @param  {String} bottomBar Bottom bar content
	   * @return {BottomBar}           self
	   */

	  updateBottomBar(bottomBar) {
	    clearLine(this.rl, 1);
	    this.rl.output.unmute();
	    this.clean();
	    this.bottomBar = bottomBar;
	    this.render();
	    this.rl.output.mute();
	    return this;
	  }

	  /**
	   * Write out log data
	   * @param {String} data - The log data to be output
	   * @return {BottomBar} self
	   */

	  writeLog(data) {
	    this.rl.output.unmute();
	    this.clean();
	    this.rl.output.write(this.enforceLF(data.toString()));
	    this.render();
	    this.rl.output.mute();
	    return this;
	  }

	  /**
	   * Make sure line end on a line feed
	   * @param  {String} str Input string
	   * @return {String}     The input string with a final line feed
	   */

	  enforceLF(str) {
	    return /[\n\r]$/.test(str) ? str : str + '\n';
	  }

	  /**
	   * Helper for writing message in Prompt
	   * @param {String} message - The message to be output
	   */
	  write(message) {
	    const msgLines = message.split(/\n/);
	    this.height = msgLines.length;

	    // Write message to screen and setPrompt to control backspace
	    this.rl.setPrompt(msgLines.at(-1));
	    if (this.rl.output.rows === 0 && this.rl.output.columns === 0) {
	      /* When it's a tty through serial port there's no terminal info and the render will malfunction,
	         so we need enforce the cursor to locate to the leftmost position for rendering. */
	      left(this.rl, message.length + this.rl.line.length);
	    }
	    this.rl.output.write(message);
	  }
	}

	var baseGetTag = _baseGetTag,
	  getPrototype = _getPrototype,
	  isObjectLike = isObjectLike_1;

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	  objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	var isPlainObject_1 = isPlainObject;
	var isPlainObject$1 = /*@__PURE__*/getDefaultExportFromCjs(isPlainObject_1);

	var assignValue = _assignValue,
	  castPath = _castPath,
	  isIndex = _isIndex,
	  isObject = isObject_1,
	  toKey = _toKey;

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet$1(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);
	  var index = -1,
	    length = path.length,
	    lastIndex = length - 1,
	    nested = object;
	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	      newValue = value;
	    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	      return object;
	    }
	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}
	var _baseSet = baseSet$1;

	var baseSet = _baseSet;

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}
	var set_1 = set;
	var set$1 = /*@__PURE__*/getDefaultExportFromCjs(set_1);

	/**
	 * Resolve a question property value if it is passed as a function.
	 * This method will overwrite the property on the question object with the received value.
	 * @param  {Object} question - Question object
	 * @param  {String} prop     - Property to fetch name
	 * @param  {Object} answers  - Answers object
	 * @return {Rx.Observable}   - Observable emitting once value is known
	 */

	const fetchAsyncQuestionProperty = function (question, prop, answers) {
	  if (typeof question[prop] !== 'function') {
	    return of(question);
	  }
	  return from(runAsync$1(question[prop])(answers).then(value => {
	    question[prop] = value;
	    return question;
	  }));
	};

	const _ = {
	  isPlainObject: isPlainObject$1,
	  set: set$1,
	  get: get$2
	};

	/**
	 * Base interface class other can inherits from
	 */
	class PromptUI extends UI {
	  constructor(prompts, opt) {
	    super(opt);
	    this.prompts = prompts;
	  }
	  run(questions, answers) {
	    // Keep global reference to the answers
	    this.answers = _.isPlainObject(answers) ? {
	      ...answers
	    } : {};

	    // Make sure questions is an array.
	    if (_.isPlainObject(questions)) {
	      // It's either an object of questions or a single question
	      questions = Object.values(questions).every(v => _.isPlainObject(v) && v.name === undefined) ? Object.entries(questions).map(([name, question]) => ({
	        name,
	        ...question
	      })) : [questions];
	    }

	    // Create an observable, unless we received one as parameter.
	    // Note: As this is a public interface, we cannot do an instanceof check as we won't
	    // be using the exact same object in memory.
	    const obs = Array.isArray(questions) ? from(questions) : questions;
	    this.process = obs.pipe(concatMap(this.processQuestion.bind(this)), publish() // Creates a hot Observable. It prevents duplicating prompts.
	    );
	    this.process.connect();
	    return this.process.pipe(reduce((answersObj, answer) => {
	      _.set(answersObj, answer.name, answer.answer);
	      return answersObj;
	    }, this.answers)).toPromise(Promise).then(this.onCompletion.bind(this), this.onError.bind(this));
	  }

	  /**
	   * Once all prompt are over
	   */
	  onCompletion() {
	    this.close();
	    return this.answers;
	  }
	  onError(error) {
	    this.close();
	    return Promise.reject(error);
	  }
	  processQuestion(question) {
	    question = {
	      ...question
	    };
	    return defer(() => {
	      const obs = of(question);
	      return obs.pipe(concatMap(this.setDefaultType.bind(this)), concatMap(this.filterIfRunnable.bind(this)), concatMap(() => fetchAsyncQuestionProperty(question, 'message', this.answers)), concatMap(() => fetchAsyncQuestionProperty(question, 'default', this.answers)), concatMap(() => fetchAsyncQuestionProperty(question, 'choices', this.answers)), concatMap(this.fetchAnswer.bind(this)));
	    });
	  }
	  fetchAnswer(question) {
	    const Prompt = this.prompts[question.type];
	    this.activePrompt = new Prompt(question, this.rl, this.answers);
	    return defer(() => from(this.activePrompt.run().then(answer => ({
	      name: question.name,
	      answer
	    }))));
	  }
	  setDefaultType(question) {
	    // Default type to input
	    if (!this.prompts[question.type]) {
	      question.type = 'input';
	    }
	    return defer(() => of(question));
	  }
	  filterIfRunnable(question) {
	    if (question.askAnswered !== true && _.get(this.answers, question.name) !== undefined) {
	      return empty();
	    }
	    if (question.when === false) {
	      return empty();
	    }
	    if (typeof question.when !== 'function') {
	      return of(question);
	    }
	    const {
	      answers
	    } = this;
	    return defer(() => from(runAsync$1(question.when)(answers).then(shouldRun => {
	      if (shouldRun) {
	        return question;
	      }
	    })).pipe(filter$2(val => val != null)));
	  }
	}

	/**
	 * Inquirer.js
	 * A collection of common interactive command line user interfaces.
	 */


	/**
	 * Create a new self-contained prompt module.
	 */
	function createPromptModule(opt) {
	  const promptModule = function (questions, answers) {
	    let uiInstance;
	    try {
	      uiInstance = new PromptUI(promptModule.prompts, opt);
	    } catch (error) {
	      return Promise.reject(error);
	    }
	    const promise = uiInstance.run(questions, answers);

	    // Monkey patch the UI on the promise object so
	    // that it remains publicly accessible.
	    promise.ui = uiInstance;
	    return promise;
	  };
	  promptModule.prompts = {};

	  /**
	   * Register a prompt type
	   * @param {String} name     Prompt type name
	   * @param {Function} prompt Prompt constructor
	   * @return {inquirer}
	   */

	  promptModule.registerPrompt = function (name, prompt) {
	    promptModule.prompts[name] = prompt;
	    return this;
	  };

	  /**
	   * Register the defaults provider prompts
	   */

	  promptModule.restoreDefaultPrompts = function () {
	    this.registerPrompt('list', ListPrompt);
	    this.registerPrompt('input', InputPrompt);
	    this.registerPrompt('number', NumberPrompt);
	    this.registerPrompt('confirm', ConfirmPrompt);
	    this.registerPrompt('rawlist', RawListPrompt);
	    this.registerPrompt('expand', ExpandPrompt);
	    this.registerPrompt('checkbox', CheckboxPrompt);
	    this.registerPrompt('password', PasswordPrompt);
	    this.registerPrompt('editor', EditorPrompt);
	  };
	  promptModule.restoreDefaultPrompts();
	  return promptModule;
	}

	/**
	 * Public CLI helper interface
	 * @param  {Array|Object|Rx.Observable} questions - Questions settings array
	 * @param  {Function} cb - Callback being passed the user answers
	 * @return {ui.Prompt}
	 */

	const prompt = createPromptModule();

	// Expose helper functions on the top level for easiest usage by common users
	function registerPrompt(name, newPrompt) {
	  prompt.registerPrompt(name, newPrompt);
	}
	function restoreDefaultPrompts() {
	  prompt.restoreDefaultPrompts();
	}
	const inquirer = {
	  prompt,
	  ui: {
	    BottomBar,
	    Prompt: PromptUI
	  },
	  createPromptModule,
	  registerPrompt,
	  restoreDefaultPrompts,
	  Separator
	};

	var eslintConfig = function eslintConfig() {
	  var langType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	  var config = {
	    "extends": ["@ovyvo/eslint-config"],
	    parserOptions: {},
	    plugins: []
	  };
	  if (langType == 2) {
	    config["extends"] = [].concat(_toConsumableArray(config["extends"]), ["plugin:@typescript-eslint/recommended"]);
	    config.parserOptions = _objectSpread2(_objectSpread2({}, config.parserOptions), {
	      parse: "@typescript-eslint/parser"
	    });
	    config.plugins = [].concat(_toConsumableArray(config.plugins), ["@typescript-eslint"]);
	  }
	  return "module.exports = ".concat(JSON.stringify(config, null, 2), ";\n");
	};

	var eslintIgnore = function eslintIgnore() {
	  return "\n  *.sh\n  *.sh\n  *.md\n  *.woff\n  *.ttf\n  .vscode\n  .husky\n  .github\n  \n  node_modules\n  dist\n  ";
	};

	var initConfig = /*#__PURE__*/function () {
	  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	    var _ref2,
	      langType,
	      eslintFileContent,
	      ignoreFileContent,
	      _args = arguments;
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, langType = _ref2.langType;
	          _context.prev = 1;
	          // 
	          loading.start({
	            text: "..."
	          });
	          _context.next = 5;
	          return commandSpawn("pnpm", ["add", "@ovyvo/eslint-config", "-D"], {
	            cwd: process.cwd(),
	            stdio: "pipe"
	          });
	        case 5:
	          loading.succeed(wSuccess(" "));
	          // 
	          if (!(langType == 2)) {
	            _context.next = 11;
	            break;
	          }
	          loading.start({
	            text: "..."
	          });
	          _context.next = 10;
	          return commandSpawn("pnpm", ["add", "@typescript-eslint/parser", "-D"], {
	            cwd: process.cwd(),
	            stdio: "pipe"
	          });
	        case 10:
	          loading.succeed(wSuccess(" "));
	        case 11:
	          // .eslint.cjs
	          loading.start({
	            text: " .eslint.cjs..."
	          });
	          eslintFileContent = eslintConfig(langType);
	          _context.next = 15;
	          return writeFile(process.cwd(), ".eslint.cjs", eslintFileContent);
	        case 15:
	          loading.succeed(wSuccess(" .eslint.cjs..."));
	          // .eslintignore
	          loading.start({
	            text: " .eslintignore..."
	          });
	          ignoreFileContent = eslintIgnore();
	          _context.next = 20;
	          return writeFile(process.cwd(), ".eslintignore", ignoreFileContent);
	        case 20:
	          loading.succeed(wSuccess(" .eslintignore..."));
	          _context.next = 27;
	          break;
	        case 23:
	          _context.prev = 23;
	          _context.t0 = _context["catch"](1);
	          cError("\uD83D\uDEA8\u62B1\u6B49, \u521D\u59CB\u5316\u5931\u8D25\uFF01\u62A5\u9519\u4FE1\u606F: ".concat(_context.t0));
	          loading.clear();
	        case 27:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee, null, [[1, 23]]);
	  }));
	  return function initConfig() {
	    return _ref.apply(this, arguments);
	  };
	}();

	var handlerInit = /*#__PURE__*/function () {
	  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	    var _yield$inquirer$promp, langType;
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return inquirer.prompt({
	            type: "list",
	            name: "langType",
	            message: "\u60A8\u7684\u9879\u76EE\u4F7F\u7528\u4EC0\u4E48\u8BED\u8A00\uFF1F",
	            choices: [{
	              name: "JavaScript",
	              value: 1
	            }, {
	              name: "TypeScript",
	              value: 2
	            }]
	          });
	        case 2:
	          _yield$inquirer$promp = _context.sent;
	          langType = _yield$inquirer$promp.langType;
	          initConfig({
	            langType: langType
	          });
	        case 5:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee);
	  }));
	  return function handlerInit() {
	    return _ref.apply(this, arguments);
	  };
	}();

	var createCommands = function createCommands(program) {
	  program.command("init").description("Initialize eslint configuration. Currently only supports Vue").action(handlerInit);
	};

	var program = new Command();

	// 
	helpOptions(program);
	// 
	createCommands(program);
	program.parse(process.argv);

}));
